import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as n,f as l}from"./app-b8d2a4ee.js";const e={},t=l('<h1 id="a-数据结构与算法总体概述" tabindex="-1"><a class="header-anchor" href="#a-数据结构与算法总体概述" aria-hidden="true">#</a> a.数据结构与算法总体概述</h1><h2 id="数据结构概述" tabindex="-1"><a class="header-anchor" href="#数据结构概述" aria-hidden="true">#</a> 数据结构概述</h2><h3 id="数据结构是什么" tabindex="-1"><a class="header-anchor" href="#数据结构是什么" aria-hidden="true">#</a> 数据结构是什么?</h3><p>程序=数据结构+算法（底层使用）</p><p><strong>程序=框架+业务逻辑</strong></p><p><strong>数据结构</strong>是为了高效访问数据而设计出的一种数据的**<u>组织和存储方式</u><strong>。更具体的说，一个数据结构包含一个</strong>数据元素的集合、数据元素之间的关系以及访问和操作数据的方法.**</p><p><u><strong>高效访问数据</strong>：</u></p><p><u>数据的组织和存储方式。</u></p><p><u>数据元素的集合。</u></p><p><u>访问和操作数据的方法。</u></p><p>一般而言，数据结构针对的是内存中的数据，所以在学习数据结构之前，需要先对内存有一个简单的了解。</p><p><strong>内存</strong>是由许多<strong>存储单元</strong>组成，每个存储单元可以存储一个固定大小的<strong>数据块</strong>，通常以<strong>字节（byte）<strong>为单位。每个存储单元都有一个</strong>唯一的地址</strong>，操作系统正是根据这一地址去访问内存中的数据的。我们讨论的数据结构中的数据元素就是保存在这些一个个的内存单元中，这些数据元素或存储在<strong>连续</strong>的内存单元中，或存储在<strong>分散</strong>的内存单元中。</p><table><thead><tr><th>连续存储</th><th>分散存储</th></tr></thead><tbody><tr><td>数组</td><td>链表</td></tr></tbody></table><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105140308751.png" alt="数据结构存储方式" tabindex="0" loading="lazy"><figcaption>数据结构存储方式</figcaption></figure><h3 id="数据结构类型" tabindex="-1"><a class="header-anchor" href="#数据结构类型" aria-hidden="true">#</a> 数据结构类型</h3><h4 id="线性结构" tabindex="-1"><a class="header-anchor" href="#线性结构" aria-hidden="true">#</a> 线性结构</h4><p>数据元素按照顺序进行排列，强调数据元素的前后或者升降顺序</p><ul><li>数组</li><li>链表</li><li>栈</li><li>队列</li></ul><h4 id="非线性结构" tabindex="-1"><a class="header-anchor" href="#非线性结构" aria-hidden="true">#</a> 非线性结构</h4><ul><li>树</li></ul><p>所有数据元素按照层次结构进行组织，强调元素之间的父子关系</p><ul><li>图</li></ul><p>由定点和边组成，顶点对应数据元素，边链接两个顶点，表示两个数项元素之间的关系。图形结构用于表达元素之间复杂的网络关系。</p><ul><li>其他 <ul><li>二维数组</li><li>多维数组</li><li>..............</li></ul></li></ul><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结：</h4><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105141116912.png" alt="数据结构类型" tabindex="0" loading="lazy"><figcaption>数据结构类型</figcaption></figure><h2 id="算法概述" tabindex="-1"><a class="header-anchor" href="#算法概述" aria-hidden="true">#</a> 算法概述</h2><h3 id="算法是什么" tabindex="-1"><a class="header-anchor" href="#算法是什么" aria-hidden="true">#</a> 算法是什么</h3><p>算法是一个用于解决特定问题的优先<strong>指令序列</strong>（计算可以执行的操作）</p><h3 id="常见算法分类" tabindex="-1"><a class="header-anchor" href="#常见算法分类" aria-hidden="true">#</a> 常见算法分类</h3><h4 id="常见搜索算法" tabindex="-1"><a class="header-anchor" href="#常见搜索算法" aria-hidden="true">#</a> 常见搜索算法</h4><p>针对树形结构：</p><ul><li><p>深度优先搜索：纵向</p></li><li><p>广度优先搜索：一层一层进行搜索</p></li></ul><h4 id="常见排序算法" tabindex="-1"><a class="header-anchor" href="#常见排序算法" aria-hidden="true">#</a> 常见排序算法</h4><ul><li><p>冒泡排序：相邻做比较</p></li><li><p>选择排序：首尾做比较</p></li><li><p>插入排序</p></li><li><p>快速排序</p></li><li><p>归并排序</p></li><li><p>堆排序</p></li><li><p>桶排序</p></li><li><p>基数排序</p></li><li><p>希尔排序</p></li><li><p>计数排序</p></li><li><p>位图排序</p></li><li><p>其它排序</p></li></ul><h4 id="常见查找算法" tabindex="-1"><a class="header-anchor" href="#常见查找算法" aria-hidden="true">#</a> 常见查找算法</h4><p>查找算法和搜索算法不一样，查找是找一个，搜索是找多个。</p><ul><li><p><strong>顺序查找</strong></p></li><li><p><strong>二分查找</strong>：折半查找</p></li></ul><p>需要是有序数据：1,3,6,<strong>10</strong>,20,34（从10开始进行查找）</p><ul><li><p>插值查找</p></li><li><p>斐波那契查找</p></li><li><p>分块查找</p></li><li><p>哈希查找</p></li><li><p>其它查找</p></li></ul><h4 id="常见实现策略算法" tabindex="-1"><a class="header-anchor" href="#常见实现策略算法" aria-hidden="true">#</a> 常见实现策略算法</h4><ul><li><p>暴力破解</p></li><li><p>增量</p></li><li><p>分治</p></li><li><p><strong>动态规划</strong></p></li><li><p>贪心算法</p></li><li><p><strong>递归</strong></p></li></ul><h3 id="如何评价一个算法的好坏" tabindex="-1"><a class="header-anchor" href="#如何评价一个算法的好坏" aria-hidden="true">#</a> 如何评价一个算法的好坏</h3><p><strong>一个算法的好坏是通过时间复杂度和空间复杂度来恒量的</strong></p><p><strong>解决特定问题有很多实现方式，找到一种最优的实现方式，找到一种最优算法</strong></p><p>简单来说：</p><p>所花的时间与占用内存便是衡量一个算法好坏的标准</p><ul><li>时间复杂度：就是执行算法的时间成本，随着程序执行次数增多，时间变化值是如何的（运行时间越小越好）</li><li>空间复杂度：就是执行算法的内存空间成本（实际中并不考虑，实际中可以进行物理拓展【添加内训，增加配件特性】，使用空间换取时间，一般不衡量这个东西）</li></ul><p>使用空间换取时间：</p><p>两个指标一般不能同时进行满足。</p><p>时间复杂度使用一种特殊的方式进行表示就是O表示法</p><h3 id="高中数学-对数函数vs指数函数复习" tabindex="-1"><a class="header-anchor" href="#高中数学-对数函数vs指数函数复习" aria-hidden="true">#</a> 高中数学：对数函数vs指数函数复习</h3><p>指数函数：次方</p><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231106095930120.png" alt="指数函数" tabindex="0" loading="lazy"><figcaption>指数函数</figcaption></figure><p>对数函数：以2为底8的对数</p><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231106095912641.png" alt="对数函数" tabindex="0" loading="lazy"><figcaption>对数函数</figcaption></figure><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105142154769.png" alt="对数课本内容" tabindex="0" loading="lazy"><figcaption>对数课本内容</figcaption></figure><p><strong>补充说明</strong></p><p>在描述算法复杂度时，经常用到o(1)， o(n)， o(logn)， o(nlogn)来表示对应算法的时间复杂度，这是算法的时间复杂度的表示。</p><p>O后面的括号中有一个函数，指明某个算法的耗时与数据增长量之间的关系。其中的n代表输入数据的量。</p><p>O(n)：n表示代码执行次数和数据量，代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。</p><p>O(logn)：当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</p><p>O(nlogn)：n乘以logn，当数据增大256倍时，耗时增256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。</p><p>O(1)：最低的时空复杂度，也就是耗时与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</p><p>O(1)：无论多少数据执行都是1</p><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105142728539.png" alt="复杂度表" tabindex="0" loading="lazy"><figcaption>复杂度表</figcaption></figure><h3 id="复杂度的大欧o-x-表示法" tabindex="-1"><a class="header-anchor" href="#复杂度的大欧o-x-表示法" aria-hidden="true">#</a> 复杂度的大欧O(X)表示法</h3><ul><li><p>时间复杂度 与 空间复杂度 都是用 “大O” 来表示(大欧表示法)，写作 O(*)</p></li><li><p>由于目前内存便宜，此刻我们谈论复杂度</p><ul><li>一般谈论的都是时间复杂度</li></ul></li><li><p>时间复杂度BigO，大欧表示法</p></li></ul><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105142849942.png" alt="复杂度大O（X）" tabindex="0" loading="lazy"><figcaption>复杂度大O（X）</figcaption></figure><p>量级增加时，时间增长的趋势。</p><ul><li>常见时间复杂度的 “大O表示法” 描述有以下几种</li></ul><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105142923590.png" alt=" 时间复杂度和空间复杂度的关系" tabindex="0" loading="lazy"><figcaption> 时间复杂度和空间复杂度的关系</figcaption></figure><h2 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h2><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105143031571.png" alt="时间复杂度排序" tabindex="0" loading="lazy"><figcaption>时间复杂度排序</figcaption></figure><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231105143053426.png" alt="排序比较" tabindex="0" loading="lazy"><figcaption>排序比较</figcaption></figure><figure><img src="https://daimakuai.oss-cn-beijing.aliyuncs.com/img/image-20231106103540574.png" alt="nlogN" tabindex="0" loading="lazy"><figcaption>nlogN</figcaption></figure>',76),r=[t];function p(g,o){return a(),n("div",null,r)}const h=i(e,[["render",p],["__file","1.数据结构与算法总体概述.html.vue"]]);export{h as default};
