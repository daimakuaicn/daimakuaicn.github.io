const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const l of e.keys())if(l===F){const a=o[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=u;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=o[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=o[f+y]+ +b,A=o[f+y+1]+1,w=o[p+y]+1,L=o[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,o,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const l=new Map;l.set(u.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(u),e=l}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const l of Object.keys(u)){const a=u[l],h=e._fieldIds[l],m=o.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:N(n.boost,g)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,o,u,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,o,u,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,o,u,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(u),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=k(u),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(u,d)),u=l,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),l=u.includes("#"),[a,h]=u.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>o.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(o.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in o)for(const c of o.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":278,\"nextId\":278,\"documentIds\":{\"0\":\"v-2e3eac9e\",\"1\":\"v-2e3eac9e#幻灯片演示\",\"2\":\"v-2e3eac9e#标注幻灯片\",\"3\":\"v-2e3eac9e#标注幻灯片-1\",\"4\":\"v-2e3eac9e#markdown\",\"5\":\"v-2e3eac9e#markdown-1\",\"6\":\"v-2e3eac9e#这是一个-h3\",\"7\":\"v-2e3eac9e#markdown-2\",\"8\":\"v-2e3eac9e#markdown-3\",\"9\":\"v-2e3eac9e#markdown-4\",\"10\":\"v-2e3eac9e#markdown-5\",\"11\":\"v-2e3eac9e#布局\",\"12\":\"v-2e3eac9e#布局-1\",\"13\":\"v-2e3eac9e#布局-2\",\"14\":\"v-2e3eac9e#布局-3\",\"15\":\"v-2e3eac9e#背景\",\"16\":\"v-2e3eac9e#动画片段\",\"17\":\"v-2e3eac9e#动画片段-1\",\"18\":\"v-2e3eac9e#动画片段-2\",\"19\":\"v-2e3eac9e#动画-class\",\"20\":\"v-2e3eac9e#动画片段-3\",\"21\":\"v-2e3eac9e#动画-class-1\",\"22\":\"v-2e3eac9e#动画片段-4\",\"23\":\"v-2e3eac9e#多个动画片段\",\"24\":\"v-2e3eac9e#动画片段-5\",\"25\":\"v-2e3eac9e#顺序\",\"26\":\"v-2e3eac9e#渐变\",\"27\":\"v-2e3eac9e#渐变-1\",\"28\":\"v-2e3eac9e#渐变-2\",\"29\":\"v-2e3eac9e#过渡动画\",\"30\":\"v-2e3eac9e#功能\",\"31\":\"v-2e3eac9e#功能-1\",\"32\":\"v-2e3eac9e#代码\",\"33\":\"v-2e3eac9e#功能-2\",\"34\":\"v-2e3eac9e#预览模式\",\"35\":\"v-2e3eac9e#功能-3\",\"36\":\"v-2e3eac9e#全屏模式\",\"37\":\"v-2e3eac9e#功能-4\",\"38\":\"v-2e3eac9e#缩放\",\"39\":\"v-2e3eac9e#结束\",\"40\":\"v-6956c0b7\",\"41\":\"v-6956c0b7#目录\",\"42\":\"v-6956c0b7@0\",\"43\":\"v-7fb92488\",\"44\":\"v-7fb92488#_1-基本概念\",\"45\":\"v-7fb92488#_1-1单体架构\",\"46\":\"v-7fb92488#_1-2微服务架构\",\"47\":\"v-7fb92488#_2-springcloud初体验\",\"48\":\"v-7fb92488#_2-1什么是springcloud\",\"49\":\"v-7fb92488#_2-2springcloud组成\",\"50\":\"v-7fb92488#_2-3springcloud初体验\",\"51\":\"v-7fb92488#_2-3-1工程结构说明\",\"52\":\"v-7fb92488#_2-3-2-父工程搭建\",\"53\":\"v-7fb92488#_2-3-3子工程搭建\",\"54\":\"v-7fb92488#_2-4-1传统调用\",\"55\":\"v-7fb92488#_2-4-2传统方式调用的问题所在\",\"56\":\"v-7fb92488#_2-4-3其他问题须知\",\"57\":\"v-7fb92488#_3-nacos注册中心\",\"58\":\"v-7fb92488#_3-1-nacos注册中心简介\",\"59\":\"v-7fb92488#_3-2注册中心产品\",\"60\":\"v-7fb92488#eurela\",\"61\":\"v-7fb92488#nacos\",\"62\":\"v-7fb92488#_3-3微服务集成nacos\",\"63\":\"v-7fb92488#_3-3-1准备工作\",\"64\":\"v-7fb92488#_3-3-2远程调用\",\"65\":\"v-7fb92488#_3-3-2-1方案一\",\"66\":\"v-7fb92488#_3-3-2-2方案二\",\"67\":\"v-7fb92488#_3-4nacos高级特性-服务集群\",\"68\":\"v-7fb92488#_3-4-1服务集群\",\"69\":\"v-7fb92488#_3-4-1-1集群概述\",\"70\":\"v-7fb92488#_3-4-1-2集群配置\",\"71\":\"v-7fb92488#_3-4-1-3集群访问\",\"72\":\"v-7fb92488#_3-5nacos高级特性-权重配置-了解\",\"73\":\"v-7fb92488#_3-6nacos高级特性-环境隔离\",\"74\":\"v-7fb92488#_3-6-1环境隔离概述\",\"75\":\"v-7fb92488#_3-6-2创建名称空间\",\"76\":\"v-7fb92488#_3-6-3微服务配置名称空间\",\"77\":\"v-7fb92488#_3-7nacos高级特性-实例类型\",\"78\":\"v-7fb92488#_4-loadbalancer\",\"79\":\"v-7fb92488#_4-1简介\",\"80\":\"v-7fb92488#_4-2-loadbalancer的执行流程\",\"81\":\"v-7fb92488#_4-3源码跟踪\",\"82\":\"v-7fb92488#_4-4补充知识-负载均衡算法\",\"83\":\"v-7fb92488#_4-5更改负载均衡算法\",\"84\":\"v-7fb92488#_5-openfeign组件\",\"85\":\"v-7fb92488#_5-1openfeign组件介绍\",\"86\":\"v-7fb92488#_5-2openfeign初体验\",\"87\":\"v-7fb92488#_5-3openfeign自定义配置\",\"88\":\"v-7fb92488#_5-3-1-日志配置\",\"89\":\"v-7fb92488#基于配置文件的方式\",\"90\":\"v-7fb92488#java代码的方式\",\"91\":\"v-7fb92488#_5-3-2-超时配置\",\"92\":\"v-7fb92488#_5-3-3-重试配置\",\"93\":\"v-7fb92488#_5-4代码优化\",\"94\":\"v-7fb92488#_6-gateway组件\",\"95\":\"v-7fb92488#_6-1认识gateway\",\"96\":\"v-7fb92488#_6-2三个核心概念\",\"97\":\"v-7fb92488#_6-2-1路由\",\"98\":\"v-7fb92488#_6-2-2断言-匹配关系\",\"99\":\"v-7fb92488#_6-2-3过滤器\",\"100\":\"v-7fb92488#_6-3gateway工作流程\",\"101\":\"v-7fb92488#_6-4gateway初体验\",\"102\":\"v-7fb92488#_6-5predicate的使用-路由断言工厂\",\"103\":\"v-7fb92488#_6-6过滤器\",\"104\":\"v-7fb92488#_6-6-1-过滤器简介\",\"105\":\"v-7fb92488#_6-6-2-内置过滤器\",\"106\":\"v-7fb92488#_6-6-3-路由过滤器\",\"107\":\"v-7fb92488#_6-6-4-默认过滤器\",\"108\":\"v-7fb92488#_6-6-5-全局过滤器\",\"109\":\"v-7fb92488#_6-6-6-过滤器执行顺序\",\"110\":\"v-7fb92488#_7-nacos配置中心\",\"111\":\"v-7fb92488#_7-1-统一配置管理\",\"112\":\"v-7fb92488#_7-2-nacos入门\",\"113\":\"v-7fb92488#_7-2-1-nacos中添加配置\",\"114\":\"v-7fb92488#_7-2-2-微服务集成配置中心\",\"115\":\"v-7fb92488#_7-2-3-读取自定义配置\",\"116\":\"v-7fb92488#value\",\"117\":\"v-7fb92488#configurationproperties\",\"118\":\"v-7fb92488#_7-3-配置热更新\",\"119\":\"v-7fb92488#_7-4-配置优先级\",\"120\":\"v-7fb92488#_8-sentinel部分\",\"121\":\"v-7fb92488#_8-1-初识sentinel\",\"122\":\"v-7fb92488#_8-1-1-雪崩效应\",\"123\":\"v-7fb92488#_8-1-2-解决方案\",\"124\":\"v-7fb92488#超时处理\",\"125\":\"v-7fb92488#隔离处理\",\"126\":\"v-7fb92488#熔断处理\",\"127\":\"v-7fb92488#流量控制\",\"128\":\"v-7fb92488#最终的目的\",\"129\":\"v-7fb92488#qps-query-per-seconds\",\"130\":\"v-7fb92488#阈值\",\"131\":\"v-7fb92488#_8-1-3-sentinel介绍\",\"132\":\"v-7fb92488#_8-2-sentinel入门\",\"133\":\"v-7fb92488#_8-2-1-下载sentinel控制台\",\"134\":\"v-7fb92488#_8-2-2-启动sentinel\",\"135\":\"v-7fb92488#_8-2-3-访问sentinel\",\"136\":\"v-7fb92488#_8-2-4-整合sentinel\",\"137\":\"v-7fb92488#_8-3-流量控制\",\"138\":\"v-7fb92488#_8-3-1-相关概念\",\"139\":\"v-7fb92488#_8-3-2-快速入门\",\"140\":\"v-7fb92488#_8-3-3-流控模式\",\"141\":\"v-7fb92488#流控模式简介\",\"142\":\"v-7fb92488#关联模式\",\"143\":\"v-7fb92488#链路模式\",\"144\":\"v-7fb92488#_8-3-4-流控效果\",\"145\":\"v-7fb92488#warm-up\",\"146\":\"v-7fb92488#排队等待\",\"147\":\"v-7fb92488#_8-3-5-热点参数限流\",\"148\":\"v-7fb92488#配置介绍\",\"149\":\"v-7fb92488#案例演示\",\"150\":\"v-7fb92488@0\",\"151\":\"v-7fb92488@1\",\"152\":\"v-0ca0a1de\",\"153\":\"v-0ca0a1de#你好\",\"154\":\"v-bf8335d6\",\"155\":\"v-bf8335d6#你好\",\"156\":\"v-630be83f\",\"157\":\"v-630be83f#你好\",\"158\":\"v-6a5e6a4e\",\"159\":\"v-6a5e6a4e#_1-1-介绍\",\"160\":\"v-6a5e6a4e#_1-2-注解\",\"161\":\"v-6a5e6a4e#_1-3-入门程序\",\"162\":\"v-6a5e6a4e#_1-4-其他注解\",\"163\":\"v-6a5e6a4e#cacheput\",\"164\":\"v-6a5e6a4e#cacheevict\",\"165\":\"v-6a5e6a4e#_1-5-缓存所有分类数据\",\"166\":\"v-6a5e6a4e@0\",\"167\":\"v-6a5e6a4e@1\",\"168\":\"v-a6a67866\",\"169\":\"v-a6a67866#你好\",\"170\":\"v-30fe51b6\",\"171\":\"v-30fe51b6#你好\",\"172\":\"v-45516948\",\"173\":\"v-45516948#你好\",\"174\":\"v-42e65f52\",\"175\":\"v-42e65f52#你好\",\"176\":\"v-06812826\",\"177\":\"v-06812826#你好\",\"178\":\"v-106e5de3\",\"179\":\"v-106e5de3#数据结构概述\",\"180\":\"v-106e5de3#数据结构是什么\",\"181\":\"v-106e5de3#数据结构类型\",\"182\":\"v-106e5de3#线性结构\",\"183\":\"v-106e5de3#非线性结构\",\"184\":\"v-106e5de3#小结\",\"185\":\"v-106e5de3#算法概述\",\"186\":\"v-106e5de3#算法是什么\",\"187\":\"v-106e5de3#常见算法分类\",\"188\":\"v-106e5de3#常见搜索算法\",\"189\":\"v-106e5de3#常见排序算法\",\"190\":\"v-106e5de3#常见查找算法\",\"191\":\"v-106e5de3#常见实现策略算法\",\"192\":\"v-106e5de3#如何评价一个算法的好坏\",\"193\":\"v-106e5de3#高中数学-对数函数vs指数函数复习\",\"194\":\"v-106e5de3#复杂度的大欧o-x-表示法\",\"195\":\"v-106e5de3#小结-1\",\"196\":\"v-06e53829\",\"197\":\"v-06e53829#基础知识\",\"198\":\"v-06e53829#数组优缺点\",\"199\":\"v-06e53829#优点\",\"200\":\"v-06e53829#缺点\",\"201\":\"v-06e53829#架构设计一个通用数组-考虑封装思想\",\"202\":\"v-06e53829#约定变量\",\"203\":\"v-06e53829#正序和反序打印数组\",\"204\":\"v-06e53829#小口诀\",\"205\":\"v-06e53829#普通版步骤v1\",\"206\":\"v-06e53829#封装数组泛型版v2\",\"207\":\"v-06e53829#规范的定制化接口imyarray\",\"208\":\"v-06e53829#完善数组封装\",\"209\":\"v-06e53829#leetcode数组练习经典题-反转字符串\",\"210\":\"v-06e53829#任务1-arraylist底层结构和扩容机制\",\"211\":\"v-06e53829#复习arraylist集合\",\"212\":\"v-06e53829#底层源码分析\",\"213\":\"v-06e53829#任务2-hashmap底层结构和扩容机制\",\"214\":\"v-06e53829#_1-hashmap无参数构造方法的分析\",\"215\":\"v-06e53829#_2-hashmap有参数构造方法分析\",\"216\":\"v-06e53829#_3-tablesizefor方法分析\",\"217\":\"v-06e53829#_4-node-内部类分析\",\"218\":\"v-06e53829#_5-存储元素的put方法源码\",\"219\":\"v-06e53829#_6-putval方法源码\",\"220\":\"v-06e53829#_7-resize方法的扩容计算\",\"221\":\"v-06e53829#_8-确定元素存储的索引\",\"222\":\"v-06e53829#_9-遇到重复哈希值的对象\",\"223\":\"v-06e53829#任务3-interface接口里面写什么类型方法-函数式接口\",\"224\":\"v-06e53829#任务4-完成反转字符串代码\",\"225\":\"v-06e53829#任务5-今天封装数组代码\",\"226\":\"v-542b239b\",\"227\":\"v-542b239b#基础知识\",\"228\":\"v-542b239b#栈是什么\",\"229\":\"v-542b239b#栈的相关操作\",\"230\":\"v-542b239b#架构设计一个通用栈-考虑封装思想\",\"231\":\"v-542b239b#判断条件\",\"232\":\"v-542b239b#istackdesc栈接口\",\"233\":\"v-542b239b#mystack\",\"234\":\"v-542b239b#对象游离-loitering\",\"235\":\"v-24f03360\",\"236\":\"v-24f03360#基础知识\",\"237\":\"v-24f03360#队列是什么queue\",\"238\":\"v-24f03360#结构设计一个队列-考虑封装问题\",\"239\":\"v-24f03360#判断条件\",\"240\":\"v-24f03360#队列接口iqueuedesc\",\"241\":\"v-24f03360#myqueue\",\"242\":\"v-dd4b063e\",\"243\":\"v-dd4b063e#基础知识\",\"244\":\"v-dd4b063e#链表的优缺点\",\"245\":\"v-dd4b063e#优点\",\"246\":\"v-dd4b063e#缺点\",\"247\":\"v-dd4b063e#架构设计一个单链表-考虑封装问题\",\"248\":\"v-dd4b063e#构造node节点\",\"249\":\"v-dd4b063e#初始化定义-mylinkedlistv1\",\"250\":\"v-dd4b063e#第1版mylinkedlistv1\",\"251\":\"v-dd4b063e#增-改进版本\",\"252\":\"v-dd4b063e#第2版mylinkedlistv2\",\"253\":\"v-dd4b063e#第3版mylinkedlistv3\",\"254\":\"v-dd4b063e#小总结\",\"255\":\"v-dd4b063e#leetcode链表练习经典题-课堂练习\",\"256\":\"v-dd4b063e#反转链表\",\"257\":\"v-5e5ce88e\",\"258\":\"v-5e5ce88e#你好\",\"259\":\"v-d735e2f2\",\"260\":\"v-53e15426\",\"261\":\"v-98496e7c\",\"262\":\"v-1303aad4\",\"263\":\"v-87f2a5ce\",\"264\":\"v-5e30028c\",\"265\":\"v-56414a89\",\"266\":\"v-708b954b\",\"267\":\"v-bf2428fc\",\"268\":\"v-7905e09c\",\"269\":\"v-43bb8f9e\",\"270\":\"v-497f9ffe\",\"271\":\"v-7e6a80ec\",\"272\":\"v-638319dc\",\"273\":\"v-73197d7b\",\"274\":\"v-e831d0fc\",\"275\":\"v-0c848d4a\",\"276\":\"v-02eec242\",\"277\":\"v-ae0131b8\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,2],\"1\":[1,5],\"2\":[1,2],\"3\":[1,12],\"4\":[1,4],\"5\":[1,4],\"6\":[2,11],\"7\":[1,11],\"8\":[1,12],\"9\":[1,10],\"10\":[1,8],\"11\":[1,1],\"12\":[1,7],\"13\":[1,8],\"14\":[1],\"15\":[1,5],\"16\":[1,1],\"17\":[1,6],\"18\":[1],\"19\":[2,10],\"20\":[1],\"21\":[2,9],\"22\":[1],\"23\":[1,8],\"24\":[1],\"25\":[1,9],\"26\":[1,1],\"27\":[1,15],\"28\":[1],\"29\":[1,8],\"30\":[1,1],\"31\":[1],\"32\":[1,20],\"33\":[1],\"34\":[1,6],\"35\":[1],\"36\":[1,6],\"37\":[1],\"38\":[1,9],\"39\":[1,2],\"40\":[1],\"41\":[1,5],\"42\":[null,null,1],\"43\":[1],\"44\":[2],\"45\":[2,15],\"46\":[2,52],\"47\":[2],\"48\":[2,10],\"49\":[2,26],\"50\":[2],\"51\":[3,5],\"52\":[3,81],\"53\":[3,100],\"54\":[3,65],\"55\":[3,9],\"56\":[3,7],\"57\":[2,5],\"58\":[3,18],\"59\":[2],\"60\":[1,2],\"61\":[1,36],\"62\":[2],\"63\":[2,44],\"64\":[2,4],\"65\":[3,65],\"66\":[3,49],\"67\":[3],\"68\":[3],\"69\":[4,45],\"70\":[4,33],\"71\":[4,25],\"72\":[5,39],\"73\":[3],\"74\":[3,20],\"75\":[3,5],\"76\":[3,24],\"77\":[3,22],\"78\":[2],\"79\":[2,10],\"80\":[3,11],\"81\":[2,43],\"82\":[4,6],\"83\":[2,55],\"84\":[2],\"85\":[2,16],\"86\":[2,81],\"87\":[2],\"88\":[4,39],\"89\":[1,44],\"90\":[1,30],\"91\":[4,54],\"92\":[3,68],\"93\":[2,95],\"94\":[2],\"95\":[2,18],\"96\":[2],\"97\":[4,1],\"98\":[5,9],\"99\":[4,4],\"100\":[2,28],\"101\":[2,111],\"102\":[4,84],\"103\":[2],\"104\":[3,9],\"105\":[3,37],\"106\":[3,55],\"107\":[3,32],\"108\":[3,86],\"109\":[2,79],\"110\":[2,7],\"111\":[3,15],\"112\":[3],\"113\":[4,7],\"114\":[3,49],\"115\":[4],\"116\":[2,37],\"117\":[2,62],\"118\":[3,16],\"119\":[3,11],\"120\":[2],\"121\":[3],\"122\":[3,16],\"123\":[4],\"124\":[1,9],\"125\":[1,18],\"126\":[1,47],\"127\":[1,19],\"128\":[1,2],\"129\":[4,2],\"130\":[1,5],\"131\":[4,78],\"132\":[3],\"133\":[4,11],\"134\":[3,31],\"135\":[4,18],\"136\":[4,45],\"137\":[3,5],\"138\":[4,39],\"139\":[4,61],\"140\":[3],\"141\":[1,23],\"142\":[1,89],\"143\":[1,103],\"144\":[4,22],\"145\":[2,61],\"146\":[1,68],\"147\":[4],\"148\":[1,34],\"149\":[1,73],\"150\":[null,null,1],\"151\":[null,null,1],\"152\":[1],\"153\":[1],\"154\":[1],\"155\":[1,1],\"156\":[1],\"157\":[1],\"158\":[2],\"159\":[2,19],\"160\":[3,27],\"161\":[3,129],\"162\":[3],\"163\":[2,41],\"164\":[2,26],\"165\":[3,78],\"166\":[null,null,3],\"167\":[null,null,1],\"168\":[1],\"169\":[1],\"170\":[1],\"171\":[1],\"172\":[1],\"173\":[1],\"174\":[1],\"175\":[1],\"176\":[1],\"177\":[1],\"178\":[2],\"179\":[1],\"180\":[2,31],\"181\":[1],\"182\":[1,6],\"183\":[1,13],\"184\":[2,1],\"185\":[1],\"186\":[1,3],\"187\":[1],\"188\":[1,5],\"189\":[1,14],\"190\":[1,19],\"191\":[1,6],\"192\":[1,21],\"193\":[2,52],\"194\":[3,21],\"195\":[1,3],\"196\":[2],\"197\":[1,29],\"198\":[1],\"199\":[2,5],\"200\":[2,11],\"201\":[2],\"202\":[1,2],\"203\":[1,40],\"204\":[1,6],\"205\":[1,123],\"206\":[1,65],\"207\":[1,5],\"208\":[1,33],\"209\":[2,28],\"210\":[2],\"211\":[1,39],\"212\":[1,101],\"213\":[2,79],\"214\":[2,24],\"215\":[2,53],\"216\":[2,40],\"217\":[3,29],\"218\":[2,19],\"219\":[2,22],\"220\":[2,29],\"221\":[2,44],\"222\":[2,42],\"223\":[4],\"224\":[2],\"225\":[2],\"226\":[2],\"227\":[2,4],\"228\":[1,2],\"229\":[1,9],\"230\":[2],\"231\":[1,3],\"232\":[1],\"233\":[1],\"234\":[3,11],\"235\":[2],\"236\":[1],\"237\":[1,14],\"238\":[2],\"239\":[1,3],\"240\":[1],\"241\":[1],\"242\":[2],\"243\":[1,12],\"244\":[1],\"245\":[1,7],\"246\":[1,11],\"247\":[2],\"248\":[1,1],\"249\":[2,1],\"250\":[1,1],\"251\":[3,1],\"252\":[1,1],\"253\":[1,1],\"254\":[1,1],\"255\":[2,1],\"256\":[1,1],\"257\":[1],\"258\":[1],\"259\":[1],\"260\":[1],\"261\":[1],\"262\":[1],\"263\":[1],\"264\":[2],\"265\":[1],\"266\":[1],\"267\":[2],\"268\":[1],\"269\":[1],\"270\":[1],\"271\":[1],\"272\":[1],\"273\":[1],\"274\":[1],\"275\":[1],\"276\":[2],\"277\":[1]},\"averageFieldLength\":[1.847797521019329,24.4607926526746,0.05948738124380718],\"storedFields\":{\"0\":{\"h\":\"幻灯片页\",\"t\":[\"@slidestart\"]},\"1\":{\"h\":\"幻灯片演示\",\"t\":[\"一个简单的幻灯片演示与各种小贴士。\",\"作者 Mr.Hope. 请滚动鼠标滚轮进入下一页\"]},\"2\":{\"h\":\"标注幻灯片\",\"t\":[\"👇\",\"--\"]},\"3\":{\"h\":\"标注幻灯片\",\"t\":[\"使用 --- 标注水平幻灯片\",\"在水平幻灯片中使用 -- 分割垂直幻灯片\",\"使用 <!-- .slide: ... --> 在幻灯片上添加属性\",\"使用 <!-- .element: ... --> 在前一个 HTML 元素上添加属性\"]},\"4\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\",\"--\"]},\"5\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\"]},\"6\":{\"h\":\"这是一个 H3\",\"t\":[\"标题默认会自动转换为大写。\",\"这是一个有着 粗体, 斜体, 删除线 文字并包含 一个链接 的段落，并且它会自动换行。所以你无需担心它的长度。\",\"--\"]},\"7\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\",\"列表默认为 inline-block\",\"项目\",\"项目\",\"项目\",\"项目 1\",\"项目 2\",\"项目 3\",\"--\"]},\"8\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\",\"在你启用 highlight 插件后，代码块会自动高亮。\",\"const a = 1; \",\"--\"]},\"9\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\",\"在你启用 math 插件后，你也可以使用 TEX 格式使用数学公式。\",\"--\"]},\"10\":{\"h\":\"Markdown\",\"t\":[\"你可以在幻灯片中使用 Markdown 语法的各种标记.\",\"⚠请注意: 表格和分割线，以及所有不在 Markdown 标准语法中的内容均不受支持。\"]},\"11\":{\"h\":\"布局\",\"t\":[\"--\"]},\"12\":{\"h\":\"布局\",\"t\":[\"👆 r-fit-text class 会让文字在不超出幻灯片范围的情况下尽可能大。\",\"--\"]},\"13\":{\"h\":\"布局\",\"t\":[\"Logo\",\"👆 r-stretch class 帮助你控制注入图片或视频的大小，使它们填充满幻灯片垂直方向上的剩余空间。\",\"--\"]},\"14\":{\"h\":\"布局\"},\"15\":{\"h\":\"背景\",\"t\":[\"你可以通过向特定幻灯片添加 data-background 属性自定义幻灯片背景.\"]},\"16\":{\"h\":\"动画片段\",\"t\":[\"--\"]},\"17\":{\"h\":\"动画片段\",\"t\":[\"动画片段用于高亮或显隐幻灯片中的元素。\",\"你需要在元素上添加 fragment 和动画 class。\",\"--\"]},\"18\":{\"h\":\"动画片段\"},\"19\":{\"h\":\"动画 class\",\"t\":[\"fade-in\",\"fade-out\",\"fade-up\",\"fade-down\",\"fade-left\",\"fade-right\",\"fade-in-then-out\",\"fade-in-then-semi-out\",\"--\"]},\"20\":{\"h\":\"动画片段\"},\"21\":{\"h\":\"动画 class\",\"t\":[\"grow\",\"shrink\",\"strike\",\"highlight-red\",\"highlight-green\",\"highlight-blue\",\"highlight-current-red\",\"highlight-current-green\",\"highlight-current-blue\",\"--\"]},\"22\":{\"h\":\"动画片段\"},\"23\":{\"h\":\"多个动画片段\",\"t\":[\"你可以按照顺序包裹一个 HTML 元素使其拥有多个动画片段 渐入 > 变红 > 渐出 \",\"--\"]},\"24\":{\"h\":\"动画片段\"},\"25\":{\"h\":\"顺序\",\"t\":[\"你可以使用 data-fragment-index 属性改变元素的动画顺序。\",\"不同元素可以有相同的动画顺序。\",\"最后显示\",\"第二个显示\",\"第一个显示\",\"第二个显示\"]},\"26\":{\"h\":\"渐变\",\"t\":[\"--\"]},\"27\":{\"h\":\"渐变\",\"t\":[\"Transition 可以通过配置中的 transition 选项全局设置，也可以通过在特定幻灯片添加 data-transition 属性局部设置.\",\"可能的值:\",\"none\",\"fade\",\"slide\",\"convex\",\"concave\",\"zoom\",\"--\"]},\"28\":{\"h\":\"渐变\"},\"29\":{\"h\":\"过渡动画\",\"t\":[\"你可以在相邻的幻灯片上添加 data-auto-animate 使相同的 HTML 元素产生过渡动画效果。\"]},\"30\":{\"h\":\"功能\",\"t\":[\"--\"]},\"31\":{\"h\":\"功能\"},\"32\":{\"h\":\"代码\",\"t\":[\"通过启用 highlight 插件，你可以对代码块进行高亮。\",\"你可以使用 [a-b|c-d] 语法来分布高亮特定行。\",\"let a = 1; let b = 2; let c = (x) => 1 + 2 + x; c(3); \",\"--\"]},\"33\":{\"h\":\"功能\"},\"34\":{\"h\":\"预览模式\",\"t\":[\"按下 Esc 或 O 即可在幻灯片获得焦点时进入预览模式。\",\"--\"]},\"35\":{\"h\":\"功能\"},\"36\":{\"h\":\"全屏模式\",\"t\":[\"按下 F 或 F11 即可在幻灯片获得焦点时进入全屏模式。\",\"--\"]},\"37\":{\"h\":\"功能\"},\"38\":{\"h\":\"缩放\",\"t\":[\"按下 alt (Linux 上使用 ctrl) 的同时点击幻灯片的任何元素，即可以向此元素进行放大。\",\"再次点击即可缩小。\"]},\"39\":{\"h\":\"结束\",\"t\":[\"@slideend\"]},\"40\":{\"h\":\"SpringBoot\"},\"41\":{\"h\":\"目录\",\"t\":[\"Markdown 展示\",\"页面展示\",\"禁用展示\",\"加密展示\"]},\"42\":{\"c\":[\"使用指南\"]},\"43\":{\"h\":\"SpringCloud\"},\"44\":{\"h\":\"1.基本概念\"},\"45\":{\"h\":\"1.1单体架构\",\"t\":[\"单体架构: 把项目中所有功能模块全部写在一个工程中\",\"缺点\",\"代码混乱,维护困难.\",\"修改一个功能,对其他功能产生影响,牵一发动全身.\",\"拓展性差,可靠性差,风险高\",\"优点\",\"结构简单,部署方便,易于维护\"]},\"46\":{\"h\":\"1.2微服务架构\",\"t\":[\"微服务架构: 微小服务,把一个完整项目,按照功能拆分成多个独立的服务模块,每个服务模块独立运行,独立部署,可以使用不同的数据库,可以使用不同的语言.\",\"image-20231025150308975\",\"优点:\",\"相互独立,谁修改某个服务,其他服务不受影响,解耦合\",\"可拓展性好\",\"容错性高\",\"高效性强\",\"灵活性强\",\"缺点:\",\"部署不是很方便\",\"微服务的管理\",\"服务间的通讯\",\"前端访问问题\",\"配置文件管理\",\"特点:\",\"单一职责:每个服务做到对应唯一业务能力\",\"自治:团队独立,数据独立,堵路部署和交付\",\"面向服务:服务提供唯一标准的接口,与语言和技术无关\",\"###1.3分布式和集群\",\"image-20231025150319539\",\"部署项目的时候,使用大于两台服务器进行部署:\",\"负载均衡:平均负担压力\",\"image-20231025150331327\",\"**集群:**多台服务器上部署相同的项目(内容)分担服务器访问压力\",\"每台服务器放的不同内容,不同模块.\",\"image-20231025150343310\",\"**分布式:**多台服务器上面部署不同内容模块\"]},\"47\":{\"h\":\"2.SpringCloud初体验\"},\"48\":{\"h\":\"2.1什么是SpringCloud\",\"t\":[\"SpringCloud并不是一种技术,springcloud是一系列框架或者组件的集合,springcloud里面包含了很多组件和框架,使用这些组件可以实现微服务架构.\",\"SpringCloud是一系列框架的有序集合.在SpringCloud这个项目中包含很多的组件,子框架,每一个组件都是用来解决问题架构中所遇到的问题,因此SpringCloud可以看做是一套微服务的解决方案.\",\"springcloud实现微服务架构离不开SpringBoot\"]},\"49\":{\"h\":\"2.2SpringCloud组成\",\"t\":[\"SpringCloud包含很多组件\",\"原生组件:由网飞公司开发,随着时间推迟,处于维护状态,不再更新.\",\"Spring Cloud alibaba组件:目前最流行的组件\",\"Spring Cloud 腾讯组件:\",\"SpringCloud组件自己研发的组件:GatWay网关\",\"常用组件\",\"⭐Nacos(注册中心,配置中心)\",\"⭐Openfeign(远程调用)\",\"⭐LoadBalancer(负载均衡)\",\"⭐Gateway(服务网关)\",\"⭐Sentinel(服务保护组件)\"]},\"50\":{\"h\":\"2.3SpringCloud初体验\"},\"51\":{\"h\":\"2.3.1工程结构说明\",\"t\":[\"在创建微服务工程的时候都需要先提供一个工程,使用父工程来管理多个微服务所需的依赖,我们的微服务系统结构如下:\",\"image-20231025150259507\"]},\"52\":{\"h\":\"2.3.2 父工程搭建\",\"t\":[\"步骤\",\"创建一个maven父工程\",\"添加依赖:\",\"<!-- 定义属性 --> <properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <spring-cloud.version>2022.0.2</spring-cloud.version> <spring-cloud-alibaba.version>2022.0.0.0-RC2</spring-cloud-alibaba.version> <mybatis-spring-boot.version>3.0.1</mybatis-spring-boot.version> <mysql.version>8.0.30</mysql.version> </properties> <!-- 指定spring boot父工程 --> <parent> <artifactId>spring-boot-starter-parent</artifactId> <groupId>org.springframework.boot</groupId> <version>3.0.5</version> </parent> <dependencyManagement> <!-- 在dependencyManagement标签中所定义的依赖不会被子工程直接进行继承 --> <dependencies> <!-- spring cloud的依赖 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-dependencies</artifactId> <version>${spring-cloud.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!-- spring cloud alibaba的依赖 --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-alibaba-dependencies</artifactId> <version>${spring-cloud-alibaba.version}</version> <type>pom</type> <scope>import</scope> </dependency> <!-- mysql的驱动 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>${mysql.version}</version> </dependency> <!-- mybatis和spring boot整合的起步依赖 --> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>${mybatis-spring-boot.version}</version> </dependency> </dependencies> </dependencyManagement> \",\"删除src目录\"]},\"53\":{\"h\":\"2.3.3子工程搭建\",\"t\":[\"创建子模块\",\"在子模块中添加依赖:\",\"<properties> <maven.compiler.source>17</maven.compiler.source> <maven.compiler.target>17</maven.compiler.target> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> </properties> <dependencies> <!-- spring boot的web开发所需要的起步依赖 --> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <!-- mysql的驱动 --> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> </dependency> <!-- mybatis和spring boot整合的起步依赖 --> <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> </dependency> <!-- lombok依赖，快速生成getter和setter方法 --> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> </dependencies> \",\"在resourse目录下面创建一个application.yml文件,文件如下:\",\"# 配置服务端口号 server: port: 10100 # 配置数据库的连接信息 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/spzx-cloud-user?characterEncoding=UTF8 username: root password: root # 配置mybatis的相关信息 mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl type-aliases-package: com.atguigu.spzx.cloud.user.entity mapper-locations: classpath:/mapper/*.xml \",\"###2.4 SpringCloud远程调用\",\"image-20231025150254012\",\"image-20231025150247970\"]},\"54\":{\"h\":\"2.4.1传统调用\",\"t\":[\"如果想完成上面的需求,我们就需要在Order为服务中向User微服务发起一个http请求,调用http://localhost:10100/api/user/findUserByuserId/{userId}这个接口\",\"第一步:在调用端order模块创建配置类,创建RestTemplate对象\",\"image-20231025181951482\",\"第二步:在调用端order模块创建User实体类,接收返回主句\",\"第三步:在Order实现类的方法使用RestTemplate发起远程调用(在Order微服务的Spring容器中注册一个RestTemplate)\",\"// com.atguigu.spzx.cloud.order.config; @Configuration public class RestTemplateConfiguration { @Bean public RestTemplate restTemplate() { return new RestTemplate() ; } } \",\"第四步:获取RestTemplate远程调用返回结果,数据封装\",\"public class OrderServiceImpl implement OrderService{ @AutoWired private RestTemplate restTemplate; @AutoWired private OrderMapper orderMapper; @Override public Order findOrderByOrderId(Long OrderId){ //根据Id查询订单数据 Order order = orderMapper.findOrderByOrderId(orderId); //发起远程调用 User User = restTemplate.getForObject(\\\"http://localhost:10100/api/user/findUserByUserId/1\\\"+order.getUserId(),User.class); order.serUser(user); //返回订单数据 return order; } } \"]},\"55\":{\"h\":\"2.4.2传统方式调用的问题所在\",\"t\":[\"维护性差:服务方提供IP地址发生改变,那么此时服务消费方就需要修改代码\",\"缺少负载均衡机制:负载均衡就是负载请求通过多台服务器进行处理\",\"image-20231025150240929\",\"image-20231025150235228\",\"image-20231025183404072\"]},\"56\":{\"h\":\"2.4.3其他问题须知\",\"t\":[\"SpringBoot \",\"SpringCloud是一系列框架集合,使用这些框架(组件)实现微服务\",\"SpringCloud实现微服务框架,必须使用SpringBoot\"]},\"57\":{\"h\":\"3.Nacos注册中心\",\"t\":[\"解决传统远程调用所存在的问题,SpringCloud Alibaba 提供了nacos注册中心:\"]},\"58\":{\"h\":\"3.1 Nacos注册中心简介\",\"t\":[\"通过注册中心可以对服务提供方和消费方解耦合.\",\"image-20231025150229500\",\"image-20231025183451126\",\"工作流程: 服务提供方在启动的时候,会向注册中心注册自己服务的详情信息(ip,端口号等).在注册中心会维护一张服务清单,保存这些注册信息,注册中心需要以心跳的方式去检测清单中的服务是否可用,如果不可用,需要在服务清单中剔除不可用的服务.\",\"服务消费方向服务注册中心咨询服务,并获取所有服务的实例清单,然后按照指定的负载均衡算法从服务清单中选择一个服务实例进行访问.\"]},\"59\":{\"h\":\"3.2注册中心产品\"},\"60\":{\"h\":\"Eurela\",\"t\":[\"image-20231025150223666\"]},\"61\":{\"h\":\"nacos\",\"t\":[\"image-20231025150218218\",\"docker安装nacos:\",\"# 拉取镜像 docker pull nacos/nacos-server:v2.2.2 # 创建容器 docker run --name nacos -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server:v2.2.2 # nacos2.x的版本新增了一个客户端与服务端的gRpc的通讯端口号9848 \",\"打开浏览器访问nacos的所提供的后端管理界面：http://192.168.136.142:8848/nacos\",\"用户名和密码：nacos/nacos\",\"nacos启动:\",\"#cmd方式进入bin里面,执行命令: startup.cmd -m standalone \"]},\"62\":{\"h\":\"3.3微服务集成nacos\"},\"63\":{\"h\":\"3.3.1准备工作\",\"t\":[\"需求：将两个微服务(user、order)注册到nacos中\",\"实现步骤：\",\"1、在两个子工程中引入如下依赖\",\"<!-- nacos作为注册中心的依赖 --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> \",\"2、在application.yml文件中添加如下配置\",\"spring: # 配置nacos注册中心的地址 cloud: nacos: discovery: server-addr: localhost:8848 application: name: spzx-cloud-user # 每一个服务注册到nacos注册中心都需要提供一个服务名称,order微服务注册的时候需要更改微服务名称 \",\"3、启动两个微服务：就可以在nacos的后台管理系统中，看到如下的注册信息：\",\"image-20230809100204178\"]},\"64\":{\"h\":\"3.3.2远程调用\",\"t\":[\"当我们把微服务都注册到注册中心以后，那么此时就可以根据服务的名称从注册中心获取服务的ip地址和端口号了，进而就可以更改远程调用代码！\"]},\"65\":{\"h\":\"3.3.2.1方案一\",\"t\":[\"使用到Spring Cloud中所提供的一个服务发现的客户端对象：DiscoveryClient。\",\"代码实现：\",\"@Service public class OrderServiceImpl implements OrderService { @Autowired // 注入RestTemplate远程调用工具 private RestTemplate restTemplate ; @Autowired private DiscoveryClient discoveryClient ; @Autowired private OrderMapper orderMapper ; @Override public Order findOrderByOrderId(Long orderId) { // 根据id查询订单数据 Order order = orderMapper.findOrderByOrderId(orderId); // 根据服务名称从注册中心中获取服务实例列表 ServiceInstance serviceInstance = chooseServiceInstance(\\\"spzx-cloud-user\\\"); // 发起远程调用 User user = restTemplate.getForObject(\\\"http://\\\" + serviceInstance.getHost() +\\\":\\\" + serviceInstance.getPort() +\\\"/api/user/findUserByUserId/\\\" + order.getUserId(), User.class); order.setUser(user); // 返回订单数据 return order; } // 根据服务的名称从注册中心中获取服务地址信息 public ServiceInstance chooseServiceInstance(String applicationName) { // 获取服务实例列表 List<ServiceInstance> instances = discoveryClient.getInstances(applicationName); // 编写一个简易的随机负载均衡算法 int size = instances.size(); Random random = new Random() ; int instanceIndex = random.nextInt(size); ServiceInstance serviceInstance = instances.get(instanceIndex); // 返回服务实例 return serviceInstance ; } } \",\"可以启动多个user微服务实例进行负载均衡的测试。\"]},\"66\":{\"h\":\"3.3.2.2方案二\",\"t\":[\"使用Spring Cloud中所提供的一个组件：spring-cloud-loadbalancer负载均衡\",\"使用步骤：\",\"1、在order微服务中添加依赖\",\"<!-- spring cloud 所提供的负载均衡器 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-loadbalancer</artifactId> </dependency> \",\"2、在声明RestTemplate的方法上添加**@LoadBalanced**注解\",\"@Bean @LoadBalanced // 让RestTemplate具有负载均衡的能力 public RestTemplate restTemplate() { return new RestTemplate() ; } \",\"3、更改远程调用代码\",\"// 服务提供方的服务ip地址和端口号可以使用服务提供方的服务名称进行替换 restTemplate.getForObject(\\\"http://spzx-cloud-user/api/user/findUserByUserId/\\\" + order.getUserId(), User.class); \",\"注意：默认使用的负载均衡算法就是轮询【依次调用对应服务】\"]},\"67\":{\"h\":\"3.4Nacos高级特性:服务集群\"},\"68\":{\"h\":\"3.4.1服务集群\"},\"69\":{\"h\":\"3.4.1.1集群概述\",\"t\":[\"在实际生产环境中，为了保证每一个服务的高可用，那么此时就需要去构建服务集群，但是并不是说把所有的服务都部署在一个机房里。而是将多个服务分散的部署到不同的机房中，每一个机房的服务可以看做成是一个集群。如下所示：\",\"image-20231025144212023\",\"微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：上海机房内的order微服务应该优先访问同机房的user微服务。\",\"image-20231025184553633\",\"根据机房进行配置,指定当前服务默认是哪个机房.保证集群的高可用\",\"❓怎么保证服务的高可用\",\"第一步:在User模块配置文件添加配置,指定访问集群机房\",\"第二步:在服务端User进行配置:配置所属区域\",\"第三步:在调用端Order进行配置:配置Order模块远程访问的集群是什么,配置负载均衡效果\",\"第四步:测试:如果错误,检查配置文件格式\",\"轮循环效果:其中一个地区服务器下线就会访问另外一个,恢复,会重新进行访问第一个.\",\"❌上线下线会重新访问原来的,如果是服务器挂了,就不会访问之前的了\",\"解决方案:把之前的缓存删除,重新进行启动\"]},\"70\":{\"h\":\"3.4.1.2集群配置\",\"t\":[\"修改spzx-cloud-user的application.yml文件，添加集群配置：\",\"spring: cloud: nacos: discovery: cluster-name: SH # 配置服务所属集群 \",\"启动三个服务user微服务实例，实例所属集群分配情况：实例1属于SH，实例2和实例3属于BJ\",\"通过添加添加JVM参数更改服务实例所属集群，启动实例2和实例3\",\"image-20230809102346561\",\"实例2：10101\",\"-Dserver.port=10101 -Dspring.cloud.nacos.discovery.cluster-name=BJ \",\"实例3：10103\",\"-Dserver.port=10103 -Dspring.cloud.nacos.discovery.cluster-name=BJ \",\"启动三个用户微服务实例，查看实例分配情况：\",\"image-20230503183655565\",\"image-20230503183721175\"]},\"71\":{\"h\":\"3.4.1.3集群访问\",\"t\":[\"需求：当order服务优先访问SH集群中的user微服务实例，当SH集群中的user微服务实例出现问题以后，在访问BJ集群中的实例。\",\"步骤：\",\"1、给order微服务的application.yml文件，添加集群配置：\",\"spring: cloud: nacos: discovery: cluster-name: SH # 配置服务所属集群 \",\"2、order微服务在loadbalancer组件中集成nacos\",\"spring: # 配置nacos注册中心的地址 cloud: loadbalancer: nacos: # 集成nacos的负载均衡算法 enabled: true \"]},\"72\":{\"h\":\"3.5Nacos高级特性:权重配置(了解)\",\"t\":[\"使用LoadBalance,默认效果是轮循机制,,我们可以设置权重,权重值越高,被访问的概率越大.一般来讲修改权重的概率不大,场景不多.了解.\",\"image-20231025144200255\",\"实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。\",\"但默认情况下Nacos的负载均衡算法是同集群内随机挑选，不会考虑机器的性能问题。\",\"因此，Nacos提供了权重配置来控制访问频率，权重越大则访问频率越高。\",\"在Nacos控制台，找到spzx-cloud-user的实例列表，点击编辑，即可修改权重：\",\"image-20230503185416608\",\"权重取值范围：0~1\",\"在配置文件中进行权重配置：\",\"spring: cloud: nacos: discovery: weight: 0.1 \",\"注意：如果权重修改为0，则该实例永远不会被访问\"]},\"73\":{\"h\":\"3.6Nacos高级特性:环境隔离\"},\"74\":{\"h\":\"3.6.1环境隔离概述\",\"t\":[\"在实际的开发过程中，可能会存在很多个软件环境：开发环境、测试环境、生产环境。\",\"nacos也是支持多环境隔离配置的，在nacos是通过namespace来实现多环境的隔离。\",\"完整的服务注册数据存储结构如下所示：\",\"image-20230503185847770\",\"namespace + group 才可以确定具体的微服务实例。默认情况下，所有service、group都在同一个namespace，名为public。如下所示：\",\"image-20230503190738675\"]},\"75\":{\"h\":\"3.6.2创建名称空间\",\"t\":[\"我们也可以创建新的名称空间，来将不同的服务隔离到不同的环境下面，如下所示：\",\"image-20230503191050511\"]},\"76\":{\"h\":\"3.6.3微服务配置名称空间\",\"t\":[\"给微服务添加名称空间的配置，来指定该微服务所属环境。\",\"例如，修改spzx-cloud-order的application.yml文件：\",\"spring: # 配置nacos注册中心的地址 cloud: nacos: discovery: namespace: 4a88035e-acf3-45a9-924f-2421acbff67a # 配置服务实例所属名称空间 \",\"此时order微服务所对应的服务实例就属于新的名称空间，user微服务所对应的服务实例属于public的名称空间，那么此时在进行远程调用的时候，就会出现如下的错误：\",\"image-20230503191655562\"]},\"77\":{\"h\":\"3.7Nacos高级特性:实例类型\",\"t\":[\"Nacos中的服务实例存在两种类型：\",\"1、临时实例：如果实例宕机超过一定时间，会从服务列表剔除，并且实例会定时上报自身的健康状态给Nacos注册中心，默认的类型。\",\"2、非临时实例：如果实例宕机，不会从服务列表剔除，Nacos注册中心会主动询问实例的健康状态，也可以叫永久实例。\",\"配置一个服务实例为永久实例：\",\"spring: cloud: nacos: discovery: ephemeral: false # 配置该实例为非临时实例 \"]},\"78\":{\"h\":\"4.LoadBalancer\"},\"79\":{\"h\":\"4.1简介\",\"t\":[\"Spring Cloud LoadBalancer是Spring Cloud中负责客户端负载均衡的模块，其主要原理是通过选择合适的服务实例来实现负载均衡。\",\"客户端负载均衡：就是负载均衡算法由客户端提供\",\"如下图所示：\",\"image-20230503213502251\"]},\"80\":{\"h\":\"4.2 LoadBalancer的执行流程\",\"t\":[\"image-20231025190315177\",\"通过LoadBalancerInterceptor请求拦截器拦截我们的RestTemplate请求:\",\"获取请求URL,然后从请求中获取提供方的主机名称\",\"然后调用LoadBalancerClient中execute方法,将服务提供方的名称传递过去\",\"在LoadBalancerClient的choose方法通过ReactiveLoadBalancer.Factory从Nacos注册中心获取列表以及负载均衡算法实例对象\",\"通过ReactieloadBalancer从服务列表中选择一个服务实例地址,然后发起远程调用\"]},\"81\":{\"h\":\"4.3源码跟踪\",\"t\":[\"LoadBalancerInterceptor\",\"核心源码如下所示：\",\"image-20230503223822056\",\"可以看到这里的intercept方法，拦截了用户的HttpRequest请求，然后做了几件事：\",\"1、request.getURI()：获取请求uri，本例中就是 http://spzx-cloud-user/api/user/findUserByUserId/1\",\"2、originalUri.getHost()：获取uri路径的主机名，其实就是服务id，spzx-cloud-user\",\"3、this.loadBalancer.execute()：处理服务id，和用户请求。\",\"这里的this.loadBalancer是BlockingLoadBalancerClient类型，我们继续跟入。\",\"BlockingLoadBalancerClient\",\"核心源码如下所示：\",\"image-20230503224702411\",\"ReactiveLoadBalancer.Factory的getInstance方法做了两件事情：\",\"1、获取了一个具体的负载均衡算法对象\",\"2、根据服务的id从Nacos注册中心中获取服务地址列表\",\"紧跟着调用了RoundRobinLoadBalancer#choose方法，从服务列表中选择一个服务实例对象。\",\"默认的负载均衡算法：RoundRobinLoadBalancer\"]},\"82\":{\"h\":\"4.4补充知识:负载均衡算法:\",\"t\":[\"按照特定的方式实现特定功能就是算法:\",\"轮循算法:\",\"数学知识:\",\"轮循算法数学原理\",\"请求次数%服务器数量=\"]},\"83\":{\"h\":\"4.5更改负载均衡算法\",\"t\":[\"LoadBalancer默认的负载均衡算法是RoundRobinLoadBalancer，如果想更改默认的负载均衡算法，那么此时需要向Spring容器中注册一个Bean，并且配置负载均衡的使用者。\",\"代码如下所示：\",\"1、在Spring容器中注册一个Bean\",\"public class CustomLoadBalancerConfiguration { /** * @param environment: 用于获取环境属性配置，其中LoadBalancerClientFactory.PROPERTY_NAME表示该负载均衡器要应用的服务名称。 * @param loadBalancerClientFactory: 是Spring Cloud中用于创建负载均衡器的工厂类，通过getLazyProvider方法获取ServiceInstanceListSupplier对象，以提供可用的服务列表。 * ServiceInstanceListSupplier：用于提供ServiceInstance列表的接口，可以从DiscoveryClient或者其他注册中心中获取可用的服务实例列表。 * @return */ @Bean ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment environment, LoadBalancerClientFactory loadBalancerClientFactory) { String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME); return new RandomLoadBalancer(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name); } } \",\"2、配置负载均衡算法的使用者\",\"@Configuration @LoadBalancerClients(value = { @LoadBalancerClient(name = \\\"spzx-cloud-user\\\" , configuration = CustomLoadBalancerConfiguration.class) // 将负载均衡算法应用到指定的服务提供方中 }) public class RestTemplateConfiguration { @Bean @LoadBalanced // 让RestTemplate具有负载均衡的能力 public RestTemplate restTemplate() { return new RestTemplate() ; } } \"]},\"84\":{\"h\":\"5.OpenFeign组件\"},\"85\":{\"h\":\"5.1OpenFeign组件介绍\",\"t\":[\"基于Nacos和OpenFeign组件一起使用,实现远程调用过程\",\"概述：feign是一个声明式的http客户端，官方地址：https://github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送。\",\"image-20230624093622996\",\"使用RestTemplate进行远程调用代码回顾：\",\"image-20230624093650991\",\"存在的弊端：参数传递不太方便\"]},\"86\":{\"h\":\"5.2OpenFeign初体验\",\"t\":[\"OpenFeign的使用步骤如下：\",\"1、我们在spzx-cloud-order服务的pom文件中引入OpenFeign的依赖\",\"<!-- 加入OpenFeign的依赖 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> \",\"2、在启动类上添加**@EnableFeignClients**开启OpenFeign的功能支持\",\"3、编写OpenFeign的客户端\",\"@FeignClient(value = \\\"spzx-cloud-user\\\") // 声明当前接口是一个访问user-service的feign的客户端 public interface UserFeignClient { @GetMapping(\\\"/api/user/findUserByUserId/{userId}\\\") public abstract User queryById(@PathVariable(\\\"userId\\\") Long userId) ; // 根据userId查询用户信息的接口方法 } \",\"这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：\",\"① 请求方式：GET\",\"② 请求路径：/api/user/findUserByUserId/\",\"③ 请求参数：Long userId\",\"④ 返回值类型：User\",\"这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。\",\"4、修改OrderService中的远程调用代码，使用Feign客户端代替RestTemplate：\",\"@Service public class OrderServiceImpl implements OrderService { @Autowired private OrderMapper orderMapper ; @Autowired private UserFeignClient userFeignClient ; @Override public Order findOrderByOrderId(Long orderId) { Order order = orderMapper.findOrderByOrderId(orderId); // 远程调用 User user = userFeignClient.queryById(order.getUserId()); order.setUser(user); return order ; } } \"]},\"87\":{\"h\":\"5.3OpenFeign自定义配置\"},\"88\":{\"h\":\"5.3.1 日志配置\",\"t\":[\"OpenFeign可以支持很多的自定义配置，如下表所示：\",\"类型\",\"作用\",\"说明\",\"feign.Logger.Level\",\"修改日志级别\",\"包含四种不同的级别：NONE、BASIC、HEADERS、FULL\",\"feign.codec.Decoder\",\"响应结果的解析器\",\"http远程调用的结果做解析，例如解析json字符串为java对象\",\"feign.codec.Encoder\",\"请求参数编码\",\"将请求参数编码，便于通过http请求发送\",\"feign.Contract\",\"支持的注解格式\",\"默认是SpringMVC的注解\",\"feign.Retryer\",\"失败重试机制\",\"请求失败的重试机制，默认是没有，不过会使用Ribbon的重试\",\"一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。\",\"下面以日志为例来演示如何自定义配置，支持两种方式的配置：\"]},\"89\":{\"h\":\"基于配置文件的方式\",\"t\":[\"基于配置文件修改feign的日志级别可以针对单个服务：\",\"# 将feign包下产生的日志的级别设置为debug logging: level: com.atguigu.spzx.cloud.order.feign: debug # openfeign日志级别配置 spring: cloud: openfeign: client: config: spzx-cloud-user: loggerLevel: full \",\"也可以针对所有服务：\",\"# 将feign包下产生的日志的级别设置为debug logging: level: com.atguigu.spzx.cloud.order.feign: debug # openfeign日志级别配置 spring: cloud: openfeign: client: config: default: # 这里用default就是全局配置，如果是写服务名称，则是针对某个微服务的配置 loggerLevel: full \",\"而日志的级别分为四种：\",\"① NONE：不记录任何日志信息，这是默认值。\",\"② BASIC：仅记录请求的方法，URL以及响应状态码和执行时间\",\"③ HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息\",\"④ FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。\"]},\"90\":{\"h\":\"Java代码的方式\",\"t\":[\"也可以基于Java代码来修改日志级别，先声明一个类，然后声明一个Logger.Level的对象：\",\"public class DefaultFeignConfiguration { @Bean public Logger.Level feignLogLevel(){ return Logger.Level.BASIC; // 日志级别为BASIC } } \",\"如果要全局生效，将其放到启动类的@EnableFeignClients这个注解中：\",\"@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) \",\"如果是局部生效，则把它放到对应的@FeignClient这个注解中：\",\"@FeignClient(value = \\\"spzx-cloud-user\\\", configuration = DefaultFeignConfiguration .class) \"]},\"91\":{\"h\":\"5.3.2 超时配置\",\"t\":[\"超时机制概述：Feign 的超时机制是指在使用 Feign 进行服务间的 HTTP 调用时，设置请求的超时时间。当请求超过设定的超时时间后，Feign 将会中断该请求并抛出相应的异常。\",\"超时机制的意义：\",\"1、防止长时间等待：通过设置适当的超时时间，可以避免客户端在请求服务时长时间等待响应而导致的性能问题。如果没有超时机制，客户端可能会一直等待，从而影响整个系统的吞吐量和响应时间。\",\"2、避免资源浪费：超时机制可以帮助及时释放占用的资源，例如连接、线程等。如果请求一直处于等待状态而不超时，将导致资源的浪费和系统的负载增加。\",\"3、优化用户体验：超时机制可以防止用户长时间等待无响应的情况发生，提供更好的用户体验。当请求超时时，可以及时给出错误提示或进行相应的处理，以提醒用户或采取其他措施。\",\"feign默认的超时配置为：\",\"image-20230624103625541\",\"超时时间越长，资源浪费的时间就越长，系统的稳定性就越差，因此需要设置为一个较为合理的超时时间，设置防止如下所示：\",\"spring: cloud: openfeign: client: config: default: loggerLevel: full read-timeout: 2000 # 读取数据的超时时间设置为2s connect-timeout: 2000 # 建立连接的超时时间设置为2s \"]},\"92\":{\"h\":\"5.3.3 重试配置\",\"t\":[\"feign一旦请求超时了，那么此时就会直接抛出SocketTimeoutException: Read timed out的异常。请求超时的原因有很多种，如网络抖动、服务不可用等。如果由于网络暂时不可用导致触发了超时机制，那么此时直接返回异常信息就并不是特别的合理，尤其针对查询请求，肯定希望得到一个结果。合理的做法：触发超时以后，让feign进行重试。\",\"具体步骤：\",\"1、自定义重试器\",\"public class FeignClientRetryer implements Retryer { // 定义两个成员变量来决定重试次数 private int start = 1 ; private int end = 3 ; @Override public void continueOrPropagate(RetryableException e) { // 是否需要进行重试取决于该方法是否抛出异常，如果抛出异常重试结束 if(start >= end) { throw new RuntimeException(e) ; } start++ ; } @Override public Retryer clone() { // 框架底层调用该方法得到一个重试器 return new FeignClientRetryer(); } } \",\"2、配置重试器\",\"spring: cloud: openfeign: client: config: default: loggerLevel: full read-timeout: 2000 connect-timeout: 2000 retryer: com.atguigu.spzx.cloud.order.feign.FeignClientRetryer # 配置自定义重试器 \"]},\"93\":{\"h\":\"5.4代码优化\",\"t\":[\"现有代码缺点\",\"上述代码存在的弊端：每一个服务消费方要调用服务提供方，都是需要去定义一个Feign的接口，不利于后期代码维护在实际的工作过程中，都是将Feign的接口抽取到一个独立的模块中，并且会将数据库所对应的实体类也抽取到一个独立的模块中，供其他的模块进行使用。\",\"例如，将UserFeginClient、Feign的默认配置都抽取到一个spzx-feign-api包中，Order、User实体类抽取到一个独立的模块中，其他的微服务引用该依赖包，即可直接使用。\",\"调用优化原理\",\"优化过程图解\",\"面向对象:实现组件复用的目的\",\"代码实现：\",\"1、定义一个新的模块spzx-cloud-model，并加入如下的依赖\",\"<!-- lombok依赖，快速生成getter和setter方法 --> <dependency> <groupId>org.projectlombok</groupId> <artifactId>lombok</artifactId> </dependency> \",\"2、将spzx-cloud-order微服务和spzx-cloud-user微服务中所对应的实体类抽取到spzx-cloud-model\",\"3、删除spzx-cloud-order微服务和spzx-cloud-user微服务中所定义的实体类\",\"4、在spzx-cloud-user微服务中加入如下依赖\",\"<dependency> <groupId>com.atguigu.springcloud</groupId> <artifactId>spzx-cloud-model</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"5、定义一个新的模块spzx-feign-api，加入如下依赖\",\"<!-- 加入fegin的依赖 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-openfeign</artifactId> </dependency> <!-- 实体类所对应的依赖 --> <dependency> <groupId>com.atguigu.springcloud</groupId> <artifactId>spzx-cloud-model</artifactId> <version>1.0-SNAPSHOT</version> </dependency> \",\"6、将spzx-cloud-order中编写的UserFeginClient、DefaultFeignConfiguration、DefaultFeignConfiguration都复制到spzx-feign-api项目中\",\"image-20230624113033761\",\"7、spzx-cloud-order微服务引入spzx-feign-api依赖，并且在启动类上添加feign接口的包扫描路径\",\"@SpringBootApplication @EnableFeignClients(basePackages = { \\\"com.atguigu.spzx.cloud.feign.api\\\" }) public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class , args) ; } } \"]},\"94\":{\"h\":\"6.Gateway组件\"},\"95\":{\"h\":\"6.1认识Gateway\",\"t\":[\"Gatway是网关组件,是SpringCloud公司研发的\",\"Gateway网关底层使用**Filter(过滤器)**对请求进行拦截 \",\"限流(拦截下来,进行分时放行)\",\"黑名单(客户端访问)\",\"统一功能处理(跨域,登录校验等)\",\"网关有多个过滤器,叫做过滤链\",\"通过网关多一层处理保障服务器安全\",\"网关架构原理\"]},\"96\":{\"h\":\"6.2三个核心概念\"},\"97\":{\"h\":\"6.2.1路由:\",\"t\":[\"不同路由访问不同内容\"]},\"98\":{\"h\":\"6.2.2断言(匹配关系):\",\"t\":[\"/api/user/**\",\"/api/user/fing/1\",\"/api/order/find/2(不能访问)\"]},\"99\":{\"h\":\"6.2.3过滤器:\",\"t\":[\"底层是过滤器,网关有很多过滤器,过滤器链.\"]},\"100\":{\"h\":\"6.3Gateway工作流程\",\"t\":[\"image-20231027093301407\",\"客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping中找到与请求匹配的路由，将其发送到Gateway Web Handler.\",\"Handler再通过指定的过滤器链来将请求发送给我们实际的服务执行业务逻辑，然后返回。\",\"过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（\\\"pre\\\"）或之后(\\\"post\\\")执行业务逻辑。\",\"Filter在\\\"pre\\\"类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等，在\\\"post\\\"类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量控制等有着非常重要的作用\"]},\"101\":{\"h\":\"6.4Gateway初体验\",\"t\":[\"下面，我们就演示下网关的基本路由功能。基本步骤如下：\",\"创建网关微服务模块\",\"配置文件\",\"创建启动类\",\"引入依赖\",\"将网关在nacos中进行注册\",\"修改配置文件\",\"重点配置\",\"在网关模块中配置文件中,配置路由信息.\",\"1、在spzx-cloud-parent下创建子模块spzx-cloud-gateway(创建网关微服务模块)\",\"image-20230721101439700\",\"2、引入如下依赖：\",\"<!--网关--> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-starter-gateway</artifactId> </dependency> <!--nacos服务发现依赖--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId> </dependency> <!-- 负载均衡组件 --> <dependency> <groupId>org.springframework.cloud</groupId> <artifactId>spring-cloud-loadbalancer</artifactId> </dependency> \",\"image-20230721092532222\",\"3、编写启动类\",\"// com.atguigu.spzx.cloud.gateway @SpringBootApplication public class GatewayApplication { public static void main(String[] args) { SpringApplication.run(GatewayApplication.class, args); } } \",\"4、在application.yml配置文件中编写基础配置和路由规则\",\"server: port: 8222 spring: application: name: spzx-cloud-gateway cloud: gateway: discovery: locator: enabled: true routes: - id: spzx-cloud-user # 路由id，可以自定义，只要唯一即可 uri: lb://spzx-cloud-user # 路由的目标地址 lb就是负载均衡，后面跟服务名称 predicates: - Path=/*/user/** # 路径匹配 - id: spzx-cloud-order uri: lb://spzx-cloud-order predicates: - Path=/*/order/** # 路径匹配 nacos: discovery: server-addr: 127.0.0.1:8848 \",\"server.port=8222 spring.application.name=spzx-cloud-gateway spring.cloud.gateway.discovery.locator.enabled=true spring.cloud.gateway.routes[0].id=spzx-cloud-user spring.cloud.gateway.routes[0].uri=lb://spzx-cloud-user spring.cloud.gateway.routes[0].predicates[0]=Path=/*/user/** spring.cloud.gateway.routes[1].id=spzx-cloud-order spring.cloud.gateway.routes[1].uri=lb://spzx-cloud-order spring.cloud.gateway.routes[1].predicates[0]=Path=/*/order/** spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 \",\"5、重启测试\",\"重启网关，访问http://localhost:8222/api/user/findUserByUserId/1时，符合`/api/user/**`规则，\",\"请求转发到uri：http://spzx-cloud-user/api/user/findUserByUserId/1，得到了结果：\",\"image-20230624163155679\"]},\"102\":{\"h\":\"6.5Predicate的使用(路由断言工厂)\",\"t\":[\"断言工厂\",\"启动网关服务后，在控制台可以看到如下信息：\",\"image-20230721101903404\",\"思考问题：我们在配置文件中只是配置了一个访问路径的规则，怎么就可以实现路由呢?\",\"底层原理：框架底层会自动读取配置文件中的内容，然后通过制定的路由工厂将其转换成对应的判断条件，然后进行判断。在Gateway中提供了很多的路由工厂如下所示：https://docs.spring.io/spring-cloud-gateway/docs/4.0.6/reference/html/#gateway-request-predicates-factories\",\"image-20230624163811030\",\"大致有12个，每一种路由工厂的使用Spring Cloud的官网都给出了具体的示例代码，我们可以参考示例代码进行使用。以After Route Predicate\",\"Factory路由工厂举例，如下所示：\",\"spring: cloud: gateway: routes: - id: spzx-cloud-user uri: lb://spzx-cloud-user predicates: - Path=/api/user/** - After=2023-07-21T10:23:06.978038800+08:00[Asia/Shanghai] # 系统时间在2023-07-21之后才可以进行访问 \",\"//获取当前时区时间代码 ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(zonedDateTime); \",\"总结\",\"Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapper基础框架的一部分。 Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以进行组合 Spring Cloud Gateway创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以赋值给 Route。Spring Cloud Gateway包含许多内置的Route Predicate Factories。所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and 。\"]},\"103\":{\"h\":\"6.6过滤器\"},\"104\":{\"h\":\"6.6.1 过滤器简介\",\"t\":[\"在gateway中要实现其他的功能：权限控制、流量监控、统一日志处理等。就需要使用到gateway中所提供的过滤器了。过滤器，可以对进入网关的请求和微服务返回的响应做处理：\",\"image-20230624164230054\"]},\"105\":{\"h\":\"6.6.2 内置过滤器\",\"t\":[\"spring gateway提供了31种不同的过滤器。\",\"官网地址：https://docs.spring.io/spring-cloud-gateway/docs/2.2.9.RELEASE/reference/html/#gatewayfilter-factories\",\"例如：\",\"名称\",\"说明\",\"AddRequestHeader\",\"给当前请求添加一个请求头\",\"RemoveRequestHeader\",\"移除请求中的一个请求头\",\"AddResponseHeader\",\"给响应结果中添加一个响应头\",\"RemoveResponseHeader\",\"从响应结果中移除有一个响应头\",\"RequestRateLimiter\",\"限制请求的流量\",\"在Gateway中提供了三种级别的类型的过滤器：\",\"1、路由过滤器：只针对当前路由有效\",\"2、默认过滤器：针对所有的路由都有效\",\"3、全局过滤器：针对所有的路由都有效，需要进行自定义\"]},\"106\":{\"h\":\"6.6.3 路由过滤器\",\"t\":[\"需求：给所有进入spzx-cloud-user的请求添加一个请求头：Truth=atguigu\",\"实现：\",\"1、修改gateway服务的application.yml文件，添加路由过滤\",\"spring: cloud: gateway: routes: - id: spzx-cloud-user uri: lb://spzx-cloud-user predicates: - Path=/api/user/** filters: - AddRequestHeader=Truth, daimakuai # 配置路由基本的过滤器，给访问user微服务的所有接口添加Truth请求头 \",\"当前过滤器写在spzx-cloud-user路由下，因此仅仅对访问spzx-cloud-user的请求有效。\",\"2、在spzx-cloud-user的接口方法中读取请求头数据，进行测试\",\"@GetMapping(value = \\\"/findUserByUserId/{userId}\\\") public User findUserByUserId(@PathVariable(value = \\\"userId\\\") Long userId , @RequestHeader(name = \\\"Truth\\\")String header) { log.info(\\\"UserController...findUserByUserId方法执行了... ,header: {} \\\" , header); return userService.findUserByUserId(userId) ; } \"]},\"107\":{\"h\":\"6.6.4 默认过滤器\",\"t\":[\"如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：\",\"spring: cloud: gateway: routes: - id: spzx-cloud-user uri: lb://spzx-cloud-user predicates: - Path=/api/user/** - After=2017-01-20T17:42:47.789-07:00[America/Denver] default-filters: - AddRequestHeader=Truth, daimakuai is good \"]},\"108\":{\"h\":\"6.6.5 全局过滤器\",\"t\":[\"概述\",\"**上述的过滤器是gateway中提供的默认的过滤器，每一个过滤器的功能都是固定的。**但是如果我们希望拦截请求，做自己的业务逻辑，默认的过滤器就没办法实现。此时就需求使用全局过滤器，全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。\",\"需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\",\"请求参数中是否有username，如果同时满足则放行，否则拦截\",\"步骤分析：\",\"定义一个类实现GlobalFilter接口❓全局过滤器接口\",\"重写filter方法\",\"将该类纳入到spring容器中\",\"实现Ordered接口定义该过滤器的顺序❓过滤器顺接口\",\"实现globleFilter里面的方法,然后进行放行操作\",\"实现getOrder方法,实现过滤器排序\",\"实现代码：判断请求路径中第一个参数是否是username,如果是正常访问,如果不是就不能正常访问\",\"具体\",\"@Component//类交给Spring进行管理 public class AuthorizationFilter implements GlobalFilter, Ordered {//实现来年两个接口 //实现过滤器逻辑 @Override public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) { //获取请求路径中参数,判断参数是否是username,如果是放行,如果不是不能访问,就不放行 //参数中exchage:通过这个可以获得request对象 //参数中chain: //方法getQueryParams()会返回一个Map对象,保存参数的信息,参数名是可以,参数值是value //遍历map,获取所有的key根据key进行遍历 String username = exchange.getRequest().getQueryParams().getFirst(\\\"username\\\"); if(!StringUtils.hasText(username)){ //设置响应状态码 exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } //定义该过滤器的优先级 @Override public int getOrder() { return 0; } } \"]},\"109\":{\"h\":\"6.6.6 过滤器执行顺序\",\"t\":[\"请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter\",\"请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：\",\"image-20230624170925571\",\"排序的规则是什么呢？\",\"1、按照order的值进行排序，order的值越小，优先级越高，执行顺序越靠前。\",\"2、路由过滤器和默认过滤器会按照order的值进行排序，这个值由spring进行指定，默认是按照声明顺序从1递增\",\"3、当过滤器的order值一样时，会按照 globalFilter > defaultFilter > 路由过滤器的顺序执行\",\"核心源码分析：org.springframework.cloud.gateway.handler.FilteringWebHandler#handle方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链\",\"public Mono<Void> handle(ServerWebExchange exchange) { Route route = (Route)exchange.getRequiredAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR); // 获取路由级别的过滤器和默认过滤器的集合 List<GatewayFilter> gatewayFilters = route.getFilters(); // 获取全局过滤器的集合 List<GatewayFilter> combined = new ArrayList(this.globalFilters); // 将取路由级别的过滤器和默认过滤器的集合中的元素添加到全局过滤器的集合中 combined.addAll(gatewayFilters); // 进行排序 AnnotationAwareOrderComparator.sort(combined); if (logger.isDebugEnabled()) { logger.debug(\\\"Sorted gatewayFilterFactories: \\\" + combined); } // 调用过滤器链中的filter方法 return (new DefaultGatewayFilterChain(combined)).filter(exchange); } \"]},\"110\":{\"h\":\"7.Nacos配置中心\",\"t\":[\"Nacos除了可以做注册中心，同样可以做配置管理来使用。\",\"把多个为服务模块中相同配置,配置到配置中心中,所有模块读取配置中心中的内容.\",\"注册中心\",\"配置中心\"]},\"111\":{\"h\":\"7.1 统一配置管理\",\"t\":[\"相同配置部分进行抽取.\",\"当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就显得十分的不方便，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\",\"image-20230624171403235\",\"nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\"]},\"112\":{\"h\":\"7.2 Nacos入门\"},\"113\":{\"h\":\"7.2.1 Nacos中添加配置\",\"t\":[\"在Nacos服务端创建一个配置，如下所示：\",\"image-20230624171530387\",\"然后在弹出的表单中，填写配置信息：\",\"image-20210714164856664\"]},\"114\":{\"h\":\"7.2.2 微服务集成配置中心\",\"t\":[\"微服务需要进行改造，从Nacos配置中心中获取配置信息进行使用。\",\"步骤：\",\"1、在spzx-cloud-user微服务中，引入spring-cloud-starter-alibaba-nacos-config依赖\",\"<!-- nacos作为配置中心时所对应的依赖 --> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId> </dependency> \",\"2、在spzx-cloud-user项目的 /src/main/resources/application.yml 配置文件中配置 Nacos Config 地址并引入服务配置\",\"# 配置数据库的连接信息 spring: cloud: nacos: config: server-addr: 192.168.136.142:8848 config: import: - nacos:spzx-cloud-user-dev.yml \"]},\"115\":{\"h\":\"7.2.3 读取自定义配置\"},\"116\":{\"h\":\"@Value\",\"t\":[\"通过@Value注解读取自定义配置，如下所示：\",\"@RestController @RequestMapping(value = \\\"/api/user\\\") @Slf4j public class UserController { @Autowired private UserService userService ; @Value(\\\"${pattern.dateformat}\\\") private String pattern ; @GetMapping(value = \\\"/findUserByUserId/{userId}\\\") public User findUserByUserId(@PathVariable(value = \\\"userId\\\") Long userId , @RequestHeader(name = \\\"Truth\\\")String header) { log.info(\\\"UserController...findUserByUserId方法执行了... ,header: {} , dateformat: {} \\\" , header , pattern); return userService.findUserByUserId(userId) ; } } \"]},\"117\":{\"h\":\"@ConfigurationProperties\",\"t\":[\"也可以通过实体类，配合@ConfigurationProperties注解读取自定义配置，代码如下所示：\",\"1、定义一个实体类，代码如下所示：\",\"@Data @ConfigurationProperties(prefix = \\\"pattern\\\") public class PatternProperties { private String dateformat ; } \",\"2、在启动类上添加@EnableConfigurationProperties注解，如下所示：\",\"@SpringBootApplication @EnableConfigurationProperties(value = { PatternProperties.class }) public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class , args) ; } } \",\"3、使用该实体类，代码如下所示：\",\"@RestController @RequestMapping(value = \\\"/api/user\\\") @Slf4j public class UserController { @Autowired private UserService userService ; @Value(\\\"${pattern.dateformat}\\\") private String pattern ; @Autowired // 注入实体类 private PatternProperties patternProperties ; @GetMapping(value = \\\"/findUserByUserId/{userId}\\\") public User findUserByUserId(@PathVariable(value = \\\"userId\\\") Long userId , @RequestHeader(name = \\\"Truth\\\")String header) { log.info(\\\"UserController...findUserByUserId方法执行了... ,header: {} , dateformat: {} \\\" , header , patternProperties.getDateformat()); return userService.findUserByUserId(userId) ; } } \"]},\"118\":{\"h\":\"7.3 配置热更新\",\"t\":[\"⭐我们最终的目的，是修改Nacos中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。实现配置的热更新有两种方式：\",\"方式一：在@Value注入的变量所在类上添加注解**@RefreshScope**\",\"image-20230624200928589\",\"方式二：通过实体类，配合@ConfigurationProperties注解读取配置信息，自动支持热更新\"]},\"119\":{\"h\":\"7.4 配置优先级\",\"t\":[\"思考问题：如果在application.yml文件中和Nacos配置中心中都定义了相同的配置内容，那么哪一个配置的优先级较高呢?\",\"优先级顺序：Nacos配置中心的配置(后导入的配置 > 先导入的配置) > application.yml\"]},\"120\":{\"h\":\"8.Sentinel部分\"},\"121\":{\"h\":\"8.1 初识sentinel\"},\"122\":{\"h\":\"8.1.1 雪崩效应\",\"t\":[\"概述：在微服务系统架构中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。一个服务的不可用导致整个系统的不可用的现象就被称之为雪崩效应。\",\"雪崩原理\",\"如下图所示：\",\"image-20230624203044831\",\"当服务D出现了问题了以后，调用服务D的服务A的线程就得不到及时的释放，在高并发情况下，随着时间的不断推移服务A的系统资源会被线程耗尽，最终导致服务A出现了问题，同理就会导致其他的服务也不能进行访问了。\"]},\"123\":{\"h\":\"8.1.2 解决方案\"},\"124\":{\"h\":\"超时处理\",\"t\":[\"超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待\",\"称为:服务降级\",\"image-20230624203153340\",\"超时处理原理\"]},\"125\":{\"h\":\"隔离处理\",\"t\":[\"隔离处理：将错误隔离在可控的范围之内，不要让其影响到其他的程序的运行。\",\"这种设计思想，来源于船舱的设计，如下图所示：\",\"image-20230624203222353\",\"船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。于此类似，我们业务系统也可以使用这种思想来防止出现雪崩效应，常见的隔离方式：线程隔离\",\"image-20230624203256590\"]},\"126\":{\"h\":\"熔断处理\",\"t\":[\"类似于保险丝,电压过高会进行熔断.熔断是在降级的基础之上发生的.\",\"熔断处理：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。\",\"断路器会统计访问某个服务的请求数量，异常比例如下所示：\",\"熔断是在降级的基础上发生的\",\"⭐设置远程调用的超时时间.如果只做降级处理,都只会发送兜底数据,我们需要做熔断操作,1调用2,多次调用都是失败,不再调用执行熔断,1调用2直接返回兜底数据.\",\"制定一个规则,十次调用中有五次是调用失败,我们就会执行熔断\",\"特点:提高很高的数据,熔断不可以无限,熔断需要设置时长,熔断五秒,超过五秒之后,会继续进行访问.这就是熔断的机制.\",\"image-20230624203334370\",\"请求了三次，两次出现异常，一次成功。当发现访问服务D的请求异常比例过高时，认为服务D有导致雪崩的风险，会拦截访问服务D的一切请求，形成熔断：\",\"image-20230624203409785\",\"触发熔断了以后，当在访问服务A的时候，就不会在通过服务A去访问服务D了，立马给用户进行返回，返回的是一种默认值，这种返回就是一种兜底方案。这种兜底方案也将其称之为降级逻辑。\"]},\"127\":{\"h\":\"流量控制\",\"t\":[\"流量控制原理图\",\"流量控制：限制业务访问的QPS(每秒的请求数)，避免服务因流量的突增而故障。\",\"设置等待时间,时间过了就会返回兜底信息.\",\"服务器在压力过大的情况下会发生宕机,所以我们对流量进行控制\",\"image-20230624203508014\",\"限流是一种预防措施，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。其他的处理方式是一种补救措施，在部分服务故障时，将故障控制在一定范围，避免雪崩。\"]},\"128\":{\"h\":\"最终的目的\",\"t\":[\"保护服务器,防止宕机\"]},\"129\":{\"h\":\"QPS:query per seconds\",\"t\":[\"服务器每秒能处理的请求数量,衡量服务器的吞吐量\"]},\"130\":{\"h\":\"阈值\",\"t\":[\"临界值,比如服务器的qps是5,每秒处理5个请求,这个就叫做阈值.\"]},\"131\":{\"h\":\"8.1.3 sentinel介绍\",\"t\":[\"⭐:分为两部分:\",\"第一部分:核心库(java客户端)使用java代码能实现sentinel使用\",\"第二部分:控制台,图形化界面,通过界面配置sentinel的控制\",\"官网地址：https://sentinelguard.io/zh-cn/\",\"随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\",\"Sentinel 的历史：\",\"- 2012 年，Sentinel 诞生，主要功能为入口流量控制。\",\"- 2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。\",\"- 2018 年，Sentinel 开源，并持续演进。\",\"- 2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 C++ 原生版本，同时针对 Service Mesh 场景也推出了 Envoy 集群流量控制支持，以解决 Service Mesh 架构下多语言限流的问题。\",\"- 2020 年，推出 Sentinel Go 版本，继续朝着云原生方向演进。\",\"Sentinel 分为两个部分:\",\"- 核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。\",\"- 控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。\",\"image-20230624203655208\",\"具有的特征:\",\"image-20230624203730680\"]},\"132\":{\"h\":\"8.2 sentinel入门\"},\"133\":{\"h\":\"8.2.1 下载sentinel控制台\",\"t\":[\"sentinel管理后台下载地址：https://github.com/alibaba/Sentinel/releases\",\"image-20230624215112184\",\"下载完毕以后就会得到一个jar包\",\"image-20230624215403344\"]},\"134\":{\"h\":\"8.2.2 启动sentinel\",\"t\":[\"将jar包放到任意非中文目录，执行命令：\",\"java -jar sentinel-dashboard-2.0.0-alpha-preview.jar \",\"如果要修改Sentinel的默认端口、账户、密码，可以通过下列配置：\",\"配置项\",\"默认值\",\"说明\",\"server.port\",\"8080\",\"服务端口\",\"sentinel.dashboard.auth.username\",\"sentinel\",\"默认用户名\",\"sentinel.dashboard.auth.password\",\"sentinel\",\"默认密码\",\"例如，修改端口：\",\"java -Dserver.port=8090 -jar sentinel-dashboard-2.0.0-alpha-preview.jar \"]},\"135\":{\"h\":\"8.2.3 访问sentinel\",\"t\":[\"访问http://localhost:8080页面，就可以看到sentinel的控制台了：\",\"image-20230624215635555\",\"需要输入账号和密码，默认都是：sentinel\",\"登录后，发现一片空白，什么都没有：因为还没有监控任何服务。另外，sentinel是懒加载的，如果服务没有访问，看不到该服务信息。\",\"image-20230624215704921\"]},\"136\":{\"h\":\"8.2.4 整合sentinel\",\"t\":[\"我们在spzx-cloud-user中整合sentinel，并连接sentinel的控制台，步骤如下：\",\"1、引入sentinel依赖\",\"<!--sentinel--> <dependency> <groupId>com.alibaba.cloud</groupId> <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId> </dependency> \",\"2、配置控制台\",\"修改application.yaml文件，添加下面内容\",\"spring: cloud: sentinel: transport: dashboard: localhost:8080 # 配置sentinel控制台地址 \",\"3、访问spzx-cloud-user的任意接口\",\"打开浏览器，访问http://localhost:10100/api/user/findUserByUserId/1，这样才能触发sentinel的监控。然后再访问sentinel的控制台，查看效果：\",\"image-20230624220303385\"]},\"137\":{\"h\":\"8.3 流量控制\",\"t\":[\"雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。\"]},\"138\":{\"h\":\"8.3.1 相关概念\",\"t\":[\"簇点链路：当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。\",\"资源：簇点链路中被监控的每一个接口就是一个资源，流控、熔断等都是针对簇点链路中的资源来设置的。\",\"默认情况下sentinel会监控spring mvc的每一个端点（Endpoint，也就是controller中的方法），因此spring mvc的每一个端点就是调用链路中的一个资源。\",\"例如，我们刚才访问的spzx-cloud-user中的UserController中的端点：/api/user/findUserByUserId/\",\"image-20230624220603571\",\"我们可以点击对应资源后面的按钮来设置规则：\",\"1、流控：流量控制\",\"2、降级：降级熔断\",\"3、热点：热点参数限流，是限流的一种\",\"4、授权：请求的权限控制\"]},\"139\":{\"h\":\"8.3.2 快速入门\",\"t\":[\"需求：给 /api/user/findUserByUserId/{userId}这个资源设置流控规则，QPS不能超过 5，然后测试。\",\"步骤：\",\"1、首先在sentinel控制台添加限流规则\",\"image-20230628090407483\",\"2、利用jmeter测试(模拟并发请求)\",\"Apache JMeter 是 Apache 组织基于 Java 开发的压力测试工具，用于对软件做压力测试。\",\"下载地址：https://archive.apache.org/dist/jmeter/binaries/\",\"课前资料提供了编写好的Jmeter测试样例\",\"image-20230628115300889\",\"通过如下命令打开jmeter\",\"java -jar ApacheJMeter.jar \",\"导入课前资料提供的测试样例\",\"image-20220320111824238\",\"选择流控入门\",\"image-20220320111955904\",\"10个线程，1秒内运行完，QPS是10，超过了5。\",\"选中流控入门，QPS<5右键运行\",\"image-20220320112040803\",\"注意：不要点击菜单中的执行按钮来运行。\",\"点击查看结果树，理想的请求执行结果应该如下所示：\",\"image-20220320112142379\",\"可以看到，成功的请求每次只有5个。\",\"注意：如果测试结果不是上述情况，那是因为sentinel在统计请求的时候，把一部分的请求统计到了下一秒中导致的。\"]},\"140\":{\"h\":\"8.3.3 流控模式\"},\"141\":{\"h\":\"流控模式简介\",\"t\":[\"在添加限流规则时，点击高级选项，可以选择三种流控模式：\",\"1、直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式\",\"2、关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流\",\"3、链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流\",\"理解\",\"如下所示：\",\"image-20230628091856122\",\"快速入门测试的就是直接模式。\"]},\"142\":{\"h\":\"关联模式\",\"t\":[\"A关联B,设置阈值1,访问B时候超过阈值,B不限流,对A进行限流\",\"image-20231027163806970\",\"关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流\",\"配置方式：\",\"image-20230628092034118\",\"**语法说明：**对/api/user/updateUserById资源的请求进行统计，当访问流量超过阈值时，就对/api/user/findUserByUserId/{userId}进行限流，避免影响/api/user/updateUserById资源。\",\"使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。\",\"案例实现：\",\"1、在UserController新建一个端点：/api/user/updateUserById，无需实现业务\",\"// 修改用户数据端点 @GetMapping(value = \\\"/updateUserById\\\") public String updateUserById() { return \\\"修改用户数据成功\\\"; } \",\"2、重启服务，访问对应的端点，让其产生簇点链路\",\"image-20230628092515666\",\"3、配置流控规则，当/api/user/updateUserById资源被访问的QPS超过5时，对/api/user/findUserByUserId/1请求限流。对哪个端点限流，就点击哪个端点后面的按钮。我们是对用户查询/api/user/findUserByUserId/1限流，因此点击它后面的按钮：\",\"image-20230628092751648\",\"4、在Jmeter中进行测试\",\"选择《流控模式-关联》：\",\"image-20220320114459422\",\"可以看到1000个线程，100秒，因此QPS为10，超过了我们设定的阈值：5\",\"查看http请求：\",\"image-20230628093126793\",\"请求的目标是/api/user/updateUserById，这样这个端点就会触发阈值。但限流的目标是/api/user/findUserByUserId/1，我们在浏览器访问，可以发现：\",\"image-20230628093300378\",\"确实被限流了。\",\"关联流控模式的使用场景：\",\"1、两个有竞争关系的资源\",\"2、一个优先级较高，一个优先级较低\",\"对高优先级的资源的流量进行统计，当超过阈值对低优先级的资源进行限流。\"]},\"143\":{\"h\":\"链路模式\",\"t\":[\"image-20231027163905542\",\"链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值，如果超过阈值对从该链路请求进行限流。\",\"配置方式：\",\"1、/api/user/save --> users\",\"2、/api/user/query --> users\",\"如果只希望统计从/api/user/query进入到users的请求，并进行限流操作，则可以这样配置：\",\"image-20230628095013326\",\"案例实现：\",\"1、在UserService中添加一个queryUsers方法，不用实现业务\",\"public void queryUsers(){ System.err.println(\\\"查询用户\\\"); } \",\"2、在UserController中，添加两个端点，在这两个端点中分别调用UserService中的queryUsers方法\",\"@GetMapping(value = \\\"/save\\\") public String save() { userService.queryUsers(); System.out.println(\\\"保存用户\\\"); return \\\"订单保存成功\\\" ; } @GetMapping(value = \\\"/query\\\") public String query() { userService.queryUsers(); System.out.println(\\\"查询用户\\\"); return \\\"查询用户成功\\\" ; } \",\"4、通过**@SentinelResource**标记UserService中的queryUsers方法为一个sentinel监控的资源(默认情况下，sentinel只监控controller方法)\",\"@SentinelResource(\\\"users\\\") public void queryUsers(){ System.err.println(\\\"查询用户\\\"); } \",\"5、更改application.yml文件中的sentinel配置\",\"链路模式中，是对不同来源的两个链路做监控。但是sentinel默认会给进入spring mvc的所有请求设置同一个root资源，会导致链路模式失效。因此需要关闭这种资源整合。\",\"spring: cloud: sentinel: web-context-unify: false # 关闭context整合 \",\"6、重启服务，访问/api/user/save和/api/user/query，可以查看到sentinel的簇点链路规则中，出现了新的资源\",\"image-20230628094306219\",\"7、添加流控规则\",\"点击users资源后面的流控按钮，在弹出的表单中填写下面信息：\",\"image-20230628094433574\",\"只统计从/api/user/query进入/users的资源，QPS阈值为2，超出则被限流。\",\"8、jmeter测试\",\"选择《流控模式-链路》\",\"image-20220320150559229\",\"可以看到这里200个线程，50秒内发完，QPS为4，超过了我们设定的阈值2。\",\"一个http请求是访问/api/user/save\",\"image-20230628094648097\",\"另一个是访问/api/user/query\",\"image-20230628094713655\",\"运行测试，察看结果树：\",\"访问/api/user/save,没有进行限流\",\"image-20230628094814795\",\"访问/api/user/query,进行限流了\",\"image-20230628094857374\"]},\"144\":{\"h\":\"8.3.4 流控效果\",\"t\":[\"在流控的高级选项中，还有一个流控效果选项\",\"image-20230628095109686\",\"流控效果是指请求达到流控阈值时应该采取的措施，包括三种：\",\"1、快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常，是默认的处理方式\",\"2、warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常，但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值\",\"3、排队等待：让所有的请求按照先后次序进入到一个队列中进行排队，当某一个请求最大的预期等待时间超过了所设定的超时时间时同样是拒绝并抛出异常\"]},\"145\":{\"h\":\"warm up\",\"t\":[\"阈值一般是一个微服务能承担的最大QPS，但是一个服务刚刚启动时，一切资源尚未初始化（冷启动），如果直接将QPS跑到最大值，可能导致服务瞬间宕机。\",\"warm up也叫预热模式，是应对服务冷启动的一种方案。阈值会动态变化，从一个较小值逐渐增加到最大阈值。\",\"工作特点：请求阈值初始值是 maxThreshold / coldFactor, 持续指定时长(预热时间)后，逐渐提高到maxThreshold值，而coldFactor的默认值是3。\",\"例如，我设置QPS的maxThreshold为10，预热时间为5秒，那么初始阈值就是 10 / 3 ，也就是3，然后在5秒后逐渐增长到10。\",\"image-20220320152944101\",\"案例需求：给/api/user/findUserByUserId/{userId}这个资源设置限流，最大QPS为10，利用warm up效果，预热时长为5秒\",\"1、配置流控规则\",\"image-20230628095505037\",\"2、jmeter测试\",\"选择《流控效果，warm up》\",\"image-20220320153409220\",\"QPS为10\",\"刚刚启动时，大部分请求失败，成功的只有3个，说明QPS被限定在3：\",\"image-20220320153522505\",\"随着时间推移，成功比例越来越高\",\"image-20220320153646510\",\"到sentinel控制台查看实时监控\",\"image-20230628095925921\"]},\"146\":{\"h\":\"排队等待\",\"t\":[\"排队等待：让所有的请求按照先后次序进入到一个队列中进行排队，当某一个请求最大的预期等待时间超过了所设定的超时时间时同样是拒绝并抛出异常\",\"例如：QPS = 5，意味着每200ms处理一个队列中的请求；timeout = 2000，意味着预期等待时长超过2000ms的请求会被拒绝并抛出异常。\",\"那什么叫做预期等待时长呢？\",\"比如现在一下子来了12 个请求，因为每200ms执行一个请求，那么：\",\"1、第6个请求的预期等待时长 = 200 * （6 - 1） = 1000ms\",\"2、第12个请求的预期等待时长 = 200 * （12-1） = 2200ms\",\"现在，第1秒同时接收到10个请求，但第2秒只有1个请求，此时QPS的曲线这样的：\",\"image-20230628100019712\",\"如果使用队列模式做流控，所有进入的请求都要排队，以固定的200ms的间隔执行，QPS会变的很平滑\",\"image-20230628100049968\",\"平滑的QPS曲线，对于服务器来说是更友好的。\",\"案例需求：给/api/user/findUserByUserId/{userId}这个资源设置限流，最大QPS为10，利用排队的流控效果，超时时长设置为5s\",\"1、添加流控规则\",\"image-20230628100313331\",\"2、jmeter测试\",\"image-20220320154801992\",\"QPS为15，已经超过了我们设定的10。\",\"运行测试用例，察看结果树：\",\"image-20220320155103019\",\"全部都通过了。\",\"再去sentinel查看实时监控的QPS曲线\",\"image-20220320155202523\",\"QPS非常平滑，一致保持在10，但是超出的请求没有被拒绝，而是放入队列。因此响应时间（等待时间）会越来越长。\"]},\"147\":{\"h\":\"8.3.5 热点参数限流\"},\"148\":{\"h\":\"配置介绍\",\"t\":[\"之前的限流是统计访问某个资源的所有请求，判断是否超过QPS阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过QPS阈值。\",\"例如，一个根据id查询商品的接口：\",\"image-20230628100914491\",\"访问/goods/{id}的请求中，id参数值会有变化，热点参数限流会根据参数值分别统计QPS，统计结果：\",\"image-20230628101012945\",\"当id=1的请求触发阈值被限流时，id值不为1的请求不受影响。\",\"配置方式(点击资源中的热点按钮)：\",\"image-20230628101216576\",\"代表的含义是：对hot这个资源的0号参数（第一个参数）做统计，每1秒相同参数值的请求数不能超过2。这种配置是对查询商品这个接口的所有商品一视同仁，QPS都限定为5。而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：\",\"image-20230628101331468\"]},\"149\":{\"h\":\"案例演示\",\"t\":[\"案例需求：给/api/user/findUserByUserId/{userId}这个资源添加热点参数限流，规则如下：\",\"1、默认的热点参数规则是每1秒请求量不超过2\",\"2、给2这个参数设置例外：每1秒请求量不超过4\",\"3、给3这个参数设置例外：每1秒请求量不超过10\",\"注意事项：热点参数限流对默认的spring mvc资源无效，需要利用@SentinelResource注解标记资源\",\"实现步骤：\",\"1、标记资源\",\"给UserController中的/api/user/findUserByUserId/{userId}资源添加注解：\",\"@SentinelResource(\\\"hot\\\") // 声明资源名称 @GetMapping(value = \\\"/findUserByUserId/{userId}\\\") public User findUserByUserId(@PathVariable(value = \\\"userId\\\") Long userId , @RequestHeader(name = \\\"Truth\\\" , required = false)String header) { log.info(\\\"UserController...findUserByUserId方法执行了... ,header: {} , dateformat: {} \\\" , header , patternProperties.getDateformat()); return userService.findUserByUserId(userId) ; } \",\"2、热点参数限流规则\",\"访问该接口，可以看到我们标记的hot资源出现了\",\"image-20230628101715773\",\"这里不要点击hot后面的按钮，页面有BUG\",\"点击左侧菜单中热点规则菜单：\",\"image-20230628102031276\",\"3、jmeter测试\",\"选择《热点参数限流 QPS1》\",\"image-20220320162420189\",\"这里发起请求的QPS为5。\",\"包含三个请求，参数分别为：101 ， 102 ， 103，运行测试程序，察看结果树：\",\"101\",\"102\",\"103\"]},\"150\":{\"c\":[\"Spring基础\"]},\"151\":{\"c\":[\"Markdown\"]},\"152\":{\"h\":\"01\"},\"153\":{\"h\":\"你好\"},\"154\":{\"h\":\"02\"},\"155\":{\"h\":\"你好\",\"t\":[\"haha\"]},\"156\":{\"h\":\"01\"},\"157\":{\"h\":\"你好\"},\"158\":{\"h\":\"Spring Cache\"},\"159\":{\"h\":\"1.1 介绍\",\"t\":[\"Spring Cache是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能，大大简化我们在业务中操作缓存的代码。\",\"Spring Cache只是提供了一层抽象，底层可以切换不同的cache实现。具体就是通过CacheManager接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口。\",\"针对不同的缓存技术需要实现不同的CacheManager：\",\"CacheManager\",\"描述\",\"EhCacheCacheManager\",\"使用EhCache作为缓存技术\",\"GuavaCacheManager\",\"使用Google的GuavaCache作为缓存技术\",\"RedisCacheManager\",\"使用Redis作为缓存技术\"]},\"160\":{\"h\":\"1.2 注解\",\"t\":[\"在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：\",\"注解\",\"说明\",\"@EnableCaching\",\"开启缓存注解功能\",\"@Cacheable\",\"在方法执行前spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中\",\"@CachePut\",\"将方法的返回值放到缓存中\",\"@CacheEvict\",\"将一条或多条数据从缓存中删除\",\"在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用**@EnableCaching**开启缓存支持即可。\",\"例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。\"]},\"161\":{\"h\":\"1.3 入门程序\",\"t\":[\"接下来，我们将通过一个入门案例来演示一下SpringCache的常见用法。 上面我们提到，SpringCache可以集成不同的缓存技术，如Redis、Ehcache\",\"本次我们直接使用Redis作为缓存技术。\",\"需求：给spring-cache-demo项目中的查询用户方法，添加查询缓存逻辑\",\"具体步骤：\",\"1、打开课程资料中所提供的spring-cache-demo项目\",\"2、在spring-cache-demo项目的pom.xml文件中添加如下依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-redis</artifactId> </dependency> \",\"3、在application.yml文件中配置Redis的连接信息\",\"spring: data: redis: host: 192.168.136.142 port: 6379 password: 1234 \",\"4、配置Redis的key的序列化器\",\"// com.atguigu.spzx.cache.config; @Configuration public class RedisConfig { @Bean public CacheManager cacheManager(LettuceConnectionFactory connectionFactory) { //定义序列化器 GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() //过期时间600秒 .entryTtl(Duration.ofSeconds(600)) // 配置序列化 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(stringRedisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer)); RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); return cacheManager; } } \",\"5、在启动类上添加**@EnableCaching**注解\",\"6、在UserServiceImpl类中的findById方法上添加**@Cacheable**注解\",\"@Override @Cacheable(value = \\\"userCache\\\" , key = \\\"#userId\\\") public User findById(Long userId) { log.info(\\\"用户数据查询成功...\\\"); User user = new User() ; user.setAge(23); user.setUserName(\\\"尚硅谷\\\"); return user; } \",\"7、启动程序进行测试：第一次查询时候会打印日志，第二次查询的时候由于Redis中已经存在了数据，因此直接从Redis中进行命中\",\"@Cacheable 说明:\",\"1、作用: 在方法执行前，spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；若没有数据，调用方法并将方法返回值放到缓存中\",\"2、value: 缓存的名称，每个缓存名称下面可以有多个key\",\"3、key: 缓存的key ----------> 支持Spring的表达式语言SPEL语法\"]},\"162\":{\"h\":\"1.4 其他注解\"},\"163\":{\"h\":\"@CachePut\",\"t\":[\"作用: 将方法返回值，放入缓存\",\"value: 缓存的名称, 每个缓存名称下面可以有很多key\",\"key: 缓存的key ----------> 支持Spring的表达式语言SPEL语法\",\"当前UserController的save方法是用来保存用户信息的，我们希望在该用户信息保存到数据库的同时，也往缓存中缓存一份数据，我们可以在save方法上加上注解 @CachePut，用法如下：\",\"@CachePut(value = \\\"userCache\\\", key = \\\"#user.userName\\\") public User saveUser(User user) { log.info(\\\"用户数据保存成功...\\\"); return user ; } \",\"key的写法如下：\",\"#user.id : #user指的是方法形参的名称, id指的是user的id属性 , 也就是使用user的id属性作为key ;\",\"#user.userName: #user指的是方法形参的名称, name指的是user的name属性 ,也就是使用user的name属性作为key ;\",\"​\",\"#result.id : #result代表方法返回值，该表达式 代表以返回对象的id属性作为key ；\",\"#result.userName: #result代表方法返回值，该表达式 代表以返回对象的name属性作为key ；\"]},\"164\":{\"h\":\"@CacheEvict\",\"t\":[\"作用: 清理指定缓存\",\"value: 缓存的名称，每个缓存名称下面可以有多个key\",\"key: 缓存的key ----------> 支持Spring的表达式语言SPEL语法\",\"当我们在删除数据库user表的数据的时候,我们需要删除缓存中对应的数据,此时就可以使用**@CacheEvict**注解, 具体的使用方式如下:\",\"@CacheEvict(value = \\\"userCache\\\" , key = \\\"#userId\\\") public void deleteById(Long userId) { log.info(\\\"用户数据删除成功...\\\"); } \"]},\"165\":{\"h\":\"1.5 缓存所有分类数据\",\"t\":[\"需求：给查询所有的分类数据添加查询缓存，使用Spring Cache框架\",\"步骤：\",\"1、在service-product服务中的pom.xml文件中添加依赖\",\"<dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-cache</artifactId> </dependency> \",\"2、配置Redis的key的序列化器\",\"// com.atguigu.spzx.cache.config; @Configuration public class RedisConfig { @Bean public CacheManager cacheManager(LettuceConnectionFactory connectionFactory) { //定义序列化器 GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer(); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() //过期时间600秒 .entryTtl(Duration.ofSeconds(600)) // 配置序列化 .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(stringRedisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(genericJackson2JsonRedisSerializer)); RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory) .cacheDefaults(config) .build(); return cacheManager; } } \",\"3、在启动类上添加**@EnableCaching**注解\",\"4、在CategoryServiceImpl类中的findCategoryTree方法上添加**@Cacheable**注解\",\"@Cacheable(value = \\\"category\\\" , key = \\\"'all'\\\") public List<Category> findAllCategory() { .. return oneCategoryList; } \",\"5、启动程序进行测试\"]},\"166\":{\"c\":[\"Spring基础\",\"Cache\",\"ThreadLocal\"]},\"167\":{\"c\":[\"Markdown\"]},\"168\":{\"h\":\"01\"},\"169\":{\"h\":\"你好\"},\"170\":{\"h\":\"01\"},\"171\":{\"h\":\"你好\"},\"172\":{\"h\":\"01\"},\"173\":{\"h\":\"你好\"},\"174\":{\"h\":\"01\"},\"175\":{\"h\":\"你好\"},\"176\":{\"h\":\"01\"},\"177\":{\"h\":\"你好\"},\"178\":{\"h\":\"a.数据结构与算法总体概述\"},\"179\":{\"h\":\"数据结构概述\"},\"180\":{\"h\":\"数据结构是什么?\",\"t\":[\"程序=数据结构+算法（底层使用）\",\"程序=框架+业务逻辑\",\"数据结构是为了高效访问数据而设计出的一种数据的**组织和存储方式。更具体的说，一个数据结构包含一个数据元素的集合、数据元素之间的关系以及访问和操作数据的方法.**\",\"高效访问数据：\",\"数据的组织和存储方式。\",\"数据元素的集合。\",\"访问和操作数据的方法。\",\"一般而言，数据结构针对的是内存中的数据，所以在学习数据结构之前，需要先对内存有一个简单的了解。\",\"内存是由许多存储单元组成，每个存储单元可以存储一个固定大小的数据块，通常以字节（byte）为单位。每个存储单元都有一个唯一的地址，操作系统正是根据这一地址去访问内存中的数据的。我们讨论的数据结构中的数据元素就是保存在这些一个个的内存单元中，这些数据元素或存储在连续的内存单元中，或存储在分散的内存单元中。\",\"连续存储\",\"分散存储\",\"数组\",\"链表\",\"数据结构存储方式\"]},\"181\":{\"h\":\"数据结构类型\"},\"182\":{\"h\":\"线性结构\",\"t\":[\"数据元素按照顺序进行排列，强调数据元素的前后或者升降顺序\",\"数组\",\"链表\",\"栈\",\"队列\"]},\"183\":{\"h\":\"非线性结构\",\"t\":[\"树\",\"所有数据元素按照层次结构进行组织，强调元素之间的父子关系\",\"图\",\"由定点和边组成，顶点对应数据元素，边链接两个顶点，表示两个数项元素之间的关系。图形结构用于表达元素之间复杂的网络关系。\",\"其他 \",\"二维数组\",\"多维数组\",\"..............\"]},\"184\":{\"h\":\"小结：\",\"t\":[\"数据结构类型\"]},\"185\":{\"h\":\"算法概述\"},\"186\":{\"h\":\"算法是什么\",\"t\":[\"算法是一个用于解决特定问题的优先指令序列（计算可以执行的操作）\"]},\"187\":{\"h\":\"常见算法分类\"},\"188\":{\"h\":\"常见搜索算法\",\"t\":[\"针对树形结构：\",\"深度优先搜索：纵向\",\"广度优先搜索：一层一层进行搜索\"]},\"189\":{\"h\":\"常见排序算法\",\"t\":[\"冒泡排序：相邻做比较\",\"选择排序：首尾做比较\",\"插入排序\",\"快速排序\",\"归并排序\",\"堆排序\",\"桶排序\",\"基数排序\",\"希尔排序\",\"计数排序\",\"位图排序\",\"其它排序\"]},\"190\":{\"h\":\"常见查找算法\",\"t\":[\"查找算法和搜索算法不一样，查找是找一个，搜索是找多个。\",\"顺序查找\",\"二分查找：折半查找\",\"需要是有序数据：1,3,6,10,20,34（从10开始进行查找）\",\"插值查找\",\"斐波那契查找\",\"分块查找\",\"哈希查找\",\"其它查找\"]},\"191\":{\"h\":\"常见实现策略算法\",\"t\":[\"暴力破解\",\"增量\",\"分治\",\"动态规划\",\"贪心算法\",\"递归\"]},\"192\":{\"h\":\"如何评价一个算法的好坏\",\"t\":[\"一个算法的好坏是通过时间复杂度和空间复杂度来恒量的\",\"解决特定问题有很多实现方式，找到一种最优的实现方式，找到一种最优算法\",\"简单来说：\",\"所花的时间与占用内存便是衡量一个算法好坏的标准\",\"时间复杂度：就是执行算法的时间成本，随着程序执行次数增多，时间变化值是如何的（运行时间越小越好）\",\"空间复杂度：就是执行算法的内存空间成本（实际中并不考虑，实际中可以进行物理拓展【添加内训，增加配件特性】，使用空间换取时间，一般不衡量这个东西）\",\"使用空间换取时间：\",\"两个指标一般不能同时进行满足。\",\"时间复杂度使用一种特殊的方式进行表示就是O表示法\"]},\"193\":{\"h\":\"高中数学：对数函数vs指数函数复习\",\"t\":[\"指数函数：次方\",\"指数函数\",\"对数函数：以2为底8的对数\",\"对数函数\",\"对数课本内容\",\"补充说明\",\"在描述算法复杂度时，经常用到o(1)， o(n)， o(logn)， o(nlogn)来表示对应算法的时间复杂度，这是算法的时间复杂度的表示。\",\"O后面的括号中有一个函数，指明某个算法的耗时与数据增长量之间的关系。其中的n代表输入数据的量。\",\"O(n)：n表示代码执行次数和数据量，代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。\",\"O(logn)：当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。\",\"O(nlogn)：n乘以logn，当数据增大256倍时，耗时增256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。\",\"O(1)：最低的时空复杂度，也就是耗时与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）\",\"O(1)：无论多少数据执行都是1\",\"复杂度表\"]},\"194\":{\"h\":\"复杂度的大欧O(X)表示法\",\"t\":[\"时间复杂度 与 空间复杂度 都是用 “大O” 来表示(大欧表示法)，写作 O(*)\",\"由于目前内存便宜，此刻我们谈论复杂度\",\"一般谈论的都是时间复杂度\",\"时间复杂度BigO，大欧表示法\",\"复杂度大O（X）\",\"量级增加时，时间增长的趋势。\",\"常见时间复杂度的 “大O表示法” 描述有以下几种\",\" 时间复杂度和空间复杂度的关系\"]},\"195\":{\"h\":\"小结\",\"t\":[\"时间复杂度排序\",\"排序比较\",\"nlogN\"]},\"196\":{\"h\":\"b.数组Array\"},\"197\":{\"h\":\"基础知识\",\"t\":[\"数组是具有相同类型的数据的集合，也就是说数组的所有元素类型都是相同的，在所有数据结构中，数组算是最常见也是最简单的一种数据结构，我们最常见的也就是一维数组，当然还有二维数组，三维数组...\",\"数组首先需要先进行声明才能使用，数组的大小一旦确定就不能进行修改，比如我们声明一个长度为10的数组\",\"//定义数组 int[] array = new int[10]; //数组的长度 int length = array.length; //索引 从0开始 array[0] ArrayList 初始值是0 new的时候是10 \",\"数组的下标是从0开始，比如上面数组的第一个元素是array[0],最后一个元素是array[9]。\",\"数组array\"]},\"198\":{\"h\":\"数组优缺点\"},\"199\":{\"h\":\"优点：\",\"t\":[\"查找快:线性关系，有顺序的存储\",\"使用下标位置索引十分高效的访问任意元素，修改快\"]},\"200\":{\"h\":\"缺点：\",\"t\":[\"插入和删除操作开销大\",\"说明：\",\"由于数组的内存连续性，插入和删除元素可能需要移动其他元素，导致开销比较大。特别是在开头和空间进行插入的时候，存在大量的数据编译操作。\",\"索引：相当图书的目录\",\"索引MySQL会讲到。\",\"数组Array的缺点\"]},\"201\":{\"h\":\"架构设计一个通用数组，考虑封装思想\"},\"202\":{\"h\":\"约定变量\",\"t\":[\"data[]\",\"size实际个数\"]},\"203\":{\"h\":\"正序和反序打印数组\",\"t\":[\"数组原理图\",\"/** *索引从0开始 */ public class DemoPrintArray{ public static void main(String[] args){ //1.定义数组 int[] ints = new int[]{1,2,3,4,5,6}; //2.遍历数组输出内容 //正向输出 for(int i = 0;i < ints.length;i++){ System.out.println(\\\"ints[\\\"+i+\\\"]=\\\"_ints[i]); } System.out.println(\\\"------------\\\"); //反向输出：要包含0，因为0是第一位 //小练习，数组正反向输出 for(int i = ints.length;i >= 0 ;i--){ System.out.println(\\\"ints[\\\"+i+\\\"]=\\\"_ints[i]); } } } \"]},\"204\":{\"h\":\"小口诀\",\"t\":[\"增删改查含，扩（扩容）缩（缩容）正反印\"]},\"205\":{\"h\":\"普通版步骤V1\",\"t\":[\"定义属性:int[] data,int size\",\"初始化capacity容量\",\"构建注入对数组进行初始化,主要是最大容量capacity值\",\"简单辅助,getSize+getCapacity+isEmpty+isFull\",\"增 \",\"头增,往数组第一位置新增一个元素:addFirst(int e)\",\"中增,指定索引下标位置,插入元素:add(int index ,int e)\",\"尾增,往数组最后新增一个元素:addLast(int e)\",\"删 \",\"头删,往数组第一位置删除一个元素,然后返回元素 removeFirst()\",\"中删,指定索引下标位置,删除元素,并返回元素,remove(int index)\",\"尾删,往数组最后删除一个元素,并返回元素:removeLast()\",\"修改,按照下标index设置元素,并返回元素set(int index,int e)\",\"查询,按照下标index获取元素get(int index)\",\"打印: \",\"打印,按照正序打印:print()\",\"逆印,按照逆序打印:printReverse()\",\"code实例\",\"public class MyArray{ /** *增删改查含，正反印 */ //1.定义属性 int[] data; int size; //2.构造对象 public MyArray(){ this(5); //默认值为5，调用的是有参构造。 } public MyArray(int capacity){ data = new int[capacity]; size = 0; } private int getSize(){//得到数组长度 return size; } public int getCategory(){//获取容量 return data.length; } public boolean isEmpty(){//是否为空 return size==0; } public boolean isFull(){//是否满了 return size==data.length; } //4.增 public void addFirst(int e){ add(0,e); } public void add(int index,int e){ if(isFull()){ throw new RuntimeException(\\\"数组满了,不能增加元素;后面考虑扩容问题!\\\"); } if(index<0||index>size){ throw new RuntimeException(\\\"超出数组边界范围\\\") } for(int i=size-1;i>=index;i--){ data[i+1] = data[i]; } //在索引位置添加1 data[index] = e; size ++; } public void addlast(int e){ //data[index] = e; add(size,e); } //5.删 public E removeFirst(){ return remove(0); } public int remove(int index){ if(isEmpty){ throw new RunTimeException(\\\"数组为空，不能删除空元素\\\");} if(index<0||index>=size){ throw new RunTimeException(\\\"索引不在范围边界内\\\"); } int result = data[index];//先获取要删除的索引对应的元素，方法返回 for(int i = index+1;i<size;i++){ //从索引+1位置进行左移动 data[i-1]=data[i]; } size--; return result; } public E removeLast(){ return remove(size-1); } //6.改 public E set(int index,int e){ if(index<0||index>=size){ throw new RuntimeException(\\\"索引不在边界范围\\\"); } return data[index] = e; } //7.查 public E get(int index){ if(index<0||index>size()){ throw new RuntimeExcption(\\\"索引不在边界范围\\\"); } } //8.包含 public boolean contain(int e){ for(int i = 0;i<size;i++){ if(data[i]==e){ return true; } } return false; } } \"]},\"206\":{\"h\":\"封装数组泛型版V2\",\"t\":[\"泛型概念\",\"泛型的使用\",\"泛型制作用于源代码阶段，只为了在写代码的时候进行更加基础的识别。\",\"/** *v2版（带泛型）：增删改查含，扩缩正反印 */ public class MyArrayGeneric<E>{ //1.定义树形 E[] data; int size(); //2.构造对象 public MyArrayGeneric(){ this(5); } public MyArrayGeneric(int capacity){ //data = new int[capacity] data = (E[]) new Object[capacity]; //不支持new E只能先创建一个object类型的，然后进行强转。 size=0; } //3.基础函数 public int getSize(){ return size; } public int getCapacity(){ return data.length; } public boolean isEmpty(){ return size == 0; } public boolean isFull(){ return size == data.lenth; } //增 public void add(int index,E e){ if(isFull()){ return new RuntimeException(\\\"数组已经满了，无法添加，你可以尝试进行扩容\\\"); } if(index<0||index>=size){ return new RuntimeException(\\\"超过边界值，请检查\\\"); } for(int i = size-1;i>index;i--){ data[i+1] = data[i]; } data[index] = e; size++; } public void addFirst(E e){ add(0,e); } public void addLast(E e){ add(size - 1,e); } //删 public E remove(int index){ } } \"]},\"207\":{\"h\":\"规范的定制化接口IMyArray\",\"t\":[\"使用interface为了更加规范，先写接口再写实现类：\",\"概念：多态 一个接口有多个实现类\"]},\"208\":{\"h\":\"完善数组封装\",\"t\":[\"//扩容 public void resize(int newCapacity){ //创建新数组，使用新容量 E[] newData = (E())new Object[newCapacity]; //遍历之前数组，把书组织放到新数组里面 for(int i = 0;i < getSize();i++){ newData[i] = data[i]; } //复制给data进行返回 data = newData; return data; } \",\"//缩容 public void resize(int newCapacity){ E[] newData = (E())new Object[newCapacity]; if(getSize() == getCapacity()/2){ System.out.println(\\\"resize()---------\\\") resize(newCapacity/2) } } \"]},\"209\":{\"h\":\"leetcode数组练习经典题：反转字符串\",\"t\":[\"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\"不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\",\"class Solution{ public void reverseString(char[] s){ for(int left = 0,right = s.length-1;left<right;left++,right--){ char tmp = s[left]; s[left] = s[right]; s[right] = s[left]; } } } \"]},\"210\":{\"h\":\"任务1：ArrayList底层结构和扩容机制\"},\"211\":{\"h\":\"复习ArrayList集合\",\"t\":[\"概述： ArrayList是List的实现类\",\"特点： 元素有序，元素可重复，有索引，线程不安全\",\"**数据结构：**数组\",\"常用方法：\",\"boolean add(E e)-->将元素添加到集合中-->(add方法一定能添加成功的，所以我们不用boolean接受返回值)； void add(int index,E element)-->在指定索引位置上添加元素 boolean remove(Object o)-->删除指定的元素，删除成功为true，删除不成功为false E remove(int index)-->删除指定索引位置上的元素，返回的是被删除的元素 E set(int index,E element)-->将指定索引位置上的元素，修改成后面的element元素 E get(int index)-->根据索引获取元素 int size()-->获取集合元素个数 \"]},\"212\":{\"h\":\"底层源码分析\",\"t\":[\"ArrayList构造：\",\"1.ArrayList():构造一个初始量为10的空列表\",\"2.ArrayList(int initialCapacity):构造一个具有指定出事容量的空列表\",\"ArrayList源码总结：\",\"不是一new底层就会创建初始容量为10的空列表，而是第一次add的时候才会创建初始容量为10的空列表\",\"ArrayList底层是数组，为什么还说集合长度可变？答案：ArrayList底层会自动扩容-->Arrays.copyof\",\"每次扩容的倍数是多少？1.5倍\",\"ArrayList():构造一个初始容量为 10 的空列表 ====================================== ArrayList<String> list = new ArrayList<>(); /* transient Object[] elementData; -> 此数组就是ArrayList底层的那个数组 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } ========================================== list.add(\\\"abc\\\"); public boolean add(E e) { ensureCapacityInternal(size + 1 -> 1); // Increments modCount!! elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity->1) { ensureExplicitCapacity(calculateCapacity(elementData->数组, minCapacity->1)->10); } private static int calculateCapacity(Object[] elementData->数组, int minCapacity->1) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { // Math.max(10,1)-> return 10 return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity->10) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity->10); } private void grow(int minCapacity->10) { // overflow-conscious code int oldCapacity = elementData.length;//0 int newCapacity = oldCapacity + (oldCapacity >> 1);//计算新数组的长度.证明每次扩容1.5倍 if (newCapacity - minCapacity < 0) newCapacity = minCapacity;//newCapacity = 10 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity->10); } \",\" ArrayList<String> list1 = new ArrayList<>(5); \",\" public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } } \",\"ArrayList数组扩容机制\"]},\"213\":{\"h\":\"任务2：HashMap底层结构和扩容机制\",\"t\":[\"哈希表扩容机制\",\"HashMap底层数据结构：哈希表\",\"哈希表底层数据结构是数组。 哈希表不能存储基本数据类型，哈希表存储的元素具有唯一性。 哈希表存储元素的过程是先判断要存储的元素与已有元素的hashcode是不是相同，如果不相同则会直接存储，如果相同就会继续调用equals方法判断，如果equals方法返回的是true则不能存储否则可以存储。 \",\"jdk7:哈希表+链表 jdk8:数组+链表+红黑树\",\"哈希表排序过程：\",\"先算哈希值，此哈希值在HashMap底层经过了特殊的计算得出\",\"如果哈希值不一样，直接存\",\"如果哈希值一样，再去比较内容，如果内容不一样，也存\",\"如果哈希值一样内容一样，直接去掉重复内容（后面的value将前面的value覆盖掉）\",\"哈希值一样内容不一样，我们把这种现象叫做哈希冲突（也叫做哈希碰撞）\",\"要知道的几点：\",\"在不指定长度时，哈希表的默认长度是16，HashMap创建出来，一开始没有创建长度为16的数组\",\"什么时候创建长度为16的数组：在第一次put的时候，底层会创建长度为16的数组\",\"哈希表中的一个数据【加载因子】-->代表当元素存储到百分之75的时候就要扩容了-->扩容大小是2倍\",\"如果对个别元素出现哈希值一样，内容不一样的时候，就会在同一个索引上以链表的形式存储，当链表的长度达到8，且当前数组长度大于64的时候，链表就会使用红黑树进行存储\",\"如果后续删除元素，那么在同一个索引的位置上的元素小于6，红黑树就会变成链表\",\"加入红黑树的目的是：查询更快\",\"外面笔试时可能会问到的变量 default_initial_capacity:HashMap默认容量 16 default_load_factor:HashMap默认加载因子 0.75f threshold:扩容的临界值 等于 容量*0.75 = 12 第一次扩容 treeify_threshold:链表长度默认值,转为红黑树:8 min_treeify_capacity:链表被树化时最小的数组容量:64 \"]},\"214\":{\"h\":\"1.HashMap无参数构造方法的分析\",\"t\":[\"//HashMap中的静态成员变量 static final float DEFAULT_LOAD_FACTOR = 0.75f; public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } \",\"解析：使用无参数构造方法创建HashMap对象，将加载因子设置为默认的加载因子，loadFactor=0.75F。\"]},\"215\":{\"h\":\"2.HashMap有参数构造方法分析\",\"t\":[\"HashMap(int initialCapacity, float loadFactor) ->创建Map集合的时候指定底层数组长度以及加载因子 public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity < 0) throw new IllegalArgumentException(\\\"Illegal initial capacity: \\\" + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor <= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\\\"Illegal load factor: \\\" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);//10 } \",\"解析：带有参数构造方法，传递哈希表的初始化容量和加载因子\",\"如果initialCapacity（初始化容量）小于0，直接抛出异常。\",\"如果initialCapacity大于最大容器，initialCapacity直接等于最大容器 \",\"MAXIMUM_CAPACITY = 1 << 30 是最大容量 (1073741824)\",\"如果loadFactor（加载因子）小于等于0，直接抛出异常\",\"tableSizeFor（initialCapacity）方法计算哈希表的初始化容量。 \",\"注意：哈希表是进行计算得出的容量，而初始化容量不直接等于我们传递的参数。\"]},\"216\":{\"h\":\"3.tableSizeFor方法分析\",\"t\":[\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 8 4 2 1规则->无论指定了多少容量,最终经过tableSizeFor这个方法计算之后,都会遵循8421规则去初始化列表容量 \",\"解析：该方法对我们传递的初始化容量进行位移运算，位移的结果是 8 4 2 1 码\",\"例如传递2，结果还是2，传递的是4，结果还是4。\",\"例如传递3，结果是4，传递5，结果是8，传递20，结果是32。\"]},\"217\":{\"h\":\"4.Node 内部类分析\",\"t\":[\"哈希表是采用数组+链表的实现方法，HashMap中的内部类Node非常重要，证明HashSet是一个单向链表\",\" static class Node<K,V> implements Map.Entry<K,V> { final int hash; final K key; V value; Node<K,V> next; Node(int hash, K key, V value, Node<K,V> next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } \",\"解析：内部类Node中具有4个成员变量\",\"hash，对象的哈希值\",\"key，作为键的对象\",\"value，作为值得对象（讲解Set集合，不牵扯值得问题）\",\"next，下一个节点对象\"]},\"218\":{\"h\":\"5.存储元素的put方法源码\",\"t\":[\"public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } \",\"解析：put方法中调研putVal方法，putVal方法中调用hash方法。\",\"hash(key)方法：传递要存储的元素，获取对象的哈希值\",\"putVal方法，传递对象哈希值和要存储的对象key\"]},\"219\":{\"h\":\"6.putVal方法源码\",\"t\":[\"Node<K,V>[] tab; Node<K,V> p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; \",\"解析：方法中进行Node对象数组的判断，如果数组是null或者长度等于0，那么就会调研resize()方法进行数组的扩容。\"]},\"220\":{\"h\":\"7.resize方法的扩容计算\",\"t\":[\"if (oldCap > 0) { if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr << 1; // double threshold } \",\"解析：计算结果，新的数组容量=原始数组容量<<1，也就是乘以2。\"]},\"221\":{\"h\":\"8.确定元素存储的索引\",\"t\":[\"if ((p = tab[i = (n - 1) & hash]) == null) tab[i] = newNode(hash, key, value, null); \",\"解析：i = (数组长度 - 1) & 对象的哈希值，会得到一个索引，然后在此索引下tab[i]，创建链表对象。\",\"不同哈希值的对象，也是有可能存储在同一个数组索引下。\",\"其中resize()扩容的方法,默认是16 tab[i] = newNode(hash, key, value, null);->将元素放在数组中 i就是索引 i = (n - 1) & hash 0000 0000 0000 0000 0000 0000 0000 1111->15 & 0&0=0 0&1=0 1&1=1 0000 0000 0000 0001 0111 1000 0110 0011->96355 -------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0011->3 \",\" 0000 0000 0000 0000 0000 0000 0000 1111->15 & 0&0=0 0&1=0 1&1=1 0000 0000 0001 0001 1111 1111 0001 0010->1179410 -------------------------------------------------------- 0000 0000 0000 0000 0000 0000 0000 0010->2 \"]},\"222\":{\"h\":\"9.遇到重复哈希值的对象\",\"t\":[\" Node<K,V> e; K k; if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) e = p; \",\"解析：如果对象的哈希值相同，对象的equals方法返回true，判断为一个对象，进行覆盖操作。\",\"else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } \",\"解析：如果对象哈希值相同，但是对象的equals方法返回false，将对此链表进行遍历，当链表没有下一个节点的时候，创建下一个节点存储对象.\"]},\"223\":{\"h\":\"任务3：interface接口里面写什么类型方法（函数式接口）\"},\"224\":{\"h\":\"任务4：完成反转字符串代码\"},\"225\":{\"h\":\"任务5：今天封装数组代码\"},\"226\":{\"h\":\"c.栈Stack\"},\"227\":{\"h\":\"基础知识：\",\"t\":[\"栈是一种特殊的线性表，他只对栈顶进行添加和删除元素。栈有入栈和出栈两种操作。\",\"入栈和出栈模式图\"]},\"228\":{\"h\":\"栈是什么\",\"t\":[\"栈是什么？\"]},\"229\":{\"h\":\"栈的相关操作\",\"t\":[\"入栈addLast()+出栈removeLast（）\",\"Push：压栈操作和入栈操作\",\"Pop:弹栈操作和出栈操作\",\"Peek：查看栈顶数据，但是不出栈\"]},\"230\":{\"h\":\"架构设计一个通用栈，考虑封装思想\"},\"231\":{\"h\":\"判断条件\",\"t\":[\"初容大于零\",\"满了不能加\",\"空了不能取\"]},\"232\":{\"h\":\"IStackDesc栈接口\"},\"233\":{\"h\":\"MyStack\"},\"234\":{\"h\":\"对象游离（loitering）\",\"t\":[\"定义：即在栈的实现中有对象的应用，而我们并没有真正的使用他，所以当减少N时，在数组中仍然有我们已经出栈的对象的指针\",\"尽管我们知道我们不会再使用它了，但是Java系统不知道\",\"解决方案：最好在去除元素对应的项设为null，这样就不会剩下。\",\"对象游离解决方案\"]},\"235\":{\"h\":\"d.队列Queue\"},\"236\":{\"h\":\"基础知识\"},\"237\":{\"h\":\"队列是什么Queue\",\"t\":[\"队列是一种特殊的线性表，他的特殊性在于我们只能操作他头部和尾部的元素，中间的元素我们操作不了，我们只能在他的头部进行删除，尾部进行添加。就像大家排队到银行取钱一样，先来的肯定要排到前面，后来的只能排在队尾，所有元素都要遵守这个操作，没有VIP会员，所以走后门插队的现象是不可能存在的，他是一种先进先出的数据结构\",\"队列原理图\",\"队列是什么\"]},\"238\":{\"h\":\"结构设计一个队列，考虑封装问题\"},\"239\":{\"h\":\"判断条件\",\"t\":[\"初容大于零\",\"满了不能加\",\"空了不能取\"]},\"240\":{\"h\":\"队列接口IQueueDesc\"},\"241\":{\"h\":\"MyQueue\"},\"242\":{\"h\":\"e.链表\"},\"243\":{\"h\":\"基础知识\",\"t\":[\"链表\",\"单向链表 一个节点指向下一个节点\",\"n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。\",\"什么事链表\"]},\"244\":{\"h\":\"链表的优缺点\"},\"245\":{\"h\":\"优点\",\"t\":[\"插入和删除操作效率高\",\"链表的插入和删除\",\"动态性能更好\",\"链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。\",\"链表是真正的动态数据结构，不需要处理固定容量的问题\"]},\"246\":{\"h\":\"缺点\",\"t\":[\"查找慢\",\"由于链表中的节点不是连续存储的，无法像数组一样根据索引直接计算出每个节点的地址。\",\"必须从头节点开始遍历链表，直到找到目标节点，这导致了链表的随机访问效率较低。\",\"额外的存储空间\",\"链表的每个节点都需要存储指向下一个节点的指针，这会占用额外的存储空间。\",\"相比于数组，链表需要更多的内存空间来存储相同数量的数据元素\"]},\"247\":{\"h\":\"架构设计一个单链表，考虑封装问题\"},\"248\":{\"h\":\"构造node节点\",\"t\":[\"构造node节点\"]},\"249\":{\"h\":\"初始化定义：MyLinkedListV1\",\"t\":[\"1\"]},\"250\":{\"h\":\"第1版MyLinkedListV1\",\"t\":[\"1\"]},\"251\":{\"h\":\"增(改进版本)\",\"t\":[\"1\"]},\"252\":{\"h\":\"第2版MyLinkedListV2\",\"t\":[\"1\"]},\"253\":{\"h\":\"第3版MyLinkedListV3\",\"t\":[\"1\"]},\"254\":{\"h\":\"小总结\",\"t\":[\"1\"]},\"255\":{\"h\":\"leetcode链表练习经典题，课堂练习\",\"t\":[\"1\"]},\"256\":{\"h\":\"反转链表\",\"t\":[\"1\"]},\"257\":{\"h\":\"01\"},\"258\":{\"h\":\"你好\"},\"259\":{\"h\":\"测试\"},\"260\":{\"h\":\"Mysql\"},\"261\":{\"h\":\"Java高级\"},\"262\":{\"h\":\"Java\"},\"263\":{\"h\":\"测试\"},\"264\":{\"h\":\"Spring Cache\"},\"265\":{\"h\":\"Spring\"},\"266\":{\"h\":\"Java初级\"},\"267\":{\"h\":\"Spring Secutiry\"},\"268\":{\"h\":\"测试\"},\"269\":{\"h\":\"其他\"},\"270\":{\"h\":\"测试\"},\"271\":{\"h\":\"中间件\"},\"272\":{\"h\":\"测试\"},\"273\":{\"h\":\"前端\"},\"274\":{\"h\":\"课件\"},\"275\":{\"h\":\"数据结构\"},\"276\":{\"h\":\"1.尚品甄选\"},\"277\":{\"h\":\"项目\"}},\"dirtCount\":0,\"index\":[[\"尚品甄选\",{\"0\":{\"276\":1}}],[\"尚硅谷\",{\"1\":{\"161\":1}}],[\"前端\",{\"0\":{\"273\":1}}],[\"前端访问问题\",{\"1\":{\"46\":1}}],[\"课件\",{\"0\":{\"274\":1}}],[\"课堂练习\",{\"0\":{\"255\":1}}],[\"课前资料提供了编写好的jmeter测试样例\",{\"1\":{\"139\":1}}],[\"额外的存储空间\",{\"1\":{\"246\":1}}],[\"额外记录了请求和响应的头信息\",{\"1\":{\"89\":1}}],[\"直到找到目标节点\",{\"1\":{\"246\":1}}],[\"直接抛出异常\",{\"1\":{\"215\":2}}],[\"直接去掉重复内容\",{\"1\":{\"213\":1}}],[\"直接存\",{\"1\":{\"213\":1}}],[\"直接\",{\"1\":{\"141\":1}}],[\"必须从头节点开始遍历链表\",{\"1\":{\"246\":1}}],[\"必须使用springboot\",{\"1\":{\"56\":1}}],[\"彼此通过指针相连\",{\"1\":{\"243\":1}}],[\"考虑封装问题\",{\"0\":{\"238\":1,\"247\":1}}],[\"考虑封装思想\",{\"0\":{\"201\":1,\"230\":1}}],[\"没有vip会员\",{\"1\":{\"237\":1}}],[\"没有进行限流\",{\"1\":{\"143\":1}}],[\"他是一种先进先出的数据结构\",{\"1\":{\"237\":1}}],[\"他的特殊性在于我们只能操作他头部和尾部的元素\",{\"1\":{\"237\":1}}],[\"他只对栈顶进行添加和删除元素\",{\"1\":{\"227\":1}}],[\"尽管我们知道我们不会再使用它了\",{\"1\":{\"234\":1}}],[\"即在栈的实现中有对象的应用\",{\"1\":{\"234\":1}}],[\"即可直接使用\",{\"1\":{\"93\":1}}],[\"即可修改权重\",{\"1\":{\"72\":1}}],[\"即可以向此元素进行放大\",{\"1\":{\"38\":1}}],[\"即可在幻灯片获得焦点时进入全屏模式\",{\"1\":{\"36\":1}}],[\"即可在幻灯片获得焦点时进入预览模式\",{\"1\":{\"34\":1}}],[\"空了不能取\",{\"1\":{\"231\":1,\"239\":1}}],[\"空间复杂度\",{\"1\":{\"192\":1,\"194\":1}}],[\"满了不能加\",{\"1\":{\"231\":1,\"239\":1}}],[\"弹栈操作和出栈操作\",{\"1\":{\"229\":1}}],[\"压栈操作和入栈操作\",{\"1\":{\"229\":1}}],[\"入栈addlast\",{\"1\":{\"229\":1}}],[\"入栈和出栈模式图\",{\"1\":{\"227\":1}}],[\"入门程序\",{\"0\":{\"161\":1}}],[\"今天封装数组代码\",{\"0\":{\"225\":1}}],[\"函数式接口\",{\"0\":{\"223\":1}}],[\"遇到重复哈希值的对象\",{\"0\":{\"222\":1}}],[\"确定一个链表我们只需要头指针\",{\"1\":{\"243\":1}}],[\"确定元素存储的索引\",{\"0\":{\"221\":1}}],[\"确实被限流了\",{\"1\":{\"142\":1}}],[\"新的数组容量=原始数组容量<<1\",{\"1\":{\"220\":1}}],[\"新的请求会被立即拒绝并抛出flowexception异常\",{\"1\":{\"144\":1}}],[\"存储元素的put方法源码\",{\"0\":{\"218\":1}}],[\"存在大量的数据编译操作\",{\"1\":{\"200\":1}}],[\"存在的弊端\",{\"1\":{\"85\":1}}],[\"讲解set集合\",{\"1\":{\"217\":1}}],[\"k\",{\"1\":{\"217\":2,\"218\":1,\"222\":4}}],[\"key的写法如下\",{\"1\":{\"163\":1}}],[\"key\",{\"1\":{\"161\":2,\"163\":2,\"164\":2,\"165\":1,\"217\":5,\"218\":4,\"221\":2,\"222\":5}}],[\"证明hashset是一个单向链表\",{\"1\":{\"217\":1}}],[\"证明每次扩容1\",{\"1\":{\"212\":1}}],[\"传递对象哈希值和要存储的对象key\",{\"1\":{\"218\":1}}],[\"传递要存储的元素\",{\"1\":{\"218\":1}}],[\"传递20\",{\"1\":{\"216\":1}}],[\"传递5\",{\"1\":{\"216\":1}}],[\"传递的是4\",{\"1\":{\"216\":1}}],[\"传递哈希表的初始化容量和加载因子\",{\"1\":{\"215\":1}}],[\"码\",{\"1\":{\"216\":1}}],[\"位移的结果是\",{\"1\":{\"216\":1}}],[\"位图排序\",{\"1\":{\"189\":1}}],[\"该方法对我们传递的初始化容量进行位移运算\",{\"1\":{\"216\":1}}],[\"该表达式\",{\"1\":{\"163\":2}}],[\"|=\",{\"1\":{\"216\":5}}],[\"||\",{\"1\":{\"215\":1,\"219\":1,\"222\":1}}],[\"带有参数构造方法\",{\"1\":{\"215\":1}}],[\"带泛型\",{\"1\":{\"206\":1}}],[\"转为红黑树\",{\"1\":{\"213\":1}}],[\"容量\",{\"1\":{\"213\":1}}],[\"容错性高\",{\"1\":{\"46\":1}}],[\"外面笔试时可能会问到的变量\",{\"1\":{\"213\":1}}],[\"红黑树就会变成链表\",{\"1\":{\"213\":1}}],[\"且当前数组长度大于64的时候\",{\"1\":{\"213\":1}}],[\"什么事链表\",{\"1\":{\"243\":1}}],[\"什么时候创建长度为16的数组\",{\"1\":{\"213\":1}}],[\"什么都没有\",{\"1\":{\"135\":1}}],[\"要知道的几点\",{\"1\":{\"213\":1}}],[\"要包含0\",{\"1\":{\"203\":1}}],[\"任务5\",{\"0\":{\"225\":1}}],[\"任务4\",{\"0\":{\"224\":1}}],[\"任务3\",{\"0\":{\"223\":1}}],[\"任务2\",{\"0\":{\"213\":1}}],[\"任务1\",{\"0\":{\"210\":1}}],[\"答案\",{\"1\":{\"212\":1}}],[\"有索引\",{\"1\":{\"211\":1}}],[\"有顺序的存储\",{\"1\":{\"199\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"209\":1}}],[\"反转链表\",{\"0\":{\"256\":1}}],[\"反转字符串\",{\"0\":{\"209\":1}}],[\"反向输出\",{\"1\":{\"203\":1}}],[\"复习arraylist集合\",{\"0\":{\"211\":1}}],[\"复制给data进行返回\",{\"1\":{\"208\":1}}],[\"复杂度大o\",{\"1\":{\"194\":1}}],[\"复杂度的大欧o\",{\"0\":{\"194\":1}}],[\"复杂度表\",{\"1\":{\"193\":1}}],[\"完成反转字符串代码\",{\"0\":{\"224\":1}}],[\"完善数组封装\",{\"0\":{\"208\":1}}],[\"完整的服务注册数据存储结构如下所示\",{\"1\":{\"74\":1}}],[\"概念\",{\"1\":{\"207\":1}}],[\"概述\",{\"1\":{\"85\":1,\"108\":1,\"122\":1,\"211\":1}}],[\"规范的定制化接口imyarray\",{\"0\":{\"207\":1}}],[\"规则如下\",{\"1\":{\"149\":1}}],[\"泛型制作用于源代码阶段\",{\"1\":{\"206\":1}}],[\"泛型的使用\",{\"1\":{\"206\":1}}],[\"泛型概念\",{\"1\":{\"206\":1}}],[\"封装数组泛型版v2\",{\"0\":{\"206\":1}}],[\"改进版本\",{\"0\":{\"251\":1}}],[\"改\",{\"1\":{\"205\":1}}],[\"得到数组长度\",{\"1\":{\"205\":1}}],[\"得到了结果\",{\"1\":{\"101\":1}}],[\"构造node节点\",{\"0\":{\"248\":1},\"1\":{\"248\":1}}],[\"构造一个初始容量为\",{\"1\":{\"212\":1}}],[\"构造一个初始量为10的空列表\",{\"1\":{\"212\":1}}],[\"构造一个具有指定出事容量的空列表\",{\"1\":{\"212\":1}}],[\"构造对象\",{\"1\":{\"205\":1,\"206\":1}}],[\"构建注入对数组进行初始化\",{\"1\":{\"205\":1}}],[\"逆印\",{\"1\":{\"205\":1}}],[\"尾节点没有后续节点\",{\"1\":{\"243\":1}}],[\"尾部进行添加\",{\"1\":{\"237\":1}}],[\"尾删\",{\"1\":{\"205\":1}}],[\"尾增\",{\"1\":{\"205\":1}}],[\"头删\",{\"1\":{\"205\":1}}],[\"头增\",{\"1\":{\"205\":1}}],[\"删\",{\"1\":{\"205\":2,\"206\":1}}],[\"删除不成功为false\",{\"1\":{\"211\":1}}],[\"删除成功为true\",{\"1\":{\"211\":1}}],[\"删除元素\",{\"1\":{\"205\":1}}],[\"删除spzx\",{\"1\":{\"93\":1}}],[\"删除src目录\",{\"1\":{\"52\":1}}],[\"删除线\",{\"1\":{\"6\":1}}],[\"往数组最后删除一个元素\",{\"1\":{\"205\":1}}],[\"往数组最后新增一个元素\",{\"1\":{\"205\":1}}],[\"往数组第一位置删除一个元素\",{\"1\":{\"205\":1}}],[\"往数组第一位置新增一个元素\",{\"1\":{\"205\":1}}],[\"简单辅助\",{\"1\":{\"205\":1}}],[\"简单来说\",{\"1\":{\"192\":1}}],[\"主要是最大容量capacity值\",{\"1\":{\"205\":1}}],[\"主要功能为入口流量控制\",{\"1\":{\"131\":1}}],[\"普通版步骤v1\",{\"0\":{\"205\":1}}],[\"缩容\",{\"1\":{\"204\":1,\"208\":1}}],[\"缩\",{\"1\":{\"204\":1}}],[\"缩放\",{\"0\":{\"38\":1}}],[\"扩缩正反印\",{\"1\":{\"206\":1}}],[\"扩容的方法\",{\"1\":{\"221\":1}}],[\"扩容的临界值\",{\"1\":{\"213\":1}}],[\"扩容\",{\"1\":{\"204\":1,\"208\":1}}],[\"扩\",{\"1\":{\"204\":1}}],[\"小总结\",{\"0\":{\"254\":1}}],[\"小于等于0\",{\"1\":{\"215\":1}}],[\"小于0\",{\"1\":{\"215\":1}}],[\"小口诀\",{\"0\":{\"204\":1}}],[\"小练习\",{\"1\":{\"203\":1}}],[\"小结\",{\"0\":{\"184\":1,\"195\":1}}],[\"正反印\",{\"1\":{\"204\":1,\"205\":1}}],[\"正向输出\",{\"1\":{\"203\":1}}],[\"正序和反序打印数组\",{\"0\":{\"203\":1}}],[\"遍历之前数组\",{\"1\":{\"208\":1}}],[\"遍历数组输出内容\",{\"1\":{\"203\":1}}],[\"遍历map\",{\"1\":{\"108\":1}}],[\"约定变量\",{\"0\":{\"202\":1}}],[\"架构设计一个单链表\",{\"0\":{\"247\":1}}],[\"架构设计一个通用栈\",{\"0\":{\"230\":1}}],[\"架构设计一个通用数组\",{\"0\":{\"201\":1}}],[\"架构下多语言限流的问题\",{\"1\":{\"131\":1}}],[\"特别是在开头和空间进行插入的时候\",{\"1\":{\"200\":1}}],[\"特点\",{\"1\":{\"46\":1,\"126\":1,\"211\":1}}],[\"导致开销比较大\",{\"1\":{\"200\":1}}],[\"导入课前资料提供的测试样例\",{\"1\":{\"139\":1}}],[\"初容大于零\",{\"1\":{\"231\":1,\"239\":1}}],[\"初始化定义\",{\"0\":{\"249\":1}}],[\"初始化容量\",{\"1\":{\"215\":1}}],[\"初始化capacity容量\",{\"1\":{\"205\":1}}],[\"初始值是0\",{\"1\":{\"197\":1}}],[\"初识sentinel\",{\"0\":{\"121\":1}}],[\"索引不在边界范围\",{\"1\":{\"205\":2}}],[\"索引不在范围边界内\",{\"1\":{\"205\":1}}],[\"索引从0开始\",{\"1\":{\"203\":1}}],[\"索引mysql会讲到\",{\"1\":{\"200\":1}}],[\"索引\",{\"1\":{\"197\":1,\"200\":1}}],[\"三维数组\",{\"1\":{\"197\":1}}],[\"量级增加时\",{\"1\":{\"194\":1}}],[\"此哈希值在hashmap底层经过了特殊的计算得出\",{\"1\":{\"213\":1}}],[\"此数组就是arraylist底层的那个数组\",{\"1\":{\"212\":1}}],[\"此刻我们谈论复杂度\",{\"1\":{\"194\":1}}],[\"此时就可以使用\",{\"1\":{\"164\":1}}],[\"此时就需求使用全局过滤器\",{\"1\":{\"108\":1}}],[\"此时qps的曲线这样的\",{\"1\":{\"146\":1}}],[\"此时order微服务所对应的服务实例就属于新的名称空间\",{\"1\":{\"76\":1}}],[\"写作\",{\"1\":{\"194\":1}}],[\"哈希值一样内容不一样\",{\"1\":{\"213\":1}}],[\"哈希表是采用数组+链表的实现方法\",{\"1\":{\"217\":1}}],[\"哈希表是进行计算得出的容量\",{\"1\":{\"215\":1}}],[\"哈希表中的一个数据\",{\"1\":{\"213\":1}}],[\"哈希表的默认长度是16\",{\"1\":{\"213\":1}}],[\"哈希表排序过程\",{\"1\":{\"213\":1}}],[\"哈希表+链表\",{\"1\":{\"213\":1}}],[\"哈希表存储元素的过程是先判断要存储的元素与已有元素的hashcode是不是相同\",{\"1\":{\"213\":1}}],[\"哈希表存储的元素具有唯一性\",{\"1\":{\"213\":1}}],[\"哈希表不能存储基本数据类型\",{\"1\":{\"213\":1}}],[\"哈希表底层数据结构是数组\",{\"1\":{\"213\":1}}],[\"哈希表\",{\"1\":{\"213\":1}}],[\"哈希表扩容机制\",{\"1\":{\"213\":1}}],[\"哈希算法就是典型的o\",{\"1\":{\"193\":1}}],[\"哈希查找\",{\"1\":{\"190\":1}}],[\"耗空间都不变\",{\"1\":{\"193\":1}}],[\"耗时\",{\"1\":{\"193\":1}}],[\"耗时增256\",{\"1\":{\"193\":1}}],[\"耗时增大logn倍\",{\"1\":{\"193\":1}}],[\"耗时只增大8倍\",{\"1\":{\"193\":1}}],[\"耗时也增大几倍\",{\"1\":{\"193\":1}}],[\"无法像数组一样根据索引直接计算出每个节点的地址\",{\"1\":{\"246\":1}}],[\"无法添加\",{\"1\":{\"206\":1}}],[\"无论多少数据执行都是1\",{\"1\":{\"193\":1}}],[\"无论数据规模多大\",{\"1\":{\"193\":1}}],[\"无论输入数据增大多少倍\",{\"1\":{\"193\":1}}],[\"无需实现业务\",{\"1\":{\"142\":1}}],[\"无需自己使用resttemplate来发送了\",{\"1\":{\"86\":1}}],[\"经常用到o\",{\"1\":{\"193\":1}}],[\"补充说明\",{\"1\":{\"193\":1}}],[\"次方\",{\"1\":{\"193\":1}}],[\"指明某个算法的耗时与数据增长量之间的关系\",{\"1\":{\"193\":1}}],[\"指数函数\",{\"1\":{\"193\":2}}],[\"指定索引下标位置\",{\"1\":{\"205\":2}}],[\"指定访问集群机房\",{\"1\":{\"69\":1}}],[\"指定当前服务默认是哪个机房\",{\"1\":{\"69\":1}}],[\"指定spring\",{\"1\":{\"52\":1}}],[\"增\",{\"0\":{\"251\":1},\"1\":{\"205\":2,\"206\":1}}],[\"增删改查含\",{\"1\":{\"204\":1,\"205\":1,\"206\":1}}],[\"增加配件特性\",{\"1\":{\"192\":1}}],[\"增量\",{\"1\":{\"191\":1}}],[\"时间增长的趋势\",{\"1\":{\"194\":1}}],[\"时间变化值是如何的\",{\"1\":{\"192\":1}}],[\"时间复杂度排序\",{\"1\":{\"195\":1}}],[\"时间复杂度和空间复杂度的关系\",{\"1\":{\"194\":1}}],[\"时间复杂度bigo\",{\"1\":{\"194\":1}}],[\"时间复杂度使用一种特殊的方式进行表示就是o表示法\",{\"1\":{\"192\":1}}],[\"时间复杂度\",{\"1\":{\"192\":1,\"193\":1,\"194\":1}}],[\"时间过了就会返回兜底信息\",{\"1\":{\"127\":1}}],[\"找到一种最优算法\",{\"1\":{\"192\":1}}],[\"找到一种最优的实现方式\",{\"1\":{\"192\":1}}],[\"找到spzx\",{\"1\":{\"72\":1}}],[\"递归\",{\"1\":{\"191\":1}}],[\"贪心算法\",{\"1\":{\"191\":1}}],[\"动态性能更好\",{\"1\":{\"245\":1}}],[\"动态规划\",{\"1\":{\"191\":1}}],[\"动画\",{\"0\":{\"19\":1,\"21\":1}}],[\"动画片段用于高亮或显隐幻灯片中的元素\",{\"1\":{\"17\":1}}],[\"动画片段\",{\"0\":{\"16\":1,\"17\":1,\"18\":1,\"20\":1,\"22\":1,\"24\":1}}],[\"暴力破解\",{\"1\":{\"191\":1}}],[\"斐波那契查找\",{\"1\":{\"190\":1}}],[\"折半查找\",{\"1\":{\"190\":1}}],[\"二分查找就是o\",{\"1\":{\"193\":1}}],[\"二分查找\",{\"1\":{\"190\":1}}],[\"二维数组\",{\"1\":{\"183\":1}}],[\"搜索是找多个\",{\"1\":{\"190\":1}}],[\"计算结果\",{\"1\":{\"220\":1}}],[\"计算新数组的长度\",{\"1\":{\"212\":1}}],[\"计算可以执行的操作\",{\"1\":{\"186\":1}}],[\"计数排序\",{\"1\":{\"189\":1}}],[\"希尔排序\",{\"1\":{\"189\":1}}],[\"桶排序\",{\"1\":{\"189\":1}}],[\"堆排序\",{\"1\":{\"189\":1}}],[\"归并排序就是o\",{\"1\":{\"193\":1}}],[\"归并排序\",{\"1\":{\"189\":1}}],[\"插入元素\",{\"1\":{\"205\":1}}],[\"插入和删除操作效率高\",{\"1\":{\"245\":1}}],[\"插入和删除操作开销大\",{\"1\":{\"200\":1}}],[\"插入和删除元素可能需要移动其他元素\",{\"1\":{\"200\":1}}],[\"插入排序\",{\"1\":{\"189\":1}}],[\"插值查找\",{\"1\":{\"190\":1}}],[\"插件\",{\"1\":{\"32\":1}}],[\"插件后\",{\"1\":{\"8\":1,\"9\":1}}],[\"首节点没有前驱节点\",{\"1\":{\"243\":1}}],[\"首尾做比较\",{\"1\":{\"189\":1}}],[\"首先在sentinel控制台添加限流规则\",{\"1\":{\"139\":1}}],[\"首先会访问dispatcherservlet\",{\"1\":{\"138\":1}}],[\"冒泡排序\",{\"1\":{\"189\":1}}],[\"广度优先搜索\",{\"1\":{\"188\":1}}],[\"纵向\",{\"1\":{\"188\":1}}],[\"深度优先搜索\",{\"1\":{\"188\":1}}],[\"算法是一个用于解决特定问题的优先指令序列\",{\"1\":{\"186\":1}}],[\"算法是什么\",{\"0\":{\"186\":1}}],[\"算法概述\",{\"0\":{\"185\":1}}],[\"表示法\",{\"0\":{\"194\":1}}],[\"表示两个数项元素之间的关系\",{\"1\":{\"183\":1}}],[\"表格和分割线\",{\"1\":{\"10\":1}}],[\"边链接两个顶点\",{\"1\":{\"183\":1}}],[\"顶点对应数据元素\",{\"1\":{\"183\":1}}],[\"图形结构用于表达元素之间复杂的网络关系\",{\"1\":{\"183\":1}}],[\"图形化界面\",{\"1\":{\"131\":1}}],[\"图\",{\"1\":{\"183\":1}}],[\"强调元素之间的父子关系\",{\"1\":{\"183\":1}}],[\"强调数据元素的前后或者升降顺序\",{\"1\":{\"182\":1}}],[\"树\",{\"1\":{\"183\":1}}],[\"非线性结构\",{\"0\":{\"183\":1}}],[\"非临时实例\",{\"1\":{\"77\":1}}],[\"队列接口iqueuedesc\",{\"0\":{\"240\":1}}],[\"队列原理图\",{\"1\":{\"237\":1}}],[\"队列是什么\",{\"1\":{\"237\":1}}],[\"队列是什么queue\",{\"0\":{\"237\":1}}],[\"队列是一种特殊的线性表\",{\"1\":{\"237\":1}}],[\"队列queue\",{\"0\":{\"235\":1}}],[\"队列\",{\"1\":{\"182\":1}}],[\"栈的相关操作\",{\"0\":{\"229\":1}}],[\"栈是什么\",{\"0\":{\"228\":1},\"1\":{\"228\":1}}],[\"栈是一种特殊的线性表\",{\"1\":{\"227\":1}}],[\"栈有入栈和出栈两种操作\",{\"1\":{\"227\":1}}],[\"栈stack\",{\"0\":{\"226\":1}}],[\"栈\",{\"1\":{\"182\":1}}],[\"线性关系\",{\"1\":{\"199\":1}}],[\"线性结构\",{\"0\":{\"182\":1}}],[\"线程不安全\",{\"1\":{\"211\":1}}],[\"线程隔离\",{\"1\":{\"125\":1}}],[\"线程等\",{\"1\":{\"91\":1}}],[\"链表需要更多的内存空间来存储相同数量的数据元素\",{\"1\":{\"246\":1}}],[\"链表是真正的动态数据结构\",{\"1\":{\"245\":1}}],[\"链表不需要像数组那样预先指定固定的大小\",{\"1\":{\"245\":1}}],[\"链表的每个节点都需要存储指向下一个节点的指针\",{\"1\":{\"246\":1}}],[\"链表的插入和删除\",{\"1\":{\"245\":1}}],[\"链表的优缺点\",{\"0\":{\"244\":1}}],[\"链表被树化时最小的数组容量\",{\"1\":{\"213\":1}}],[\"链表长度默认值\",{\"1\":{\"213\":1}}],[\"链表就会使用红黑树进行存储\",{\"1\":{\"213\":1}}],[\"链表\",{\"0\":{\"242\":1},\"1\":{\"180\":1,\"182\":1,\"243\":1}}],[\"链路模式中\",{\"1\":{\"143\":1}}],[\"链路模式\",{\"0\":{\"143\":1},\"1\":{\"143\":1}}],[\"链路\",{\"1\":{\"141\":1,\"143\":1}}],[\"连续存储\",{\"1\":{\"180\":1}}],[\"操作系统正是根据这一地址去访问内存中的数据的\",{\"1\":{\"180\":1}}],[\"为什么还说集合长度可变\",{\"1\":{\"212\":1}}],[\"为单位\",{\"1\":{\"180\":1}}],[\"为了保证每一个服务的高可用\",{\"1\":{\"69\":1}}],[\"通常以字节\",{\"1\":{\"180\":1}}],[\"通过头指针就可以把整个链表都能推出来\",{\"1\":{\"243\":1}}],[\"通过如下命令打开jmeter\",{\"1\":{\"139\":1}}],[\"通过界面配置sentinel的控制\",{\"1\":{\"131\":1}}],[\"通过实体类\",{\"1\":{\"118\":1}}],[\"通过\",{\"1\":{\"116\":1,\"143\":1}}],[\"通过这个可以获得request对象\",{\"1\":{\"108\":1}}],[\"通过网关多一层处理保障服务器安全\",{\"1\":{\"95\":1}}],[\"通过设置适当的超时时间\",{\"1\":{\"91\":1}}],[\"通过getlazyprovider方法获取serviceinstancelistsupplier对象\",{\"1\":{\"83\":1}}],[\"通过reactieloadbalancer从服务列表中选择一个服务实例地址\",{\"1\":{\"80\":1}}],[\"通过loadbalancerinterceptor请求拦截器拦截我们的resttemplate请求\",{\"1\":{\"80\":1}}],[\"通过添加添加jvm参数更改服务实例所属集群\",{\"1\":{\"70\":1}}],[\"通过注册中心可以对服务提供方和消费方解耦合\",{\"1\":{\"58\":1}}],[\"通过启用\",{\"1\":{\"32\":1}}],[\"更具体的说\",{\"1\":{\"180\":1}}],[\"更改application\",{\"1\":{\"143\":1}}],[\"更改远程调用代码\",{\"1\":{\"66\":1}}],[\"程序=框架+业务逻辑\",{\"1\":{\"180\":1}}],[\"程序=数据结构+算法\",{\"1\":{\"180\":1}}],[\"缓存所有分类数据\",{\"0\":{\"165\":1}}],[\"缓存的key\",{\"1\":{\"161\":1,\"163\":1,\"164\":1}}],[\"缓存的名称\",{\"1\":{\"161\":1,\"163\":1,\"164\":1}}],[\"清理指定缓存\",{\"1\":{\"164\":1}}],[\"​\",{\"1\":{\"163\":1}}],[\"放入缓存\",{\"1\":{\"163\":1}}],[\"本次我们直接使用redis作为缓存技术\",{\"1\":{\"161\":1}}],[\"本例中就是\",{\"1\":{\"81\":1}}],[\"接下来\",{\"1\":{\"161\":1}}],[\"接收返回主句\",{\"1\":{\"54\":1}}],[\"若没有数据\",{\"1\":{\"160\":1,\"161\":1}}],[\"描述有以下几种\",{\"1\":{\"194\":1}}],[\"描述\",{\"1\":{\"159\":1}}],[\"针对树形结构\",{\"1\":{\"188\":1}}],[\"针对不同的缓存技术需要实现不同的cachemanager\",{\"1\":{\"159\":1}}],[\"针对所有的路由都有效\",{\"1\":{\"105\":2}}],[\"介绍\",{\"0\":{\"159\":1}}],[\"页面有bug\",{\"1\":{\"149\":1}}],[\"页面展示\",{\"1\":{\"41\":1}}],[\"声明资源名称\",{\"1\":{\"149\":1}}],[\"声明当前接口是一个访问user\",{\"1\":{\"86\":1}}],[\"高中数学\",{\"0\":{\"193\":1}}],[\"高效访问数据\",{\"1\":{\"180\":1}}],[\"高效性强\",{\"1\":{\"46\":1}}],[\"高一些\",{\"1\":{\"148\":1}}],[\"做统计\",{\"1\":{\"148\":1}}],[\"做自己的业务逻辑\",{\"1\":{\"108\":1}}],[\"代表数据量增大几倍\",{\"1\":{\"193\":1}}],[\"代表以返回对象的name属性作为key\",{\"1\":{\"163\":1}}],[\"代表以返回对象的id属性作为key\",{\"1\":{\"163\":1}}],[\"代表的含义是\",{\"1\":{\"148\":1}}],[\"代码如下所示\",{\"1\":{\"83\":1,\"117\":3}}],[\"代码实现\",{\"1\":{\"65\":1,\"93\":1}}],[\"代码混乱\",{\"1\":{\"45\":1}}],[\"代码\",{\"0\":{\"32\":1}}],[\"代码块会自动高亮\",{\"1\":{\"8\":1}}],[\"之前的限流是统计访问某个资源的所有请求\",{\"1\":{\"148\":1}}],[\"再去比较内容\",{\"1\":{\"213\":1}}],[\"再去sentinel查看实时监控的qps曲线\",{\"1\":{\"146\":1}}],[\"再次点击即可缩小\",{\"1\":{\"38\":1}}],[\"已经超过了我们设定的10\",{\"1\":{\"146\":1}}],[\"平滑的qps曲线\",{\"1\":{\"146\":1}}],[\"平均负担压力\",{\"1\":{\"46\":1}}],[\"现在\",{\"1\":{\"146\":1}}],[\"现有代码缺点\",{\"1\":{\"93\":1}}],[\"个请求\",{\"1\":{\"146\":1}}],[\"意味着预期等待时长超过2000ms的请求会被拒绝并抛出异常\",{\"1\":{\"146\":1}}],[\"意味着每200ms处理一个队列中的请求\",{\"1\":{\"146\":1}}],[\"到sentinel控制台查看实时监控\",{\"1\":{\"145\":1}}],[\"大欧表示法\",{\"1\":{\"194\":2}}],[\"大o表示法\",{\"1\":{\"194\":1}}],[\"大o\",{\"1\":{\"194\":1}}],[\"大大简化我们在业务中操作缓存的代码\",{\"1\":{\"159\":1}}],[\"大部分请求失败\",{\"1\":{\"145\":1}}],[\"大致有12个\",{\"1\":{\"102\":1}}],[\"刚刚启动时\",{\"1\":{\"145\":1}}],[\"利用排队的流控效果\",{\"1\":{\"146\":1}}],[\"利用warm\",{\"1\":{\"145\":1}}],[\"利用jmeter测试\",{\"1\":{\"139\":1}}],[\"案例演示\",{\"0\":{\"149\":1}}],[\"案例需求\",{\"1\":{\"145\":1,\"146\":1,\"149\":1}}],[\"案例实现\",{\"1\":{\"142\":1,\"143\":1}}],[\"我设置qps的maxthreshold为10\",{\"1\":{\"145\":1}}],[\"我们只能在他的头部进行删除\",{\"1\":{\"237\":1}}],[\"我们把这种现象叫做哈希冲突\",{\"1\":{\"213\":1}}],[\"我们最常见的也就是一维数组\",{\"1\":{\"197\":1}}],[\"我们讨论的数据结构中的数据元素就是保存在这些一个个的内存单元中\",{\"1\":{\"180\":1}}],[\"我们将通过一个入门案例来演示一下springcache的常见用法\",{\"1\":{\"161\":1}}],[\"我们希望在该用户信息保存到数据库的同时\",{\"1\":{\"163\":1}}],[\"我们希望这部分商品的qps限制与其它商品不一样\",{\"1\":{\"148\":1}}],[\"我们希望性能好的机器承担更多的用户请求\",{\"1\":{\"72\":1}}],[\"我们是对用户查询\",{\"1\":{\"142\":1}}],[\"我们刚才访问的spzx\",{\"1\":{\"138\":1}}],[\"我们先学习这种模式\",{\"1\":{\"137\":1}}],[\"我们需要删除缓存中对应的数据\",{\"1\":{\"164\":1}}],[\"我们需要做熔断操作\",{\"1\":{\"126\":1}}],[\"我们需要一种统一配置管理方案\",{\"1\":{\"111\":1}}],[\"我们业务系统也可以使用这种思想来防止出现雪崩效应\",{\"1\":{\"125\":1}}],[\"我们可以在save方法上加上注解\",{\"1\":{\"163\":1}}],[\"我们可以点击对应资源后面的按钮来设置规则\",{\"1\":{\"138\":1}}],[\"我们可以参考示例代码进行使用\",{\"1\":{\"102\":1}}],[\"我们可以设置权重\",{\"1\":{\"72\":1}}],[\"我们在浏览器访问\",{\"1\":{\"142\":1}}],[\"我们在配置文件中只是配置了一个访问路径的规则\",{\"1\":{\"102\":1}}],[\"我们在spzx\",{\"1\":{\"86\":1,\"136\":1}}],[\"我们就会执行熔断\",{\"1\":{\"126\":1}}],[\"我们就演示下网关的基本路由功能\",{\"1\":{\"101\":1}}],[\"我们就需要在order为服务中向user微服务发起一个http请求\",{\"1\":{\"54\":1}}],[\"我们继续跟入\",{\"1\":{\"81\":1}}],[\"我们也可以创建新的名称空间\",{\"1\":{\"75\":1}}],[\"我们的微服务系统结构如下\",{\"1\":{\"51\":1}}],[\"逐渐提高到maxthreshold值\",{\"1\":{\"145\":1}}],[\"逐个修改微服务配置就显得十分的不方便\",{\"1\":{\"111\":1}}],[\"持续指定时长\",{\"1\":{\"145\":1}}],[\"工作特点\",{\"1\":{\"145\":1}}],[\"工作流程\",{\"1\":{\"58\":1}}],[\"冷启动\",{\"1\":{\"145\":1}}],[\"排队等待\",{\"0\":{\"146\":1},\"1\":{\"144\":1,\"146\":1}}],[\"排序比较\",{\"1\":{\"195\":1}}],[\"排序的规则是什么呢\",{\"1\":{\"109\":1}}],[\"排序后依次执行每个过滤器\",{\"1\":{\"109\":1}}],[\"预热时长为5秒\",{\"1\":{\"145\":1}}],[\"预热时间为5秒\",{\"1\":{\"145\":1}}],[\"预热时间\",{\"1\":{\"145\":1}}],[\"预热模式\",{\"1\":{\"144\":1}}],[\"预览模式\",{\"0\":{\"34\":1}}],[\"win\",{\"1\":{\"212\":1}}],[\"warm\",{\"0\":{\"145\":1},\"1\":{\"144\":1,\"145\":2}}],[\"webflux\",{\"1\":{\"102\":1}}],[\"web\",{\"1\":{\"100\":1,\"143\":1}}],[\"web<\",{\"1\":{\"53\":1}}],[\"weight\",{\"1\":{\"72\":1}}],[\"达到阈值后\",{\"1\":{\"144\":1}}],[\"达到数十\",{\"1\":{\"111\":1}}],[\"还有一个流控效果选项\",{\"1\":{\"144\":1}}],[\"察看结果树\",{\"1\":{\"143\":1,\"146\":1,\"149\":1}}],[\"运行时间越小越好\",{\"1\":{\"192\":1}}],[\"运行时环境\",{\"1\":{\"131\":1}}],[\"运行测试程序\",{\"1\":{\"149\":1}}],[\"运行测试用例\",{\"1\":{\"146\":1}}],[\"运行测试\",{\"1\":{\"143\":1}}],[\"出现了新的资源\",{\"1\":{\"143\":1}}],[\"关闭context整合\",{\"1\":{\"143\":1}}],[\"关联流控模式的使用场景\",{\"1\":{\"142\":1}}],[\"关联模式\",{\"0\":{\"142\":1},\"1\":{\"142\":1}}],[\"关联\",{\"1\":{\"141\":1,\"142\":1}}],[\"订单保存成功\",{\"1\":{\"143\":1}}],[\"两个指标一般不能同时进行满足\",{\"1\":{\"192\":1}}],[\"两个有竞争关系的资源\",{\"1\":{\"142\":1}}],[\"两次出现异常\",{\"1\":{\"126\":1}}],[\"业务需求是优先支付和更新订单的业务\",{\"1\":{\"142\":1}}],[\"产生竞争\",{\"1\":{\"142\":1}}],[\"查\",{\"1\":{\"205\":1}}],[\"查找慢\",{\"1\":{\"246\":1}}],[\"查找快\",{\"1\":{\"199\":1}}],[\"查找是找一个\",{\"1\":{\"190\":1}}],[\"查找算法和搜索算法不一样\",{\"1\":{\"190\":1}}],[\"查询更快\",{\"1\":{\"213\":1}}],[\"查询\",{\"1\":{\"205\":1}}],[\"查询用户成功\",{\"1\":{\"143\":1}}],[\"查询用户\",{\"1\":{\"143\":3}}],[\"查询和修改操作会争抢数据库锁\",{\"1\":{\"142\":1}}],[\"查看栈顶数据\",{\"1\":{\"229\":1}}],[\"查看http请求\",{\"1\":{\"142\":1}}],[\"查看效果\",{\"1\":{\"136\":1}}],[\"查看实例分配情况\",{\"1\":{\"70\":1}}],[\"理解\",{\"1\":{\"141\":1}}],[\"理想的请求执行结果应该如下所示\",{\"1\":{\"139\":1}}],[\"统计结果\",{\"1\":{\"148\":1}}],[\"统计从指定链路访问到本资源的请求\",{\"1\":{\"141\":1}}],[\"统计与当前资源相关的另一个资源\",{\"1\":{\"141\":1,\"142\":1}}],[\"统计当前资源的请求\",{\"1\":{\"141\":1}}],[\"统一配置管理\",{\"0\":{\"111\":1}}],[\"统一日志处理等\",{\"1\":{\"104\":1}}],[\"统一功能处理\",{\"1\":{\"95\":1}}],[\"那就需要配置热点参数限流的高级选项了\",{\"1\":{\"148\":1}}],[\"那什么叫做预期等待时长呢\",{\"1\":{\"146\":1}}],[\"那是因为sentinel在统计请求的时候\",{\"1\":{\"139\":1}}],[\"那么就会调研resize\",{\"1\":{\"219\":1}}],[\"那么在同一个索引的位置上的元素小于6\",{\"1\":{\"213\":1}}],[\"那么\",{\"1\":{\"146\":1}}],[\"那么初始阈值就是\",{\"1\":{\"145\":1}}],[\"那么哪一个配置的优先级较高呢\",{\"1\":{\"119\":1}}],[\"那么此时直接返回异常信息就并不是特别的合理\",{\"1\":{\"92\":1}}],[\"那么此时需要向spring容器中注册一个bean\",{\"1\":{\"83\":1}}],[\"那么此时在进行远程调用的时候\",{\"1\":{\"76\":1}}],[\"那么此时就会直接抛出sockettimeoutexception\",{\"1\":{\"92\":1}}],[\"那么此时就需要去构建服务集群\",{\"1\":{\"69\":1}}],[\"那么此时就可以根据服务的名称从注册中心获取服务的ip地址和端口号了\",{\"1\":{\"64\":1}}],[\"那么此时服务消费方就需要修改代码\",{\"1\":{\"55\":1}}],[\"成功比例越来越高\",{\"1\":{\"145\":1}}],[\"成功的只有3个\",{\"1\":{\"145\":1}}],[\"成功的请求每次只有5个\",{\"1\":{\"139\":1}}],[\"成为基础技术模块\",{\"1\":{\"131\":1}}],[\"点击左侧菜单中热点规则菜单\",{\"1\":{\"149\":1}}],[\"点击资源中的热点按钮\",{\"1\":{\"148\":1}}],[\"点击users资源后面的流控按钮\",{\"1\":{\"143\":1}}],[\"点击高级选项\",{\"1\":{\"141\":1}}],[\"点击查看结果树\",{\"1\":{\"139\":1}}],[\"点击编辑\",{\"1\":{\"72\":1}}],[\"选择排序\",{\"1\":{\"189\":1}}],[\"选择\",{\"1\":{\"142\":1,\"143\":1,\"145\":1,\"149\":1}}],[\"选择流控入门\",{\"1\":{\"139\":1}}],[\"选中流控入门\",{\"1\":{\"139\":1}}],[\"选项全局设置\",{\"1\":{\"27\":1}}],[\"模拟并发请求\",{\"1\":{\"139\":1}}],[\"快速排序\",{\"1\":{\"189\":1}}],[\"快速失败\",{\"1\":{\"144\":1}}],[\"快速入门测试的就是直接模式\",{\"1\":{\"141\":1}}],[\"快速入门\",{\"0\":{\"139\":1}}],[\"快速生成getter和setter方法\",{\"1\":{\"53\":1,\"93\":1}}],[\"授权\",{\"1\":{\"138\":1}}],[\"热点参数限流规则\",{\"1\":{\"149\":1}}],[\"热点参数限流对默认的spring\",{\"1\":{\"149\":1}}],[\"热点参数限流会根据参数值分别统计qps\",{\"1\":{\"148\":1}}],[\"热点参数限流\",{\"0\":{\"147\":1},\"1\":{\"138\":1,\"149\":1}}],[\"热点\",{\"1\":{\"138\":1}}],[\"降级熔断\",{\"1\":{\"138\":1}}],[\"降级\",{\"1\":{\"138\":1}}],[\"流控效果是指请求达到流控阈值时应该采取的措施\",{\"1\":{\"144\":1}}],[\"流控效果\",{\"0\":{\"144\":1},\"1\":{\"145\":1}}],[\"流控模式简介\",{\"0\":{\"141\":1}}],[\"流控模式\",{\"0\":{\"140\":1},\"1\":{\"142\":1,\"143\":1}}],[\"流控\",{\"1\":{\"138\":2}}],[\"流量控制原理图\",{\"1\":{\"127\":1}}],[\"流量控制\",{\"0\":{\"127\":1,\"137\":1},\"1\":{\"127\":1,\"138\":1}}],[\"流量控制等有着非常重要的作用\",{\"1\":{\"100\":1}}],[\"流量监控\",{\"1\":{\"100\":1,\"104\":1}}],[\"资源添加注解\",{\"1\":{\"149\":1}}],[\"资源\",{\"1\":{\"138\":1}}],[\"资源浪费的时间就越长\",{\"1\":{\"91\":1}}],[\"簇点链路中被监控的每一个接口就是一个资源\",{\"1\":{\"138\":1}}],[\"簇点链路\",{\"1\":{\"138\":1}}],[\"yaml文件\",{\"1\":{\"136\":1}}],[\"yml\",{\"1\":{\"114\":2,\"119\":1}}],[\"yml配置文件中编写基础配置和路由规则\",{\"1\":{\"101\":1}}],[\"yml文件中配置redis的连接信息\",{\"1\":{\"161\":1}}],[\"yml文件中的sentinel配置\",{\"1\":{\"143\":1}}],[\"yml文件中和nacos配置中心中都定义了相同的配置内容\",{\"1\":{\"119\":1}}],[\"yml文件中添加如下配置\",{\"1\":{\"63\":1}}],[\"yml文件\",{\"1\":{\"53\":1,\"70\":1,\"71\":1,\"76\":1,\"106\":1}}],[\"整合sentinel\",{\"0\":{\"136\":1}}],[\"看不到该服务信息\",{\"1\":{\"135\":1}}],[\"看到如下的注册信息\",{\"1\":{\"63\":1}}],[\"另外\",{\"1\":{\"135\":1}}],[\"另一个是访问\",{\"1\":{\"143\":1}}],[\"另一方可以在配置变更时\",{\"1\":{\"111\":1}}],[\"另一些较差\",{\"1\":{\"72\":1}}],[\"发现一片空白\",{\"1\":{\"135\":1}}],[\"发起远程调用\",{\"1\":{\"54\":1,\"65\":1}}],[\"登录后\",{\"1\":{\"135\":1}}],[\"登录校验等\",{\"1\":{\"95\":1}}],[\"访问和操作数据的方法\",{\"1\":{\"180\":1}}],[\"访问该接口\",{\"1\":{\"149\":1}}],[\"访问\",{\"1\":{\"143\":3,\"148\":1}}],[\"访问对应的端点\",{\"1\":{\"142\":1}}],[\"访问b时候超过阈值\",{\"1\":{\"142\":1}}],[\"访问spzx\",{\"1\":{\"136\":1}}],[\"访问sentinel\",{\"0\":{\"135\":1}}],[\"访问http\",{\"1\":{\"101\":1,\"135\":1,\"136\":1}}],[\"密码\",{\"1\":{\"134\":1}}],[\"账户\",{\"1\":{\"134\":1}}],[\"下一个节点对象\",{\"1\":{\"217\":1}}],[\"下载地址\",{\"1\":{\"139\":1}}],[\"下载完毕以后就会得到一个jar包\",{\"1\":{\"133\":1}}],[\"下载sentinel控制台\",{\"0\":{\"133\":1}}],[\"下面\",{\"1\":{\"101\":1}}],[\"下面以日志为例来演示如何自定义配置\",{\"1\":{\"88\":1}}],[\"具有的特征\",{\"1\":{\"131\":1}}],[\"具体的使用方式如下\",{\"1\":{\"164\":1}}],[\"具体就是通过cachemanager接口来统一不同的缓存技术\",{\"1\":{\"159\":1}}],[\"具体\",{\"1\":{\"108\":1}}],[\"具体步骤\",{\"1\":{\"92\":1,\"161\":1}}],[\"等于\",{\"1\":{\"213\":1}}],[\"等待时间\",{\"1\":{\"146\":1}}],[\"等应用容器\",{\"1\":{\"131\":1}}],[\"等框架也有较好的支持\",{\"1\":{\"131\":1}}],[\"打印\",{\"1\":{\"205\":2}}],[\"打开课程资料中所提供的spring\",{\"1\":{\"161\":1}}],[\"打开浏览器\",{\"1\":{\"136\":1}}],[\"打开浏览器访问nacos的所提供的后端管理界面\",{\"1\":{\"61\":1}}],[\"打包后可以直接运行\",{\"1\":{\"131\":1}}],[\"能够运行于所有\",{\"1\":{\"131\":1}}],[\"库\",{\"1\":{\"131\":1}}],[\"继续朝着云原生方向演进\",{\"1\":{\"131\":1}}],[\"版本\",{\"1\":{\"131\":1}}],[\"场景也推出了\",{\"1\":{\"131\":1}}],[\"场景不多\",{\"1\":{\"72\":1}}],[\"原生版本\",{\"1\":{\"131\":1}}],[\"原生组件\",{\"1\":{\"49\":1}}],[\"推出\",{\"1\":{\"131\":2}}],[\"朝着多语言扩展的方向不断探索\",{\"1\":{\"131\":1}}],[\"覆盖了所有的核心场景\",{\"1\":{\"131\":1}}],[\"诞生\",{\"1\":{\"131\":1}}],[\"年\",{\"1\":{\"131\":5}}],[\"随着程序执行次数增多\",{\"1\":{\"192\":1}}],[\"随着微服务的流行\",{\"1\":{\"131\":1}}],[\"随着时间推移\",{\"1\":{\"145\":1}}],[\"随着时间推迟\",{\"1\":{\"49\":1}}],[\"随着时间的不断推移服务a的系统资源会被线程耗尽\",{\"1\":{\"122\":1}}],[\"zh\",{\"1\":{\"131\":1}}],[\"zoneddatetime\",{\"1\":{\"102\":4}}],[\"zoom\",{\"1\":{\"27\":1}}],[\"控制台\",{\"1\":{\"131\":2}}],[\"核心库\",{\"1\":{\"131\":2}}],[\"核心源码分析\",{\"1\":{\"109\":1}}],[\"核心源码如下所示\",{\"1\":{\"81\":2}}],[\"临界值\",{\"1\":{\"130\":1}}],[\"临时实例\",{\"1\":{\"77\":1}}],[\"阈值会动态变化\",{\"1\":{\"145\":1}}],[\"阈值一般是一个微服务能承担的最大qps\",{\"1\":{\"145\":1}}],[\"阈值\",{\"0\":{\"130\":1}}],[\"衡量服务器的吞吐量\",{\"1\":{\"129\":1}}],[\"query进入\",{\"1\":{\"143\":1}}],[\"query进入到users的请求\",{\"1\":{\"143\":1}}],[\"queryusers\",{\"1\":{\"143\":4}}],[\"query\",{\"0\":{\"129\":1},\"1\":{\"143\":6}}],[\"querybyid\",{\"1\":{\"86\":2}}],[\"qps1\",{\"1\":{\"149\":1}}],[\"qps都限定为5\",{\"1\":{\"148\":1}}],[\"qps非常平滑\",{\"1\":{\"146\":1}}],[\"qps会变的很平滑\",{\"1\":{\"146\":1}}],[\"qps为15\",{\"1\":{\"146\":1}}],[\"qps为10\",{\"1\":{\"145\":1}}],[\"qps为4\",{\"1\":{\"143\":1}}],[\"qps阈值为2\",{\"1\":{\"143\":1}}],[\"qps<5右键运行\",{\"1\":{\"139\":1}}],[\"qps是10\",{\"1\":{\"139\":1}}],[\"qps不能超过\",{\"1\":{\"139\":1}}],[\"qps\",{\"0\":{\"129\":1},\"1\":{\"146\":1}}],[\"防止宕机\",{\"1\":{\"128\":1}}],[\"防止长时间等待\",{\"1\":{\"91\":1}}],[\"立马给用户进行返回\",{\"1\":{\"126\":1}}],[\"触发阈值时\",{\"1\":{\"141\":2,\"142\":1}}],[\"触发阈值时对当前资源直接限流\",{\"1\":{\"141\":1}}],[\"触发熔断了以后\",{\"1\":{\"126\":1}}],[\"触发超时以后\",{\"1\":{\"92\":1}}],[\"形成熔断\",{\"1\":{\"126\":1}}],[\"认为服务d有导致雪崩的风险\",{\"1\":{\"126\":1}}],[\"超出数组边界范围\",{\"1\":{\"205\":1}}],[\"超出则被限流\",{\"1\":{\"143\":1}}],[\"超过边界值\",{\"1\":{\"206\":1}}],[\"超过了我们设定的阈值2\",{\"1\":{\"143\":1}}],[\"超过了我们设定的阈值\",{\"1\":{\"142\":1}}],[\"超过了5\",{\"1\":{\"139\":1}}],[\"超过五秒之后\",{\"1\":{\"126\":1}}],[\"超时时长设置为5s\",{\"1\":{\"146\":1}}],[\"超时时间越长\",{\"1\":{\"91\":1}}],[\"超时处理原理\",{\"1\":{\"124\":1}}],[\"超时处理\",{\"0\":{\"124\":1},\"1\":{\"124\":1}}],[\"超时机制可以防止用户长时间等待无响应的情况发生\",{\"1\":{\"91\":1}}],[\"超时机制可以帮助及时释放占用的资源\",{\"1\":{\"91\":1}}],[\"超时机制的意义\",{\"1\":{\"91\":1}}],[\"超时机制概述\",{\"1\":{\"91\":1}}],[\"超时配置\",{\"0\":{\"91\":1}}],[\"提高很高的数据\",{\"1\":{\"126\":1}}],[\"提供更好的用户体验\",{\"1\":{\"91\":1}}],[\"提供了nacos注册中心\",{\"1\":{\"57\":1}}],[\"十次调用中有五次是调用失败\",{\"1\":{\"126\":1}}],[\"制定一个规则\",{\"1\":{\"126\":1}}],[\"都会遵循8421规则去初始化列表容量\",{\"1\":{\"216\":1}}],[\"都可以在一次计算后找到目标\",{\"1\":{\"193\":1}}],[\"都只会发送兜底数据\",{\"1\":{\"126\":1}}],[\"都是用\",{\"1\":{\"194\":1}}],[\"都是将feign的接口抽取到一个独立的模块中\",{\"1\":{\"93\":1}}],[\"都是需要去定义一个feign的接口\",{\"1\":{\"93\":1}}],[\"异常比例如下所示\",{\"1\":{\"126\":1}}],[\"断路器会统计访问某个服务的请求数量\",{\"1\":{\"126\":1}}],[\"断言工厂\",{\"1\":{\"102\":1}}],[\"由于链表中的节点不是连续存储的\",{\"1\":{\"246\":1}}],[\"由于数组的内存连续性\",{\"1\":{\"200\":1}}],[\"由于目前内存便宜\",{\"1\":{\"194\":1}}],[\"由定点和边组成\",{\"1\":{\"183\":1}}],[\"由断路器统计业务执行的异常比例\",{\"1\":{\"126\":1}}],[\"由网飞公司开发\",{\"1\":{\"49\":1}}],[\"熔断等都是针对簇点链路中的资源来设置的\",{\"1\":{\"138\":1}}],[\"熔断降级\",{\"1\":{\"131\":1}}],[\"熔断五秒\",{\"1\":{\"126\":1}}],[\"熔断需要设置时长\",{\"1\":{\"126\":1}}],[\"熔断不可以无限\",{\"1\":{\"126\":1}}],[\"熔断是在降级的基础上发生的\",{\"1\":{\"126\":1}}],[\"熔断是在降级的基础之上发生的\",{\"1\":{\"126\":1}}],[\"熔断处理\",{\"0\":{\"126\":1},\"1\":{\"126\":1}}],[\"电压过高会进行熔断\",{\"1\":{\"126\":1}}],[\"常用方法\",{\"1\":{\"211\":1}}],[\"常用组件\",{\"1\":{\"49\":1}}],[\"常见时间复杂度的\",{\"1\":{\"194\":1}}],[\"常见实现策略算法\",{\"0\":{\"191\":1}}],[\"常见查找算法\",{\"0\":{\"190\":1}}],[\"常见排序算法\",{\"0\":{\"189\":1}}],[\"常见搜索算法\",{\"0\":{\"188\":1}}],[\"常见算法分类\",{\"0\":{\"187\":1}}],[\"常见的是以下的几个\",{\"1\":{\"160\":1}}],[\"常见的隔离方式\",{\"1\":{\"125\":1}}],[\"于此类似\",{\"1\":{\"125\":1}}],[\"避免影响\",{\"1\":{\"142\":1}}],[\"避免雪崩\",{\"1\":{\"127\":1}}],[\"避免因瞬间高并发流量而导致服务故障\",{\"1\":{\"127\":1}}],[\"避免服务因流量的突增而故障\",{\"1\":{\"127\":1}}],[\"避免整个船体都被淹没\",{\"1\":{\"125\":1}}],[\"避免资源浪费\",{\"1\":{\"91\":1}}],[\"船舱都会被隔板分离为多个独立空间\",{\"1\":{\"125\":1}}],[\"隔离处理\",{\"0\":{\"125\":1},\"1\":{\"125\":1}}],[\"称为\",{\"1\":{\"124\":1}}],[\"设定超时时间\",{\"1\":{\"124\":1}}],[\"设置阈值1\",{\"1\":{\"142\":1}}],[\"设置等待时间\",{\"1\":{\"127\":1}}],[\"设置响应状态码\",{\"1\":{\"108\":1}}],[\"设置防止如下所示\",{\"1\":{\"91\":1}}],[\"设置请求的超时时间\",{\"1\":{\"91\":1}}],[\"同时用户要查询订单\",{\"1\":{\"142\":1}}],[\"同时对\",{\"1\":{\"131\":1}}],[\"同时针对\",{\"1\":{\"131\":1}}],[\"同理就会导致其他的服务也不能进行访问了\",{\"1\":{\"122\":1}}],[\"同样可以做配置管理来使用\",{\"1\":{\"110\":1}}],[\"最好在去除元素对应的项设为null\",{\"1\":{\"234\":1}}],[\"最后一个元素是array\",{\"1\":{\"197\":1}}],[\"最后显示\",{\"1\":{\"25\":1}}],[\"最低的时空复杂度\",{\"1\":{\"193\":1}}],[\"最大qps为10\",{\"1\":{\"145\":1,\"146\":1}}],[\"最终经过tablesizefor这个方法计算之后\",{\"1\":{\"216\":1}}],[\"最终的目的\",{\"0\":{\"128\":1}}],[\"最终导致服务a出现了问题\",{\"1\":{\"122\":1}}],[\"雪崩问题虽然有四种方案\",{\"1\":{\"137\":1}}],[\"雪崩原理\",{\"1\":{\"122\":1}}],[\"雪崩效应\",{\"0\":{\"122\":1}}],[\"先来的肯定要排到前面\",{\"1\":{\"237\":1}}],[\"先算哈希值\",{\"1\":{\"213\":1}}],[\"先写接口再写实现类\",{\"1\":{\"207\":1}}],[\"先获取要删除的索引对应的元素\",{\"1\":{\"205\":1}}],[\"先导入的配置\",{\"1\":{\"119\":1}}],[\"先声明一个类\",{\"1\":{\"90\":1}}],[\"后来的只能排在队尾\",{\"1\":{\"237\":1}}],[\"后面的value将前面的value覆盖掉\",{\"1\":{\"213\":1}}],[\"后面考虑扩容问题\",{\"1\":{\"205\":1}}],[\"后面跟服务名称\",{\"1\":{\"101\":1}}],[\"后\",{\"1\":{\"145\":1}}],[\"后导入的配置\",{\"1\":{\"119\":1}}],[\"方法进行数组的扩容\",{\"1\":{\"219\":1}}],[\"方法中进行node对象数组的判断\",{\"1\":{\"219\":1}}],[\"方法\",{\"1\":{\"218\":1}}],[\"方法计算哈希表的初始化容量\",{\"1\":{\"215\":1}}],[\"方法返回\",{\"1\":{\"205\":1}}],[\"方法getqueryparams\",{\"1\":{\"108\":1}}],[\"方式二\",{\"1\":{\"118\":1}}],[\"方式一\",{\"1\":{\"118\":1}}],[\"也是有可能存储在同一个数组索引下\",{\"1\":{\"221\":1}}],[\"也是默认的模式\",{\"1\":{\"141\":1}}],[\"也叫做哈希碰撞\",{\"1\":{\"213\":1}}],[\"也存\",{\"1\":{\"213\":1}}],[\"也往缓存中缓存一份数据\",{\"1\":{\"163\":1}}],[\"也就是乘以2\",{\"1\":{\"220\":1}}],[\"也就是说数组的所有元素类型都是相同的\",{\"1\":{\"197\":1}}],[\"也就是耗时与输入数据大小无关\",{\"1\":{\"193\":1}}],[\"也就是使用user的name属性作为key\",{\"1\":{\"163\":1}}],[\"也就是使用user的id属性作为key\",{\"1\":{\"163\":1}}],[\"也就是3\",{\"1\":{\"145\":1}}],[\"也就是controller中的方法\",{\"1\":{\"138\":1}}],[\"也就是配置热更新\",{\"1\":{\"118\":1}}],[\"也因此积累了大量的流量归整场景以及生产实践\",{\"1\":{\"131\":1}}],[\"也可以通过实体类\",{\"1\":{\"117\":1}}],[\"也可以通过在特定幻灯片添加\",{\"1\":{\"27\":1}}],[\"也可以基于java代码来修改日志级别\",{\"1\":{\"90\":1}}],[\"也可以针对所有服务\",{\"1\":{\"89\":1}}],[\"也可以叫永久实例\",{\"1\":{\"77\":1}}],[\"配合\",{\"1\":{\"117\":1,\"118\":1}}],[\"配置序列化\",{\"1\":{\"161\":1,\"165\":1}}],[\"配置redis的key的序列化器\",{\"1\":{\"161\":1,\"165\":1}}],[\"配置介绍\",{\"0\":{\"148\":1}}],[\"配置流控规则\",{\"1\":{\"142\":1,\"145\":1}}],[\"配置方式\",{\"1\":{\"142\":1,\"143\":1,\"148\":1}}],[\"配置sentinel控制台地址\",{\"1\":{\"136\":1}}],[\"配置控制台\",{\"1\":{\"136\":1}}],[\"配置项\",{\"1\":{\"134\":1}}],[\"配置优先级\",{\"0\":{\"119\":1}}],[\"配置热更新\",{\"0\":{\"118\":1}}],[\"配置到配置中心中\",{\"1\":{\"110\":1}}],[\"配置路由基本的过滤器\",{\"1\":{\"106\":1}}],[\"配置路由信息\",{\"1\":{\"101\":1}}],[\"配置文件中配置\",{\"1\":{\"114\":1}}],[\"配置文件\",{\"1\":{\"101\":1}}],[\"配置文件管理\",{\"1\":{\"46\":1}}],[\"配置自定义重试器\",{\"1\":{\"92\":1}}],[\"配置重试器\",{\"1\":{\"92\":1}}],[\"配置负载均衡算法的使用者\",{\"1\":{\"83\":1}}],[\"配置负载均衡效果\",{\"1\":{\"69\":1}}],[\"配置该实例为非临时实例\",{\"1\":{\"77\":1}}],[\"配置一个服务实例为永久实例\",{\"1\":{\"77\":1}}],[\"配置服务实例所属名称空间\",{\"1\":{\"76\":1}}],[\"配置服务所属集群\",{\"1\":{\"70\":1,\"71\":1}}],[\"配置服务端口号\",{\"1\":{\"53\":1}}],[\"配置order模块远程访问的集群是什么\",{\"1\":{\"69\":1}}],[\"配置所属区域\",{\"1\":{\"69\":1}}],[\"配置nacos注册中心的地址\",{\"1\":{\"63\":1,\"71\":1,\"76\":1}}],[\"配置mybatis的相关信息\",{\"1\":{\"53\":1}}],[\"配置数据库的连接信息\",{\"1\":{\"53\":1,\"114\":1}}],[\"配置中心\",{\"1\":{\"49\":1,\"110\":1}}],[\"$\",{\"1\":{\"116\":1,\"117\":1}}],[\"读取自定义配置\",{\"0\":{\"115\":1}}],[\"读取数据的超时时间设置为2s\",{\"1\":{\"91\":1}}],[\"地址并引入服务配置\",{\"1\":{\"114\":1}}],[\"填写配置信息\",{\"1\":{\"113\":1}}],[\"及时通知微服务\",{\"1\":{\"111\":1}}],[\"相比于数组\",{\"1\":{\"246\":1}}],[\"相当图书的目录\",{\"1\":{\"200\":1}}],[\"相邻做比较\",{\"1\":{\"189\":1}}],[\"相关概念\",{\"0\":{\"138\":1}}],[\"相同配置部分进行抽取\",{\"1\":{\"111\":1}}],[\"相互独立\",{\"1\":{\"46\":1}}],[\"组织和存储方式\",{\"1\":{\"180\":1}}],[\"组织基于\",{\"1\":{\"139\":1}}],[\"组织过滤器链\",{\"1\":{\"109\":1}}],[\"组件\",{\"1\":{\"56\":1}}],[\"中间件\",{\"0\":{\"271\":1}}],[\"中间的元素我们操作不了\",{\"1\":{\"237\":1}}],[\"中删\",{\"1\":{\"205\":1}}],[\"中增\",{\"1\":{\"205\":1}}],[\"中\",{\"1\":{\"109\":1}}],[\"合并到一个过滤器链\",{\"1\":{\"109\":1}}],[\"合理的做法\",{\"1\":{\"92\":1}}],[\"参数分别为\",{\"1\":{\"149\":1}}],[\"参数值是value\",{\"1\":{\"108\":1}}],[\"参数名是可以\",{\"1\":{\"108\":1}}],[\"参数中chain\",{\"1\":{\"108\":1}}],[\"参数中exchage\",{\"1\":{\"108\":1}}],[\"参数传递不太方便\",{\"1\":{\"85\":1}}],[\"判断条件\",{\"0\":{\"231\":1,\"239\":1}}],[\"判断为一个对象\",{\"1\":{\"222\":1}}],[\"判断是否超过qps阈值\",{\"1\":{\"148\":2}}],[\"判断是否超过阈值\",{\"1\":{\"143\":1}}],[\"判断参数是否是username\",{\"1\":{\"108\":1}}],[\"判断请求路径中第一个参数是否是username\",{\"1\":{\"108\":1}}],[\"判断请求的参数是否满足下面条件\",{\"1\":{\"108\":1}}],[\"类似于保险丝\",{\"1\":{\"126\":1}}],[\"类交给spring进行管理\",{\"1\":{\"108\":1}}],[\"类型的过滤器中可以做响应内容\",{\"1\":{\"100\":1}}],[\"类型的过滤器可以做参数校验\",{\"1\":{\"100\":1}}],[\"类型\",{\"1\":{\"88\":1}}],[\"否则拦截\",{\"1\":{\"108\":1}}],[\"区别在于gatewayfilter通过配置定义\",{\"1\":{\"108\":1}}],[\"与\",{\"1\":{\"194\":1}}],[\"与前面的过滤器合并后根据order排序\",{\"1\":{\"109\":1}}],[\"与gatewayfilter的作用一样\",{\"1\":{\"108\":1}}],[\"与语言和技术无关\",{\"1\":{\"46\":1}}],[\"格式如下\",{\"1\":{\"107\":1}}],[\"格式使用数学公式\",{\"1\":{\"9\":1}}],[\"全部都通过了\",{\"1\":{\"146\":1}}],[\"全局过滤器的作用也是处理一切进入网关的请求和微服务响应\",{\"1\":{\"108\":1}}],[\"全局过滤器\",{\"0\":{\"108\":1},\"1\":{\"105\":1}}],[\"全屏模式\",{\"0\":{\"36\":1}}],[\"限制业务访问的qps\",{\"1\":{\"127\":1}}],[\"限制请求的流量\",{\"1\":{\"105\":1}}],[\"限流是一种预防措施\",{\"1\":{\"127\":1}}],[\"限流\",{\"1\":{\"95\":1}}],[\"移除请求中的一个请求头\",{\"1\":{\"105\":1}}],[\"名称\",{\"1\":{\"105\":1}}],[\"名为public\",{\"1\":{\"74\":1}}],[\"官网地址\",{\"1\":{\"105\":1,\"131\":1}}],[\"官方地址\",{\"1\":{\"85\":1}}],[\"内部类node中具有4个成员变量\",{\"1\":{\"217\":1}}],[\"内部类分析\",{\"0\":{\"217\":1}}],[\"内存是由许多存储单元组成\",{\"1\":{\"180\":1}}],[\"内置过滤器\",{\"0\":{\"105\":1}}],[\"内容不一样的时候\",{\"1\":{\"213\":1}}],[\"内容\",{\"1\":{\"46\":1}}],[\"总结\",{\"1\":{\"102\":1}}],[\"系统负载保护等多个维度保护服务的稳定性\",{\"1\":{\"131\":1}}],[\"系统时间在2023\",{\"1\":{\"102\":1}}],[\"系统的稳定性就越差\",{\"1\":{\"91\":1}}],[\"框架底层会自动读取配置文件中的内容\",{\"1\":{\"102\":1}}],[\"框架底层调用该方法得到一个重试器\",{\"1\":{\"92\":1}}],[\"底层会创建长度为16的数组\",{\"1\":{\"213\":1}}],[\"底层源码分析\",{\"0\":{\"212\":1}}],[\"底层使用\",{\"1\":{\"180\":1}}],[\"底层可以切换不同的cache实现\",{\"1\":{\"159\":1}}],[\"底层原理\",{\"1\":{\"102\":1}}],[\"底层是过滤器\",{\"1\":{\"99\":1}}],[\"怎么就可以实现路由呢\",{\"1\":{\"102\":1}}],[\"思考问题\",{\"1\":{\"102\":1,\"119\":1}}],[\"`规则\",{\"1\":{\"101\":1}}],[\"符合`\",{\"1\":{\"101\":1}}],[\"路径匹配\",{\"1\":{\"101\":2}}],[\"路由过滤器的顺序执行\",{\"1\":{\"109\":1}}],[\"路由过滤器和默认过滤器会按照order的值进行排序\",{\"1\":{\"109\":1}}],[\"路由过滤器\",{\"0\":{\"106\":1},\"1\":{\"105\":1}}],[\"路由断言工厂\",{\"0\":{\"102\":1}}],[\"路由的目标地址\",{\"1\":{\"101\":1}}],[\"路由id\",{\"1\":{\"101\":1}}],[\"只为了在写代码的时候进行更加基础的识别\",{\"1\":{\"206\":1}}],[\"只需要导入spring\",{\"1\":{\"160\":1}}],[\"只需要简单地加一个注解\",{\"1\":{\"159\":1}}],[\"只需要创建自定义的\",{\"1\":{\"88\":1}}],[\"只统计从\",{\"1\":{\"143\":1}}],[\"只针对从指定链路访问到本资源的请求做统计\",{\"1\":{\"143\":1}}],[\"只针对当前路由有效\",{\"1\":{\"105\":1}}],[\"只会导致部分空间进入\",{\"1\":{\"125\":1}}],[\"只要唯一即可\",{\"1\":{\"101\":1}}],[\"引入sentinel依赖\",{\"1\":{\"136\":1}}],[\"引入spring\",{\"1\":{\"114\":1}}],[\"引入如下依赖\",{\"1\":{\"101\":1}}],[\"引入依赖\",{\"1\":{\"101\":1}}],[\"响应头的修改\",{\"1\":{\"100\":1}}],[\"响应结果的解析器\",{\"1\":{\"88\":1}}],[\"协议转换等\",{\"1\":{\"100\":1}}],[\"权限控制\",{\"1\":{\"104\":1}}],[\"权限校验\",{\"1\":{\"100\":1}}],[\"权重取值范围\",{\"1\":{\"72\":1}}],[\"权重越大则访问频率越高\",{\"1\":{\"72\":1}}],[\"权重值越高\",{\"1\":{\"72\":1}}],[\"权重配置\",{\"0\":{\"72\":1}}],[\"执行顺序越靠前\",{\"1\":{\"109\":1}}],[\"执行业务逻辑\",{\"1\":{\"100\":1}}],[\"执行命令\",{\"1\":{\"61\":1,\"134\":1}}],[\"匹配关系\",{\"0\":{\"98\":1}}],[\"网关\",{\"1\":{\"101\":1}}],[\"网关有很多过滤器\",{\"1\":{\"99\":1}}],[\"网关有多个过滤器\",{\"1\":{\"95\":1}}],[\"网关架构原理\",{\"1\":{\"95\":1}}],[\"叫做过滤链\",{\"1\":{\"95\":1}}],[\"跨域\",{\"1\":{\"95\":1}}],[\"黑名单\",{\"1\":{\"95\":1}}],[\"拦截访问该业务的一切请求\",{\"1\":{\"126\":1}}],[\"拦截请求\",{\"1\":{\"108\":1}}],[\"拦截下来\",{\"1\":{\"95\":1}}],[\"拦截了用户的httprequest请求\",{\"1\":{\"81\":1}}],[\"对象游离解决方案\",{\"1\":{\"234\":1}}],[\"对象游离\",{\"0\":{\"234\":1}}],[\"对象的equals方法返回true\",{\"1\":{\"222\":1}}],[\"对象的哈希值\",{\"1\":{\"217\":1,\"221\":1}}],[\"对数课本内容\",{\"1\":{\"193\":1}}],[\"对数函数\",{\"1\":{\"193\":2}}],[\"对数函数vs指数函数复习\",{\"0\":{\"193\":1}}],[\"对hot这个资源的0号参数\",{\"1\":{\"148\":1}}],[\"对于服务器来说是更友好的\",{\"1\":{\"146\":1}}],[\"对超出阈值的请求同样是拒绝并抛出异常\",{\"1\":{\"144\":1}}],[\"对高优先级的资源的流量进行统计\",{\"1\":{\"142\":1}}],[\"对哪个端点限流\",{\"1\":{\"142\":1}}],[\"对\",{\"1\":{\"142\":2}}],[\"对a进行限流\",{\"1\":{\"142\":1}}],[\"对指定链路限流\",{\"1\":{\"141\":1}}],[\"对当前资源限流\",{\"1\":{\"141\":1,\"142\":1}}],[\"对请求进行拦截\",{\"1\":{\"95\":1}}],[\"对其他功能产生影响\",{\"1\":{\"45\":1}}],[\"过期时间600秒\",{\"1\":{\"161\":1,\"165\":1}}],[\"过滤器执行顺序\",{\"0\":{\"109\":1}}],[\"过滤器简介\",{\"0\":{\"104\":1}}],[\"过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前\",{\"1\":{\"100\":1}}],[\"过滤器链\",{\"1\":{\"99\":1}}],[\"过滤器\",{\"1\":{\"95\":1,\"104\":1}}],[\"过渡动画\",{\"0\":{\"29\":1}}],[\"75\",{\"1\":{\"213\":1}}],[\"75f\",{\"1\":{\"213\":1,\"214\":2}}],[\"789\",{\"1\":{\"107\":1}}],[\"7\",{\"0\":{\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"114\":1,\"115\":1,\"118\":1,\"119\":1,\"220\":1},\"1\":{\"93\":1,\"143\":1,\"161\":1,\"205\":1}}],[\"7nacos高级特性\",{\"0\":{\"77\":1}}],[\"面向对象\",{\"1\":{\"93\":1}}],[\"面向服务\",{\"1\":{\"46\":1}}],[\"供其他的模块进行使用\",{\"1\":{\"93\":1}}],[\"是最大容量\",{\"1\":{\"215\":1}}],[\"是否满了\",{\"1\":{\"205\":1}}],[\"是否为空\",{\"1\":{\"205\":1}}],[\"是否需要进行重试取决于该方法是否抛出异常\",{\"1\":{\"92\":1}}],[\"是比线性还要低的时间复杂度\",{\"1\":{\"193\":1}}],[\"是应对服务冷启动的一种方案\",{\"1\":{\"145\":1}}],[\"是默认的处理方式\",{\"1\":{\"144\":1}}],[\"是对不同来源的两个链路做监控\",{\"1\":{\"143\":1}}],[\"是对微服务雪崩问题的预防\",{\"1\":{\"137\":1}}],[\"是\",{\"1\":{\"139\":1}}],[\"是限流的一种\",{\"1\":{\"138\":1}}],[\"是修改nacos中的配置后\",{\"1\":{\"118\":1}}],[\"是springcloud公司研发的\",{\"1\":{\"95\":1}}],[\"是spring\",{\"1\":{\"83\":1}}],[\"定义\",{\"1\":{\"234\":1}}],[\"定义树形\",{\"1\":{\"206\":1}}],[\"定义数组\",{\"1\":{\"197\":1,\"203\":1}}],[\"定义序列化器\",{\"1\":{\"161\":1,\"165\":1}}],[\"定义该过滤器的优先级\",{\"1\":{\"108\":1}}],[\"定义一个实体类\",{\"1\":{\"117\":1}}],[\"定义一个类实现globalfilter接口❓全局过滤器接口\",{\"1\":{\"108\":1}}],[\"定义一个新的模块spzx\",{\"1\":{\"93\":2}}],[\"定义全局过滤器\",{\"1\":{\"108\":1}}],[\"定义两个成员变量来决定重试次数\",{\"1\":{\"92\":1}}],[\"定义属性\",{\"1\":{\"52\":1,\"205\":2}}],[\"自动支持热更新\",{\"1\":{\"118\":1}}],[\"自定义重试器\",{\"1\":{\"92\":1}}],[\"自治\",{\"1\":{\"46\":1}}],[\"让所有的请求按照先后次序进入到一个队列中进行排队\",{\"1\":{\"144\":1,\"146\":1}}],[\"让其产生簇点链路\",{\"1\":{\"142\":1}}],[\"让feign进行重试\",{\"1\":{\"92\":1}}],[\"让resttemplate具有负载均衡的能力\",{\"1\":{\"66\":1,\"83\":1}}],[\"肯定希望得到一个结果\",{\"1\":{\"92\":1}}],[\"尤其针对查询请求\",{\"1\":{\"92\":1}}],[\"重写filter方法\",{\"1\":{\"108\":1}}],[\"重启服务\",{\"1\":{\"142\":1,\"143\":1}}],[\"重启网关\",{\"1\":{\"101\":1}}],[\"重启测试\",{\"1\":{\"101\":1}}],[\"重点配置\",{\"1\":{\"101\":1}}],[\"重试配置\",{\"0\":{\"92\":1}}],[\"重新进行启动\",{\"1\":{\"69\":1}}],[\"建立连接的超时时间设置为2s\",{\"1\":{\"91\":1}}],[\"优先级顺序\",{\"1\":{\"119\":1}}],[\"优先级越高\",{\"1\":{\"109\":1}}],[\"优化过程图解\",{\"1\":{\"93\":1}}],[\"优化用户体验\",{\"1\":{\"91\":1}}],[\"优点\",{\"0\":{\"199\":1,\"245\":1},\"1\":{\"45\":1,\"46\":1}}],[\"从索引+1位置进行左移动\",{\"1\":{\"205\":1}}],[\"从0开始\",{\"1\":{\"197\":1}}],[\"从10开始进行查找\",{\"1\":{\"190\":1}}],[\"从一个较小值逐渐增加到最大阈值\",{\"1\":{\"144\":1,\"145\":1}}],[\"从流量控制\",{\"1\":{\"131\":1}}],[\"从nacos配置中心中获取配置信息进行使用\",{\"1\":{\"114\":1}}],[\"从响应结果中移除有一个响应头\",{\"1\":{\"105\":1}}],[\"从而影响整个系统的吞吐量和响应时间\",{\"1\":{\"91\":1}}],[\"从服务列表中选择一个服务实例对象\",{\"1\":{\"81\":1}}],[\"客户端\",{\"1\":{\"131\":1}}],[\"客户端向spring\",{\"1\":{\"100\":1}}],[\"客户端访问\",{\"1\":{\"95\":1}}],[\"客户端可能会一直等待\",{\"1\":{\"91\":1}}],[\"客户端负载均衡\",{\"1\":{\"79\":1}}],[\"调用的是有参构造\",{\"1\":{\"205\":1}}],[\"调用方法并将方法返回值放到缓存中\",{\"1\":{\"160\":1,\"161\":1}}],[\"调用服务d的服务a的线程就得不到及时的释放\",{\"1\":{\"122\":1}}],[\"调用过滤器链中的filter方法\",{\"1\":{\"109\":1}}],[\"调用优化原理\",{\"1\":{\"93\":1}}],[\"调用时\",{\"1\":{\"91\":1}}],[\"调用http\",{\"1\":{\"54\":1}}],[\"进而避免雪崩\",{\"1\":{\"127\":1}}],[\"进而就可以更改远程调用代码\",{\"1\":{\"64\":1}}],[\"进行覆盖操作\",{\"1\":{\"222\":1}}],[\"进行限流了\",{\"1\":{\"143\":1}}],[\"进行限流\",{\"1\":{\"142\":1}}],[\"进行排序\",{\"1\":{\"109\":1}}],[\"进行测试\",{\"1\":{\"106\":1}}],[\"进行分时放行\",{\"1\":{\"95\":1}}],[\"进行服务间的\",{\"1\":{\"91\":1}}],[\"日志的输出\",{\"1\":{\"100\":1}}],[\"日志输出\",{\"1\":{\"100\":1}}],[\"日志级别为basic\",{\"1\":{\"90\":1}}],[\"日志配置\",{\"0\":{\"88\":1}}],[\"元数据\",{\"1\":{\"89\":1}}],[\"元素可重复\",{\"1\":{\"211\":1}}],[\"元素有序\",{\"1\":{\"211\":1}}],[\"元素产生过渡动画效果\",{\"1\":{\"29\":1}}],[\"元素使其拥有多个动画片段\",{\"1\":{\"23\":1}}],[\"元素上添加属性\",{\"1\":{\"3\":1}}],[\"包含\",{\"1\":{\"205\":1}}],[\"包含三个请求\",{\"1\":{\"149\":1}}],[\"包含四种不同的级别\",{\"1\":{\"88\":1}}],[\"包括三种\",{\"1\":{\"144\":1}}],[\"包括头信息\",{\"1\":{\"89\":1}}],[\"记录所有请求和响应的明细\",{\"1\":{\"89\":1}}],[\"仅记录请求的方法\",{\"1\":{\"89\":1}}],[\"而我们并没有真正的使用他\",{\"1\":{\"234\":1}}],[\"而初始化容量不直接等于我们传递的参数\",{\"1\":{\"215\":1}}],[\"而在实际开发中\",{\"1\":{\"148\":1}}],[\"而热点参数限流是分别统计参数值相同的请求\",{\"1\":{\"148\":1}}],[\"而是可以随时动态的增长或缩小\",{\"1\":{\"245\":1}}],[\"而是第一次add的时候才会创建初始容量为10的空列表\",{\"1\":{\"212\":1}}],[\"而是放入队列\",{\"1\":{\"146\":1}}],[\"而是将多个服务分散的部署到不同的机房中\",{\"1\":{\"69\":1}}],[\"而coldfactor的默认值是3\",{\"1\":{\"145\":1}}],[\"而且很容易出错\",{\"1\":{\"111\":1}}],[\"而globalfilter的逻辑需要自己写代码实现\",{\"1\":{\"108\":1}}],[\"而日志的级别分为四种\",{\"1\":{\"89\":1}}],[\"则直接返回缓存数据\",{\"1\":{\"160\":1,\"161\":1}}],[\"则可以这样配置\",{\"1\":{\"143\":1}}],[\"则可以将过滤器工厂写到default下\",{\"1\":{\"107\":1}}],[\"则把它放到对应的\",{\"1\":{\"90\":1}}],[\"则是针对某个微服务的配置\",{\"1\":{\"89\":1}}],[\"则该实例永远不会被访问\",{\"1\":{\"72\":1}}],[\"支持spring的表达式语言spel语法\",{\"1\":{\"161\":1,\"163\":1,\"164\":1}}],[\"支持两种方式的配置\",{\"1\":{\"88\":1}}],[\"支持的注解格式\",{\"1\":{\"88\":1}}],[\"失败重试机制\",{\"1\":{\"88\":1}}],[\"便于通过http请求发送\",{\"1\":{\"88\":1}}],[\"说明qps被限定在3\",{\"1\":{\"145\":1}}],[\"说明\",{\"1\":{\"88\":1,\"105\":1,\"134\":1,\"160\":1,\"161\":1,\"200\":1}}],[\"作为值得对象\",{\"1\":{\"217\":1}}],[\"作为键的对象\",{\"1\":{\"217\":1}}],[\"作用\",{\"1\":{\"88\":1,\"161\":1,\"163\":1,\"164\":1}}],[\"作者\",{\"1\":{\"1\":1}}],[\"④\",{\"1\":{\"86\":1,\"89\":1}}],[\"③\",{\"1\":{\"86\":1,\"89\":1}}],[\"②\",{\"1\":{\"86\":1,\"89\":1}}],[\"①\",{\"1\":{\"86\":1,\"89\":1}}],[\"比如上面数组的第一个元素是array\",{\"1\":{\"197\":1}}],[\"比如我们声明一个长度为10的数组\",{\"1\":{\"197\":1}}],[\"比如常见的遍历算法\",{\"1\":{\"193\":1}}],[\"比如现在一下子来了12\",{\"1\":{\"146\":1}}],[\"比如用户支付时需要修改订单状态\",{\"1\":{\"142\":1}}],[\"比如服务器的qps是5\",{\"1\":{\"130\":1}}],[\"比如\",{\"1\":{\"86\":1,\"193\":1}}],[\"编写一个函数\",{\"1\":{\"209\":1}}],[\"编写一个简易的随机负载均衡算法\",{\"1\":{\"65\":1}}],[\"编写启动类\",{\"1\":{\"101\":1}}],[\"编写openfeign的客户端\",{\"1\":{\"86\":1}}],[\"开启缓存支持即可\",{\"1\":{\"160\":1}}],[\"开启缓存注解功能\",{\"1\":{\"160\":1}}],[\"开启openfeign的功能支持\",{\"1\":{\"86\":1}}],[\"开发的压力测试工具\",{\"1\":{\"139\":1}}],[\"开发\",{\"1\":{\"131\":1}}],[\"开发环境\",{\"1\":{\"74\":1}}],[\"开源\",{\"1\":{\"131\":1}}],[\"加载因子\",{\"1\":{\"213\":1,\"215\":1}}],[\"加入红黑树的目的是\",{\"1\":{\"213\":1}}],[\"加入fegin的依赖\",{\"1\":{\"93\":1}}],[\"加入如下依赖\",{\"1\":{\"93\":1}}],[\"加入openfeign的依赖\",{\"1\":{\"86\":1}}],[\"加密展示\",{\"1\":{\"41\":1}}],[\"基础函数\",{\"1\":{\"206\":1}}],[\"基础知识\",{\"0\":{\"197\":1,\"227\":1,\"236\":1,\"243\":1}}],[\"基数排序\",{\"1\":{\"189\":1}}],[\"基本步骤如下\",{\"1\":{\"101\":1}}],[\"基本概念\",{\"0\":{\"44\":1}}],[\"基于\",{\"1\":{\"131\":1}}],[\"基于配置文件修改feign的日志级别可以针对单个服务\",{\"1\":{\"89\":1}}],[\"基于配置文件的方式\",{\"0\":{\"89\":1}}],[\"基于nacos和openfeign组件一起使用\",{\"1\":{\"85\":1}}],[\"以2为底8的对数\",{\"1\":{\"193\":1}}],[\"以固定的200ms的间隔执行\",{\"1\":{\"146\":1}}],[\"以解决\",{\"1\":{\"131\":1}}],[\"以流量为切入点\",{\"1\":{\"131\":1}}],[\"以after\",{\"1\":{\"102\":1}}],[\"以提醒用户或采取其他措施\",{\"1\":{\"91\":1}}],[\"以提供可用的服务列表\",{\"1\":{\"83\":1}}],[\"以及所有不在\",{\"1\":{\"10\":1}}],[\"用法如下\",{\"1\":{\"163\":1}}],[\"用户数据删除成功\",{\"1\":{\"164\":1}}],[\"用户数据保存成功\",{\"1\":{\"163\":1}}],[\"用户数据查询成功\",{\"1\":{\"161\":1}}],[\"用户名和密码\",{\"1\":{\"61\":1}}],[\"用于对软件做压力测试\",{\"1\":{\"139\":1}}],[\"用于提供serviceinstance列表的接口\",{\"1\":{\"83\":1}}],[\"用于获取环境属性配置\",{\"1\":{\"83\":1}}],[\"请检查\",{\"1\":{\"206\":1}}],[\"请求阈值初始值是\",{\"1\":{\"145\":1}}],[\"请求的目标是\",{\"1\":{\"142\":1}}],[\"请求的权限控制\",{\"1\":{\"138\":1}}],[\"请求了三次\",{\"1\":{\"126\":1}}],[\"请求超过一定时间没有响应就返回错误信息\",{\"1\":{\"124\":1}}],[\"请求超时的原因有很多种\",{\"1\":{\"92\":1}}],[\"请求路由后\",{\"1\":{\"109\":1}}],[\"请求路径\",{\"1\":{\"86\":1}}],[\"请求进入网关会碰到三类过滤器\",{\"1\":{\"109\":1}}],[\"请求转发到uri\",{\"1\":{\"101\":1}}],[\"请求体\",{\"1\":{\"89\":1}}],[\"请求失败的重试机制\",{\"1\":{\"88\":1}}],[\"请求参数中是否有username\",{\"1\":{\"108\":1}}],[\"请求参数编码\",{\"1\":{\"88\":1}}],[\"请求参数\",{\"1\":{\"86\":1}}],[\"请求方式\",{\"1\":{\"86\":1}}],[\"请求次数\",{\"1\":{\"82\":1}}],[\"请滚动鼠标滚轮进入下一页\",{\"1\":{\"1\":1}}],[\"数组长度\",{\"1\":{\"221\":1}}],[\"数组+链表+红黑树\",{\"1\":{\"213\":1}}],[\"数组已经满了\",{\"1\":{\"206\":1}}],[\"数组为空\",{\"1\":{\"205\":1}}],[\"数组满了\",{\"1\":{\"205\":1}}],[\"数组正反向输出\",{\"1\":{\"203\":1}}],[\"数组原理图\",{\"1\":{\"203\":1}}],[\"数组优缺点\",{\"0\":{\"198\":1}}],[\"数组的下标是从0开始\",{\"1\":{\"197\":1}}],[\"数组的长度\",{\"1\":{\"197\":1}}],[\"数组的大小一旦确定就不能进行修改\",{\"1\":{\"197\":1}}],[\"数组首先需要先进行声明才能使用\",{\"1\":{\"197\":1}}],[\"数组算是最常见也是最简单的一种数据结构\",{\"1\":{\"197\":1}}],[\"数组是具有相同类型的数据的集合\",{\"1\":{\"197\":1}}],[\"数组array的缺点\",{\"1\":{\"200\":1}}],[\"数组array\",{\"0\":{\"196\":1},\"1\":{\"197\":1}}],[\"数组\",{\"1\":{\"180\":1,\"182\":1,\"211\":1}}],[\"数百时\",{\"1\":{\"111\":1}}],[\"数学知识\",{\"1\":{\"82\":1}}],[\"数据元素按照顺序进行排列\",{\"1\":{\"182\":1}}],[\"数据元素的集合\",{\"1\":{\"180\":1}}],[\"数据元素之间的关系以及访问和操作数据的方法\",{\"1\":{\"180\":1}}],[\"数据的组织和存储方式\",{\"1\":{\"180\":1}}],[\"数据结构\",{\"0\":{\"275\":1},\"1\":{\"211\":1}}],[\"数据结构类型\",{\"0\":{\"181\":1},\"1\":{\"184\":1}}],[\"数据结构存储方式\",{\"1\":{\"180\":1}}],[\"数据结构针对的是内存中的数据\",{\"1\":{\"180\":1}}],[\"数据结构是为了高效访问数据而设计出的一种数据的\",{\"1\":{\"180\":1}}],[\"数据结构是什么\",{\"0\":{\"180\":1}}],[\"数据结构概述\",{\"0\":{\"179\":1}}],[\"数据结构与算法总体概述\",{\"0\":{\"178\":1}}],[\"数据封装\",{\"1\":{\"54\":1}}],[\"数据独立\",{\"1\":{\"46\":1}}],[\"轮循算法数学原理\",{\"1\":{\"82\":1}}],[\"轮循算法\",{\"1\":{\"82\":1}}],[\"轮循环效果\",{\"1\":{\"69\":1}}],[\"紧跟着调用了roundrobinloadbalancer\",{\"1\":{\"81\":1}}],[\"和用户请求\",{\"1\":{\"81\":1}}],[\"和动画\",{\"1\":{\"17\":1}}],[\"处理逻辑是固定的\",{\"1\":{\"108\":1}}],[\"处理服务id\",{\"1\":{\"81\":1}}],[\"处于维护状态\",{\"1\":{\"49\":1}}],[\"将对此链表进行遍历\",{\"1\":{\"222\":1}}],[\"将加载因子设置为默认的加载因子\",{\"1\":{\"214\":1}}],[\"将方法返回值\",{\"1\":{\"163\":1}}],[\"将方法的返回值放到缓存中\",{\"1\":{\"160\":1}}],[\"将一条或多条数据从缓存中删除\",{\"1\":{\"160\":1}}],[\"将jar包放到任意非中文目录\",{\"1\":{\"134\":1}}],[\"将故障控制在一定范围\",{\"1\":{\"127\":1}}],[\"将故障控制在一定范围内\",{\"1\":{\"125\":1}}],[\"将错误隔离在可控的范围之内\",{\"1\":{\"125\":1}}],[\"将取路由级别的过滤器和默认过滤器的集合中的元素添加到全局过滤器的集合中\",{\"1\":{\"109\":1}}],[\"将该类纳入到spring容器中\",{\"1\":{\"108\":1}}],[\"将网关在nacos中进行注册\",{\"1\":{\"101\":1}}],[\"将其发送到gateway\",{\"1\":{\"100\":1}}],[\"将其放到启动类的\",{\"1\":{\"90\":1}}],[\"将spzx\",{\"1\":{\"93\":2}}],[\"将userfeginclient\",{\"1\":{\"93\":1}}],[\"将导致资源的浪费和系统的负载增加\",{\"1\":{\"91\":1}}],[\"将会中断该请求并抛出相应的异常\",{\"1\":{\"91\":1}}],[\"将feign包下产生的日志的级别设置为debug\",{\"1\":{\"89\":2}}],[\"将请求参数编码\",{\"1\":{\"88\":1}}],[\"将负载均衡算法应用到指定的服务提供方中\",{\"1\":{\"83\":1}}],[\"将服务提供方的名称传递过去\",{\"1\":{\"80\":1}}],[\"将两个微服务\",{\"1\":{\"63\":1}}],[\"然后测试\",{\"1\":{\"139\":1}}],[\"然后进入controller\",{\"1\":{\"138\":1}}],[\"然后进行强转\",{\"1\":{\"206\":1}}],[\"然后进行放行操作\",{\"1\":{\"108\":1}}],[\"然后进行判断\",{\"1\":{\"102\":1}}],[\"然后再访问sentinel的控制台\",{\"1\":{\"136\":1}}],[\"然后在此索引下tab\",{\"1\":{\"221\":1}}],[\"然后在5秒后逐渐增长到10\",{\"1\":{\"145\":1}}],[\"然后在弹出的表单中\",{\"1\":{\"113\":1}}],[\"然后在gateway\",{\"1\":{\"100\":1}}],[\"然后通过制定的路由工厂将其转换成对应的判断条件\",{\"1\":{\"102\":1}}],[\"然后返回元素\",{\"1\":{\"205\":1}}],[\"然后返回\",{\"1\":{\"100\":1}}],[\"然后声明一个logger\",{\"1\":{\"90\":1}}],[\"然后做了几件事\",{\"1\":{\"81\":1}}],[\"然后发起远程调用\",{\"1\":{\"80\":1}}],[\"然后调用loadbalancerclient中execute方法\",{\"1\":{\"80\":1}}],[\"然后从请求中获取提供方的主机名称\",{\"1\":{\"80\":1}}],[\"然后按照指定的负载均衡算法从服务清单中选择一个服务实例进行访问\",{\"1\":{\"58\":1}}],[\"9\",{\"0\":{\"222\":1},\"1\":{\"105\":1,\"197\":1}}],[\"978038800+08\",{\"1\":{\"102\":1}}],[\"924f\",{\"1\":{\"76\":1}}],[\"9848\",{\"1\":{\"61\":2}}],[\"来表示\",{\"1\":{\"194\":1}}],[\"来表示对应算法的时间复杂度\",{\"1\":{\"193\":1}}],[\"来源于船舱的设计\",{\"1\":{\"125\":1}}],[\"来指定该微服务所属环境\",{\"1\":{\"76\":1}}],[\"来将不同的服务隔离到不同的环境下面\",{\"1\":{\"75\":1}}],[\"给查询所有的分类数据添加查询缓存\",{\"1\":{\"165\":1}}],[\"给spring\",{\"1\":{\"161\":1}}],[\"给usercontroller中的\",{\"1\":{\"149\":1}}],[\"给3这个参数设置例外\",{\"1\":{\"149\":1}}],[\"给2这个参数设置例外\",{\"1\":{\"149\":1}}],[\"给\",{\"1\":{\"139\":1,\"145\":1,\"146\":1,\"149\":1}}],[\"给访问user微服务的所有接口添加truth请求头\",{\"1\":{\"106\":1}}],[\"给所有进入spzx\",{\"1\":{\"106\":1}}],[\"给响应结果中添加一个响应头\",{\"1\":{\"105\":1}}],[\"给当前请求添加一个请求头\",{\"1\":{\"105\":1}}],[\"给微服务添加名称空间的配置\",{\"1\":{\"76\":1}}],[\"给order微服务的application\",{\"1\":{\"71\":1}}],[\"才可以确定具体的微服务实例\",{\"1\":{\"74\":1}}],[\"才访问其它集群\",{\"1\":{\"69\":1}}],[\"生产环境\",{\"1\":{\"74\":1}}],[\"64\",{\"1\":{\"213\":1}}],[\"600\",{\"1\":{\"161\":1,\"165\":1}}],[\"6379\",{\"1\":{\"161\":1}}],[\"6过滤器\",{\"0\":{\"103\":1}}],[\"6\",{\"0\":{\"74\":1,\"75\":1,\"76\":1,\"94\":1,\"95\":1,\"96\":1,\"97\":1,\"98\":1,\"99\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":1,\"104\":2,\"105\":2,\"106\":2,\"107\":2,\"108\":2,\"109\":3,\"219\":1},\"1\":{\"93\":1,\"102\":1,\"143\":1,\"146\":1,\"161\":1,\"190\":1,\"203\":1,\"205\":1}}],[\"6nacos高级特性\",{\"0\":{\"73\":1}}],[\"环境隔离\",{\"0\":{\"73\":1}}],[\"但第2秒只有1个请求\",{\"1\":{\"146\":1}}],[\"但这种模式阈值会动态变化\",{\"1\":{\"144\":1}}],[\"但限流的目标是\",{\"1\":{\"142\":1}}],[\"但是java系统不知道\",{\"1\":{\"234\":1}}],[\"但是不出栈\",{\"1\":{\"229\":1}}],[\"但是对象的equals方法返回false\",{\"1\":{\"222\":1}}],[\"但是超出的请求没有被拒绝\",{\"1\":{\"146\":1}}],[\"但是一个服务刚刚启动时\",{\"1\":{\"145\":1}}],[\"但是sentinel默认会给进入spring\",{\"1\":{\"143\":1}}],[\"但是限流是避免服务因突发的流量而发生故障\",{\"1\":{\"137\":1}}],[\"但是如果我们希望拦截请求\",{\"1\":{\"108\":1}}],[\"但是并不是说把所有的服务都部署在一个机房里\",{\"1\":{\"69\":1}}],[\"但默认情况下nacos的负载均衡算法是同集群内随机挑选\",{\"1\":{\"72\":1}}],[\"部分实例所在机器性能较好\",{\"1\":{\"72\":1}}],[\"部署项目的时候\",{\"1\":{\"46\":1}}],[\"部署不是很方便\",{\"1\":{\"46\":1}}],[\"部署方便\",{\"1\":{\"45\":1}}],[\"一开始没有创建长度为16的数组\",{\"1\":{\"213\":1}}],[\"一层一层进行搜索\",{\"1\":{\"188\":1}}],[\"一致保持在10\",{\"1\":{\"146\":1}}],[\"一切资源尚未初始化\",{\"1\":{\"145\":1}}],[\"一次成功\",{\"1\":{\"126\":1}}],[\"一般谈论的都是时间复杂度\",{\"1\":{\"194\":1}}],[\"一般不衡量这个东西\",{\"1\":{\"192\":1}}],[\"一般而言\",{\"1\":{\"180\":1}}],[\"一般情况下\",{\"1\":{\"88\":1}}],[\"一般来讲修改权重的概率不大\",{\"1\":{\"72\":1}}],[\"一个节点指向下一个节点\",{\"1\":{\"243\":1}}],[\"一个接口有多个实现类\",{\"1\":{\"207\":1}}],[\"一个算法的好坏是通过时间复杂度和空间复杂度来恒量的\",{\"1\":{\"192\":1}}],[\"一个数据结构包含一个数据元素的集合\",{\"1\":{\"180\":1}}],[\"一个根据id查询商品的接口\",{\"1\":{\"148\":1}}],[\"一个http请求是访问\",{\"1\":{\"143\":1}}],[\"一个优先级较低\",{\"1\":{\"142\":1}}],[\"一个优先级较高\",{\"1\":{\"142\":1}}],[\"一个服务的不可用导致整个系统的不可用的现象就被称之为雪崩效应\",{\"1\":{\"122\":1}}],[\"一个微服务往往依赖于多个其它微服务\",{\"1\":{\"122\":1}}],[\"一个链接\",{\"1\":{\"6\":1}}],[\"一个简单的幻灯片演示与各种小贴士\",{\"1\":{\"1\":1}}],[\"被访问的概率越大\",{\"1\":{\"72\":1}}],[\"默认都是\",{\"1\":{\"135\":1}}],[\"默认密码\",{\"1\":{\"134\":1}}],[\"默认用户名\",{\"1\":{\"134\":1}}],[\"默认值为5\",{\"1\":{\"205\":1}}],[\"默认值\",{\"1\":{\"134\":1}}],[\"默认值就能满足我们使用\",{\"1\":{\"88\":1}}],[\"默认过滤器\",{\"0\":{\"107\":1},\"1\":{\"105\":1}}],[\"默认是16\",{\"1\":{\"221\":1}}],[\"默认是按照声明顺序从1递增\",{\"1\":{\"109\":1}}],[\"默认是没有\",{\"1\":{\"88\":1}}],[\"默认是springmvc的注解\",{\"1\":{\"88\":1}}],[\"默认的热点参数规则是每1秒请求量不超过2\",{\"1\":{\"149\":1}}],[\"默认的过滤器就没办法实现\",{\"1\":{\"108\":1}}],[\"默认的负载均衡算法\",{\"1\":{\"81\":1}}],[\"默认的类型\",{\"1\":{\"77\":1}}],[\"默认情况下sentinel会监控spring\",{\"1\":{\"138\":1}}],[\"默认情况下\",{\"1\":{\"74\":1,\"143\":1}}],[\"默认效果是轮循机制\",{\"1\":{\"72\":1}}],[\"默认使用的负载均衡算法就是轮询\",{\"1\":{\"66\":1}}],[\"了解\",{\"0\":{\"72\":1},\"1\":{\"72\":1}}],[\"5倍\",{\"1\":{\"212\":2}}],[\"50秒内发完\",{\"1\":{\"143\":1}}],[\"5predicate的使用\",{\"0\":{\"102\":1}}],[\"5\",{\"0\":{\"84\":1,\"85\":1,\"86\":1,\"87\":1,\"88\":1,\"91\":1,\"92\":1,\"93\":1,\"108\":1,\"147\":1,\"165\":1,\"218\":1},\"1\":{\"93\":1,\"101\":1,\"139\":1,\"142\":1,\"143\":1,\"146\":1,\"161\":1,\"165\":1,\"203\":1,\"205\":2,\"206\":1,\"212\":1}}],[\"5更改负载均衡算法\",{\"0\":{\"83\":1}}],[\"5nacos高级特性\",{\"0\":{\"72\":1}}],[\"5<\",{\"1\":{\"52\":1}}],[\"集合\",{\"1\":{\"109\":1}}],[\"集成nacos的负载均衡算法\",{\"1\":{\"71\":1}}],[\"集群流量控制支持\",{\"1\":{\"131\":1}}],[\"集群\",{\"1\":{\"46\":1}}],[\"实际中可以进行物理拓展\",{\"1\":{\"192\":1}}],[\"实际中并不考虑\",{\"1\":{\"192\":1}}],[\"实际部署中会出现这样的场景\",{\"1\":{\"72\":1}}],[\"实体类所对应的依赖\",{\"1\":{\"93\":1}}],[\"实例类型\",{\"0\":{\"77\":1}}],[\"实例3\",{\"1\":{\"70\":1}}],[\"实例2\",{\"1\":{\"70\":1}}],[\"实例2和实例3属于bj\",{\"1\":{\"70\":1}}],[\"实例1属于sh\",{\"1\":{\"70\":1}}],[\"实例所属集群分配情况\",{\"1\":{\"70\":1}}],[\"实现了基于注解的缓存功能\",{\"1\":{\"159\":1}}],[\"实现配置的热更新有两种方式\",{\"1\":{\"118\":1}}],[\"实现配置的热更新\",{\"1\":{\"111\":1}}],[\"实现过滤器逻辑\",{\"1\":{\"108\":1}}],[\"实现过滤器排序\",{\"1\":{\"108\":1}}],[\"实现来年两个接口\",{\"1\":{\"108\":1}}],[\"实现代码\",{\"1\":{\"108\":1}}],[\"实现getorder方法\",{\"1\":{\"108\":1}}],[\"实现globlefilter里面的方法\",{\"1\":{\"108\":1}}],[\"实现ordered接口定义该过滤器的顺序❓过滤器顺接口\",{\"1\":{\"108\":1}}],[\"实现\",{\"1\":{\"106\":1}}],[\"实现组件复用的目的\",{\"1\":{\"93\":1}}],[\"实现远程调用过程\",{\"1\":{\"85\":1}}],[\"实现步骤\",{\"1\":{\"63\":1,\"149\":1}}],[\"实现微服务\",{\"1\":{\"56\":1}}],[\"启动程序进行测试\",{\"1\":{\"161\":1,\"165\":1}}],[\"启动sentinel\",{\"0\":{\"134\":1}}],[\"启动网关服务后\",{\"1\":{\"102\":1}}],[\"启动三个用户微服务实例\",{\"1\":{\"70\":1}}],[\"启动三个服务user微服务实例\",{\"1\":{\"70\":1}}],[\"启动实例2和实例3\",{\"1\":{\"70\":1}}],[\"启动两个微服务\",{\"1\":{\"63\":1}}],[\"添加内训\",{\"1\":{\"192\":1}}],[\"添加查询缓存逻辑\",{\"1\":{\"161\":1}}],[\"添加流控规则\",{\"1\":{\"143\":1,\"146\":1}}],[\"添加两个端点\",{\"1\":{\"143\":1}}],[\"添加下面内容\",{\"1\":{\"136\":1}}],[\"添加路由过滤\",{\"1\":{\"106\":1}}],[\"添加集群配置\",{\"1\":{\"70\":1,\"71\":1}}],[\"添加依赖\",{\"1\":{\"52\":1}}],[\"修改成后面的element元素\",{\"1\":{\"211\":1}}],[\"修改\",{\"1\":{\"205\":1}}],[\"修改快\",{\"1\":{\"199\":1}}],[\"修改用户数据成功\",{\"1\":{\"142\":1}}],[\"修改用户数据端点\",{\"1\":{\"142\":1}}],[\"修改application\",{\"1\":{\"136\":1}}],[\"修改端口\",{\"1\":{\"134\":1}}],[\"修改gateway服务的application\",{\"1\":{\"106\":1}}],[\"修改配置文件\",{\"1\":{\"101\":1}}],[\"修改日志级别\",{\"1\":{\"88\":1}}],[\"修改orderservice中的远程调用代码\",{\"1\":{\"86\":1}}],[\"修改spzx\",{\"1\":{\"70\":1,\"76\":1}}],[\"修改一个功能\",{\"1\":{\"45\":1}}],[\"就像大家排队到银行取钱一样\",{\"1\":{\"237\":1}}],[\"就会在同一个索引上以链表的形式存储\",{\"1\":{\"213\":1}}],[\"就会出现如下的错误\",{\"1\":{\"76\":1}}],[\"就是执行算法的内存空间成本\",{\"1\":{\"192\":1}}],[\"就是执行算法的时间成本\",{\"1\":{\"192\":1}}],[\"就是负载均衡算法由客户端提供\",{\"1\":{\"79\":1}}],[\"就能实现缓存功能\",{\"1\":{\"159\":1}}],[\"就点击哪个端点后面的按钮\",{\"1\":{\"142\":1}}],[\"就对\",{\"1\":{\"142\":1}}],[\"就可以看到sentinel的控制台了\",{\"1\":{\"135\":1}}],[\"就可以在nacos的后台管理系统中\",{\"1\":{\"63\":1}}],[\"就不会在通过服务a去访问服务d了\",{\"1\":{\"126\":1}}],[\"就不会访问之前的了\",{\"1\":{\"69\":1}}],[\"就不放行\",{\"1\":{\"108\":1}}],[\"就需要使用到gateway中所提供的过滤器了\",{\"1\":{\"104\":1}}],[\"❌上线下线会重新访问原来的\",{\"1\":{\"69\":1}}],[\"恢复\",{\"1\":{\"69\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"209\":1}}],[\"其它查找\",{\"1\":{\"190\":1}}],[\"其它排序\",{\"1\":{\"189\":1}}],[\"其他\",{\"0\":{\"269\":1},\"1\":{\"183\":1}}],[\"其他注解\",{\"0\":{\"162\":1}}],[\"其他的处理方式是一种补救措施\",{\"1\":{\"127\":1}}],[\"其他的微服务引用该依赖包\",{\"1\":{\"93\":1}}],[\"其他服务不受影响\",{\"1\":{\"46\":1}}],[\"其中resize\",{\"1\":{\"221\":1}}],[\"其中的n代表输入数据的量\",{\"1\":{\"193\":1}}],[\"其中loadbalancerclientfactory\",{\"1\":{\"83\":1}}],[\"其中一个地区服务器下线就会访问另外一个\",{\"1\":{\"69\":1}}],[\"其实就是服务id\",{\"1\":{\"81\":1}}],[\"其主要原理是通过选择合适的服务实例来实现负载均衡\",{\"1\":{\"79\":1}}],[\"检查配置文件格式\",{\"1\":{\"69\":1}}],[\"测试环境\",{\"1\":{\"74\":1}}],[\"测试\",{\"0\":{\"259\":1,\"263\":1,\"268\":1,\"270\":1,\"272\":1},\"1\":{\"69\":1}}],[\"❓怎么保证服务的高可用\",{\"1\":{\"69\":1}}],[\"保护服务器\",{\"1\":{\"128\":1}}],[\"保存用户\",{\"1\":{\"143\":1}}],[\"保存参数的信息\",{\"1\":{\"108\":1}}],[\"保存这些注册信息\",{\"1\":{\"58\":1}}],[\"保证集群的高可用\",{\"1\":{\"69\":1}}],[\"上面我们提到\",{\"1\":{\"161\":1}}],[\"上述的过滤器是gateway中提供的默认的过滤器\",{\"1\":{\"108\":1}}],[\"上述代码存在的弊端\",{\"1\":{\"93\":1}}],[\"上海机房内的order微服务应该优先访问同机房的user微服务\",{\"1\":{\"69\":1}}],[\"上使用\",{\"1\":{\"38\":1}}],[\"例如传递3\",{\"1\":{\"216\":1}}],[\"例如传递2\",{\"1\":{\"216\":1}}],[\"例如秒杀商品\",{\"1\":{\"148\":1}}],[\"例如连接\",{\"1\":{\"91\":1}}],[\"例如解析json字符串为java对象\",{\"1\":{\"88\":1}}],[\"例如\",{\"1\":{\"69\":1,\"76\":1,\"93\":1,\"105\":1,\"134\":1,\"138\":1,\"145\":1,\"146\":1,\"148\":1,\"160\":1}}],[\"当链表没有下一个节点的时候\",{\"1\":{\"222\":1}}],[\"当链表的长度达到8\",{\"1\":{\"213\":1}}],[\"当然还有二维数组\",{\"1\":{\"197\":1}}],[\"当数据增大256倍时\",{\"1\":{\"193\":2}}],[\"当数据增大n倍时\",{\"1\":{\"193\":1}}],[\"当我们在删除数据库user表的数据的时候\",{\"1\":{\"164\":1}}],[\"当我们把微服务都注册到注册中心以后\",{\"1\":{\"64\":1}}],[\"当id=1的请求触发阈值被限流时\",{\"1\":{\"148\":1}}],[\"当某一个请求最大的预期等待时间超过了所设定的超时时间时同样是拒绝并抛出异常\",{\"1\":{\"144\":1,\"146\":1}}],[\"当超过阈值对低优先级的资源进行限流\",{\"1\":{\"142\":1}}],[\"当\",{\"1\":{\"142\":1}}],[\"当访问流量超过阈值时\",{\"1\":{\"142\":1}}],[\"当请求进入微服务时\",{\"1\":{\"138\":1}}],[\"当请求超时时\",{\"1\":{\"91\":1}}],[\"当请求超过设定的超时时间后\",{\"1\":{\"91\":1}}],[\"当在访问服务a的时候\",{\"1\":{\"126\":1}}],[\"当发现访问服务d的请求异常比例过高时\",{\"1\":{\"126\":1}}],[\"当船体破损时\",{\"1\":{\"125\":1}}],[\"当服务d出现了问题了以后\",{\"1\":{\"122\":1}}],[\"当微服务部署的实例越来越多\",{\"1\":{\"111\":1}}],[\"当过滤器的order值一样时\",{\"1\":{\"109\":1}}],[\"当前usercontroller的save方法是用来保存用户信息的\",{\"1\":{\"163\":1}}],[\"当前路由的过滤器\",{\"1\":{\"109\":1}}],[\"当前过滤器写在spzx\",{\"1\":{\"106\":1}}],[\"当sh集群中的user微服务实例出现问题以后\",{\"1\":{\"71\":1}}],[\"当order服务优先访问sh集群中的user微服务实例\",{\"1\":{\"71\":1}}],[\"当本集群内不可用时\",{\"1\":{\"69\":1}}],[\"因为0是第一位\",{\"1\":{\"203\":1}}],[\"因为每200ms执行一个请求\",{\"1\":{\"146\":1}}],[\"因为还没有监控任何服务\",{\"1\":{\"135\":1}}],[\"因为本地访问速度更快\",{\"1\":{\"69\":1}}],[\"因此直接从redis中进行命中\",{\"1\":{\"161\":1}}],[\"因此响应时间\",{\"1\":{\"146\":1}}],[\"因此需要关闭这种资源整合\",{\"1\":{\"143\":1}}],[\"因此需要设置为一个较为合理的超时时间\",{\"1\":{\"91\":1}}],[\"因此qps为10\",{\"1\":{\"142\":1}}],[\"因此点击它后面的按钮\",{\"1\":{\"142\":1}}],[\"因此当修改订单业务触发阈值时\",{\"1\":{\"142\":1}}],[\"因此spring\",{\"1\":{\"138\":1}}],[\"因此springcloud可以看做是一套微服务的解决方案\",{\"1\":{\"48\":1}}],[\"因此仅仅对访问spzx\",{\"1\":{\"106\":1}}],[\"因此\",{\"1\":{\"72\":1}}],[\"应该尽可能访问同集群实例\",{\"1\":{\"69\":1}}],[\"如何评价一个算法的好坏\",{\"0\":{\"192\":1}}],[\"如redis\",{\"1\":{\"161\":1}}],[\"如网络抖动\",{\"1\":{\"92\":1}}],[\"如下表所示\",{\"1\":{\"88\":1}}],[\"如下图所示\",{\"1\":{\"79\":1,\"122\":1,\"125\":1}}],[\"如下所示\",{\"1\":{\"69\":1,\"74\":1,\"75\":1,\"102\":1,\"113\":1,\"116\":1,\"117\":1,\"141\":1}}],[\"如果对象哈希值相同\",{\"1\":{\"222\":1}}],[\"如果对象的哈希值相同\",{\"1\":{\"222\":1}}],[\"如果对个别元素出现哈希值一样\",{\"1\":{\"213\":1}}],[\"如果数组是null或者长度等于0\",{\"1\":{\"219\":1}}],[\"如果loadfactor\",{\"1\":{\"215\":1}}],[\"如果initialcapacity大于最大容器\",{\"1\":{\"215\":1}}],[\"如果initialcapacity\",{\"1\":{\"215\":1}}],[\"如果后续删除元素\",{\"1\":{\"213\":1}}],[\"如果内容不一样\",{\"1\":{\"213\":1}}],[\"如果哈希值一样内容一样\",{\"1\":{\"213\":1}}],[\"如果哈希值一样\",{\"1\":{\"213\":1}}],[\"如果哈希值不一样\",{\"1\":{\"213\":1}}],[\"如果equals方法返回的是true则不能存储否则可以存储\",{\"1\":{\"213\":1}}],[\"如果相同就会继续调用equals方法判断\",{\"1\":{\"213\":1}}],[\"如果有数据\",{\"1\":{\"160\":1,\"161\":1}}],[\"如果使用队列模式做流控\",{\"1\":{\"146\":1}}],[\"如果直接将qps跑到最大值\",{\"1\":{\"145\":1}}],[\"如果只希望统计从\",{\"1\":{\"143\":1}}],[\"如果只做降级处理\",{\"1\":{\"126\":1}}],[\"如果超过阈值对从该链路请求进行限流\",{\"1\":{\"143\":1}}],[\"如果超出阈值则会熔断该业务\",{\"1\":{\"126\":1}}],[\"如果测试结果不是上述情况\",{\"1\":{\"139\":1}}],[\"如果服务没有访问\",{\"1\":{\"135\":1}}],[\"如果在application\",{\"1\":{\"119\":1}}],[\"如果不相同则会直接存储\",{\"1\":{\"213\":1}}],[\"如果不是不能访问\",{\"1\":{\"108\":1}}],[\"如果不是就不能正常访问\",{\"1\":{\"108\":1}}],[\"如果不可用\",{\"1\":{\"58\":1}}],[\"如果同时满足则放行\",{\"1\":{\"108\":1}}],[\"如果抛出异常重试结束\",{\"1\":{\"92\":1}}],[\"如果由于网络暂时不可用导致触发了超时机制\",{\"1\":{\"92\":1}}],[\"如果请求一直处于等待状态而不超时\",{\"1\":{\"91\":1}}],[\"如果没有超时机制\",{\"1\":{\"91\":1}}],[\"如果要修改sentinel的默认端口\",{\"1\":{\"134\":1}}],[\"如果要对所有的路由都生效\",{\"1\":{\"107\":1}}],[\"如果要全局生效\",{\"1\":{\"90\":1}}],[\"如果要自定义时\",{\"1\":{\"88\":1}}],[\"如果是放行\",{\"1\":{\"108\":1}}],[\"如果是正常访问\",{\"1\":{\"108\":1}}],[\"如果是局部生效\",{\"1\":{\"90\":1}}],[\"如果是写服务名称\",{\"1\":{\"89\":1}}],[\"如果是服务器挂了\",{\"1\":{\"69\":1}}],[\"如果想更改默认的负载均衡算法\",{\"1\":{\"83\":1}}],[\"如果想完成上面的需求\",{\"1\":{\"54\":1}}],[\"如果实例宕机\",{\"1\":{\"77\":1}}],[\"如果实例宕机超过一定时间\",{\"1\":{\"77\":1}}],[\"如果权重修改为0\",{\"1\":{\"72\":1}}],[\"如果错误\",{\"1\":{\"69\":1}}],[\"依次调用对应服务\",{\"1\":{\"66\":1}}],[\"所花的时间与占用内存便是衡量一个算法好坏的标准\",{\"1\":{\"192\":1}}],[\"所以走后门插队的现象是不可能存在的\",{\"1\":{\"237\":1}}],[\"所以当减少n时\",{\"1\":{\"234\":1}}],[\"所以我们不用boolean接受返回值\",{\"1\":{\"211\":1}}],[\"所以我们对流量进行控制\",{\"1\":{\"127\":1}}],[\"所以在学习数据结构之前\",{\"1\":{\"180\":1}}],[\"所以你无需担心它的长度\",{\"1\":{\"6\":1}}],[\"所有元素都要遵守这个操作\",{\"1\":{\"237\":1}}],[\"所有数据元素按照层次结构进行组织\",{\"1\":{\"183\":1}}],[\"所有进入的请求都要排队\",{\"1\":{\"146\":1}}],[\"所有模块读取配置中心中的内容\",{\"1\":{\"110\":1}}],[\"所有这些谓词都匹配http请求的不同属性\",{\"1\":{\"102\":1}}],[\"所有这些predicate都与http请求的不同属性匹配\",{\"1\":{\"102\":1}}],[\"所有service\",{\"1\":{\"74\":1}}],[\"所提供的负载均衡器\",{\"1\":{\"66\":1}}],[\"返回的是被删除的元素\",{\"1\":{\"211\":1}}],[\"返回的是一种默认值\",{\"1\":{\"126\":1}}],[\"返回值类型\",{\"1\":{\"86\":1}}],[\"返回服务实例\",{\"1\":{\"65\":1}}],[\"返回订单数据\",{\"1\":{\"54\":1,\"65\":1}}],[\"获取对象的哈希值\",{\"1\":{\"218\":1}}],[\"获取容量\",{\"1\":{\"205\":1}}],[\"获取全局过滤器的集合\",{\"1\":{\"109\":1}}],[\"获取路由级别的过滤器和默认过滤器的集合\",{\"1\":{\"109\":1}}],[\"获取所有的key根据key进行遍历\",{\"1\":{\"108\":1}}],[\"获取请求路径中参数\",{\"1\":{\"108\":1}}],[\"获取请求uri\",{\"1\":{\"81\":1}}],[\"获取请求url\",{\"1\":{\"80\":1}}],[\"获取当前时区时间代码\",{\"1\":{\"102\":1}}],[\"获取了一个具体的负载均衡算法对象\",{\"1\":{\"81\":1}}],[\"获取uri路径的主机名\",{\"1\":{\"81\":1}}],[\"获取服务实例列表\",{\"1\":{\"65\":1}}],[\"获取resttemplate远程调用返回结果\",{\"1\":{\"54\":1}}],[\"根据userid查询用户信息的接口方法\",{\"1\":{\"86\":1}}],[\"根据机房进行配置\",{\"1\":{\"69\":1}}],[\"根据服务的id从nacos注册中心中获取服务地址列表\",{\"1\":{\"81\":1}}],[\"根据服务的名称从注册中心中获取服务地址信息\",{\"1\":{\"65\":1}}],[\"根据服务名称从注册中心中获取服务实例列表\",{\"1\":{\"65\":1}}],[\"根据id查询订单数据\",{\"1\":{\"54\":1,\"65\":1}}],[\"注入实体类\",{\"1\":{\"117\":1}}],[\"注入resttemplate远程调用工具\",{\"1\":{\"65\":1}}],[\"注意事项\",{\"1\":{\"149\":1}}],[\"注意\",{\"1\":{\"66\":1,\"72\":1,\"139\":2,\"215\":1}}],[\"注解\",{\"0\":{\"160\":1},\"1\":{\"66\":1,\"160\":1,\"161\":2,\"164\":1,\"165\":2}}],[\"注册到nacos中\",{\"1\":{\"63\":1}}],[\"注册中心需要以心跳的方式去检测清单中的服务是否可用\",{\"1\":{\"58\":1}}],[\"注册中心\",{\"1\":{\"49\":1,\"110\":1}}],[\"需要是有序数据\",{\"1\":{\"190\":1}}],[\"需要先对内存有一个简单的了解\",{\"1\":{\"180\":1}}],[\"需要利用\",{\"1\":{\"149\":1}}],[\"需要对查询订单业务限流\",{\"1\":{\"142\":1}}],[\"需要输入账号和密码\",{\"1\":{\"135\":1}}],[\"需要进行自定义\",{\"1\":{\"105\":1}}],[\"需要在服务清单中剔除不可用的服务\",{\"1\":{\"58\":1}}],[\"需求\",{\"1\":{\"63\":1,\"71\":1,\"106\":1,\"108\":1,\"139\":1,\"161\":1,\"165\":1}}],[\"8=2048倍\",{\"1\":{\"193\":1}}],[\"8080页面\",{\"1\":{\"135\":1}}],[\"8080\",{\"1\":{\"134\":1,\"136\":1}}],[\"8\",{\"0\":{\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"131\":1,\"132\":1,\"133\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":1,\"144\":1,\"147\":1,\"221\":1},\"1\":{\"143\":1,\"205\":1,\"213\":1,\"216\":3}}],[\"8222\",{\"1\":{\"101\":2}}],[\"8848\",{\"1\":{\"61\":3,\"63\":1,\"101\":2,\"114\":1}}],[\"8<\",{\"1\":{\"52\":1,\"53\":1}}],[\"v\",{\"1\":{\"217\":2,\"218\":2}}],[\"v>\",{\"1\":{\"217\":4,\"219\":2,\"222\":1}}],[\"void\",{\"1\":{\"92\":1,\"93\":1,\"101\":1,\"117\":1,\"143\":2,\"164\":1,\"203\":1,\"205\":3,\"206\":3,\"208\":2,\"209\":1,\"211\":1,\"212\":3}}],[\"value注入的变量所在类上添加注解\",{\"1\":{\"118\":1}}],[\"value注解读取自定义配置\",{\"1\":{\"116\":1}}],[\"value\",{\"0\":{\"116\":1},\"1\":{\"83\":1,\"86\":1,\"90\":1,\"106\":2,\"116\":4,\"117\":5,\"142\":1,\"143\":2,\"149\":2,\"161\":2,\"163\":2,\"164\":2,\"165\":1,\"217\":5,\"218\":2,\"220\":1,\"221\":2,\"222\":1}}],[\"v2版\",{\"1\":{\"206\":1}}],[\"v2\",{\"1\":{\"61\":2}}],[\"version\",{\"1\":{\"52\":4}}],[\"version>8\",{\"1\":{\"52\":1}}],[\"version>3\",{\"1\":{\"52\":1}}],[\"version>\",{\"1\":{\"52\":9,\"93\":2}}],[\"version>2022\",{\"1\":{\"52\":2}}],[\"拉取镜像\",{\"1\":{\"61\":1}}],[\"并返回元素set\",{\"1\":{\"205\":1}}],[\"并返回元素\",{\"1\":{\"205\":2}}],[\"并在启动类上使用\",{\"1\":{\"160\":1}}],[\"并进行限流操作\",{\"1\":{\"143\":1}}],[\"并连接sentinel的控制台\",{\"1\":{\"136\":1}}],[\"并持续演进\",{\"1\":{\"131\":1}}],[\"并通过逻辑and\",{\"1\":{\"102\":1}}],[\"并加入如下的依赖\",{\"1\":{\"93\":1}}],[\"并且在启动类上添加feign接口的包扫描路径\",{\"1\":{\"93\":1}}],[\"并且会将数据库所对应的实体类也抽取到一个独立的模块中\",{\"1\":{\"93\":1}}],[\"并且配置负载均衡的使用者\",{\"1\":{\"83\":1}}],[\"并且实例会定时上报自身的健康状态给nacos注册中心\",{\"1\":{\"77\":1}}],[\"并且它会自动换行\",{\"1\":{\"6\":1}}],[\"并获取所有服务的实例清单\",{\"1\":{\"58\":1}}],[\"端口号等\",{\"1\":{\"58\":1}}],[\"会得到一个索引\",{\"1\":{\"221\":1}}],[\"会越来越长\",{\"1\":{\"146\":1}}],[\"会导致链路模式失效\",{\"1\":{\"143\":1}}],[\"会拦截访问服务d的一切请求\",{\"1\":{\"126\":1}}],[\"会继续进行访问\",{\"1\":{\"126\":1}}],[\"会按照\",{\"1\":{\"109\":1}}],[\"会将当前路由过滤器和defaultfilter\",{\"1\":{\"109\":1}}],[\"会返回一个map对象\",{\"1\":{\"108\":1}}],[\"会从服务列表剔除\",{\"1\":{\"77\":1}}],[\"会重新进行访问第一个\",{\"1\":{\"69\":1}}],[\"会向注册中心注册自己服务的详情信息\",{\"1\":{\"58\":1}}],[\"会让文字在不超出幻灯片范围的情况下尽可能大\",{\"1\":{\"12\":1}}],[\"解析\",{\"1\":{\"214\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":1,\"219\":1,\"220\":1,\"221\":1,\"222\":2}}],[\"解决特定问题有很多实现方式\",{\"1\":{\"192\":1}}],[\"解决方案\",{\"0\":{\"123\":1},\"1\":{\"69\":1,\"234\":1}}],[\"解决传统远程调用所存在的问题\",{\"1\":{\"57\":1}}],[\"解耦合\",{\"1\":{\"46\":1}}],[\"缺少负载均衡机制\",{\"1\":{\"55\":1}}],[\"缺点\",{\"0\":{\"200\":1,\"246\":1},\"1\":{\"45\":1,\"46\":1}}],[\"维护性差\",{\"1\":{\"55\":1}}],[\"维护困难\",{\"1\":{\"45\":1}}],[\"这会占用额外的存储空间\",{\"1\":{\"246\":1}}],[\"这导致了链表的随机访问效率较低\",{\"1\":{\"246\":1}}],[\"这些数据元素或存储在连续的内存单元中\",{\"1\":{\"180\":1}}],[\"这种配置是对查询商品这个接口的所有商品一视同仁\",{\"1\":{\"148\":1}}],[\"这种兜底方案也将其称之为降级逻辑\",{\"1\":{\"126\":1}}],[\"这种返回就是一种兜底方案\",{\"1\":{\"126\":1}}],[\"这种设计思想\",{\"1\":{\"125\":1}}],[\"这就是熔断的机制\",{\"1\":{\"126\":1}}],[\"这是算法的时间复杂度的表示\",{\"1\":{\"193\":1}}],[\"这是默认值\",{\"1\":{\"89\":1}}],[\"这是一个有着\",{\"1\":{\"6\":1}}],[\"这是一个\",{\"0\":{\"6\":1}}],[\"这里的log是以2为底的\",{\"1\":{\"193\":1}}],[\"这里的this\",{\"1\":{\"81\":1}}],[\"这里发起请求的qps为5\",{\"1\":{\"149\":1}}],[\"这里不要点击hot后面的按钮\",{\"1\":{\"149\":1}}],[\"这里用default就是全局配置\",{\"1\":{\"89\":1}}],[\"这样就不会剩下\",{\"1\":{\"234\":1}}],[\"这样这个端点就会触发阈值\",{\"1\":{\"142\":1}}],[\"这样的一个调用链就叫做簇点链路\",{\"1\":{\"138\":1}}],[\"这样才能触发sentinel的监控\",{\"1\":{\"136\":1}}],[\"这样\",{\"1\":{\"86\":1}}],[\"这个复杂度高于线性低于平方\",{\"1\":{\"193\":1}}],[\"这个资源添加热点参数限流\",{\"1\":{\"149\":1}}],[\"这个资源设置限流\",{\"1\":{\"145\":1,\"146\":1}}],[\"这个资源设置流控规则\",{\"1\":{\"139\":1}}],[\"这个就叫做阈值\",{\"1\":{\"130\":1}}],[\"这个值由spring进行指定\",{\"1\":{\"109\":1}}],[\"这个客户端主要是基于springmvc的注解来声明远程调用的信息\",{\"1\":{\"86\":1}}],[\"这个接口\",{\"1\":{\"54\":1}}],[\"47\",{\"1\":{\"107\":1}}],[\"42\",{\"1\":{\"107\":1}}],[\"4gateway初体验\",{\"0\":{\"101\":1}}],[\"4代码优化\",{\"0\":{\"93\":1}}],[\"4补充知识\",{\"0\":{\"82\":1}}],[\"45a9\",{\"1\":{\"76\":1}}],[\"4a88035e\",{\"1\":{\"76\":1}}],[\"4nacos高级特性\",{\"0\":{\"67\":1}}],[\"4\",{\"0\":{\"54\":1,\"55\":1,\"56\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"107\":1,\"119\":1,\"136\":1,\"144\":1,\"162\":1,\"217\":1},\"1\":{\"53\":1,\"86\":1,\"93\":1,\"101\":1,\"102\":1,\"138\":1,\"142\":1,\"143\":1,\"161\":1,\"165\":1,\"203\":1,\"205\":1,\"216\":3}}],[\"usually\",{\"1\":{\"212\":1}}],[\"user指的是方法形参的名称\",{\"1\":{\"163\":2}}],[\"usercache\",{\"1\":{\"161\":1,\"163\":1,\"164\":1}}],[\"usercontroller\",{\"1\":{\"106\":1,\"116\":2,\"117\":2,\"149\":1}}],[\"users的资源\",{\"1\":{\"143\":1}}],[\"users\",{\"1\":{\"143\":3}}],[\"userservice\",{\"1\":{\"106\":1,\"116\":3,\"117\":3,\"143\":2,\"149\":1}}],[\"user中的usercontroller中的端点\",{\"1\":{\"138\":1}}],[\"user中整合sentinel\",{\"1\":{\"136\":1}}],[\"userapplication\",{\"1\":{\"117\":2}}],[\"user项目的\",{\"1\":{\"114\":1}}],[\"user路由下\",{\"1\":{\"106\":1}}],[\"user微服务中\",{\"1\":{\"114\":1}}],[\"user微服务中加入如下依赖\",{\"1\":{\"93\":1}}],[\"user微服务中所定义的实体类\",{\"1\":{\"93\":1}}],[\"user微服务中所对应的实体类抽取到spzx\",{\"1\":{\"93\":1}}],[\"user微服务所对应的服务实例属于public的名称空间\",{\"1\":{\"76\":1}}],[\"user实体类抽取到一个独立的模块中\",{\"1\":{\"93\":1}}],[\"userfeignclient\",{\"1\":{\"86\":4}}],[\"user的任意接口\",{\"1\":{\"136\":1}}],[\"user的接口方法中读取请求头数据\",{\"1\":{\"106\":1}}],[\"user的请求有效\",{\"1\":{\"106\":1}}],[\"user的请求添加一个请求头\",{\"1\":{\"106\":1}}],[\"user的实例列表\",{\"1\":{\"72\":1}}],[\"user的application\",{\"1\":{\"70\":1}}],[\"userid\",{\"1\":{\"54\":1,\"86\":4,\"106\":4,\"116\":4,\"117\":4,\"139\":1,\"142\":1,\"145\":1,\"146\":1,\"149\":6,\"161\":2,\"164\":2}}],[\"username\",{\"1\":{\"53\":1,\"108\":3,\"134\":1,\"163\":3}}],[\"user\",{\"1\":{\"53\":2,\"54\":6,\"63\":2,\"65\":6,\"66\":3,\"81\":3,\"83\":1,\"86\":8,\"89\":1,\"90\":1,\"98\":2,\"101\":10,\"102\":3,\"106\":4,\"107\":3,\"114\":1,\"116\":2,\"117\":2,\"136\":1,\"138\":1,\"139\":1,\"142\":9,\"143\":10,\"145\":1,\"146\":1,\"149\":3,\"161\":7,\"163\":7}}],[\"unify\",{\"1\":{\"143\":1}}],[\"unauthorized\",{\"1\":{\"108\":1}}],[\"uri=lb\",{\"1\":{\"101\":2}}],[\"uri\",{\"1\":{\"101\":2,\"102\":1,\"106\":1,\"107\":1}}],[\"url以及响应状态码和执行时间\",{\"1\":{\"89\":1}}],[\"url\",{\"1\":{\"53\":1}}],[\"up效果\",{\"1\":{\"145\":1}}],[\"up也叫预热模式\",{\"1\":{\"145\":1}}],[\"updateuserbyid\",{\"1\":{\"142\":4}}],[\"updateuserbyid资源被访问的qps超过5时\",{\"1\":{\"142\":1}}],[\"updateuserbyid资源\",{\"1\":{\"142\":1}}],[\"updateuserbyid资源的请求进行统计\",{\"1\":{\"142\":1}}],[\"up\",{\"0\":{\"145\":1},\"1\":{\"19\":1,\"144\":1,\"145\":1}}],[\"jdk8\",{\"1\":{\"213\":1}}],[\"jdk7\",{\"1\":{\"213\":1}}],[\"jdbc\",{\"1\":{\"53\":2}}],[\"jmeter测试\",{\"1\":{\"143\":1,\"145\":1,\"146\":1,\"149\":1}}],[\"jmeter\",{\"1\":{\"139\":2}}],[\"jar\",{\"1\":{\"134\":4,\"139\":2}}],[\"java初级\",{\"0\":{\"266\":1}}],[\"java高级\",{\"0\":{\"261\":1}}],[\"java\",{\"0\":{\"262\":1},\"1\":{\"131\":2,\"134\":2,\"139\":2}}],[\"java客户端\",{\"1\":{\"131\":1}}],[\"java代码的方式\",{\"0\":{\"90\":1}}],[\"java<\",{\"1\":{\"52\":1,\"53\":1}}],[\"n个节点离散分配\",{\"1\":{\"243\":1}}],[\"null\",{\"1\":{\"219\":1,\"221\":3,\"222\":3}}],[\"n乘以logn\",{\"1\":{\"193\":1}}],[\"n表示代码执行次数和数据量\",{\"1\":{\"193\":1}}],[\"nlogn\",{\"1\":{\"193\":3,\"195\":1}}],[\"n\",{\"1\":{\"193\":2,\"216\":14,\"219\":3,\"221\":2}}],[\"node<k\",{\"1\":{\"217\":3,\"219\":2,\"222\":1}}],[\"node\",{\"0\":{\"217\":1},\"1\":{\"217\":1}}],[\"now\",{\"1\":{\"102\":1}}],[\"none\",{\"1\":{\"27\":1,\"88\":1,\"89\":1}}],[\"next\",{\"1\":{\"217\":5,\"222\":2}}],[\"nextint\",{\"1\":{\"65\":1}}],[\"newnode\",{\"1\":{\"221\":2,\"222\":1}}],[\"newthr\",{\"1\":{\"220\":1}}],[\"newcap\",{\"1\":{\"220\":1}}],[\"newcapacity\",{\"1\":{\"208\":5,\"212\":7}}],[\"newdata\",{\"1\":{\"208\":4}}],[\"new的时候是10\",{\"1\":{\"197\":1}}],[\"new\",{\"1\":{\"54\":1,\"65\":1,\"66\":1,\"83\":2,\"92\":2,\"109\":2,\"161\":3,\"165\":2,\"197\":1,\"203\":1,\"205\":7,\"206\":4,\"208\":2,\"212\":4,\"215\":2}}],[\"nacos作为配置中心时所对应的依赖\",{\"1\":{\"114\":1}}],[\"nacos作为注册中心的依赖\",{\"1\":{\"63\":1}}],[\"nacos中添加配置\",{\"0\":{\"113\":1}}],[\"nacos中的服务实例存在两种类型\",{\"1\":{\"77\":1}}],[\"nacos入门\",{\"0\":{\"112\":1}}],[\"nacos一方面可以将配置集中管理\",{\"1\":{\"111\":1}}],[\"nacos除了可以做注册中心\",{\"1\":{\"110\":1}}],[\"nacos配置中心的配置\",{\"1\":{\"119\":1}}],[\"nacos配置中心\",{\"0\":{\"110\":1}}],[\"nacos服务发现依赖\",{\"1\":{\"101\":1}}],[\"nacos也是支持多环境隔离配置的\",{\"1\":{\"74\":1}}],[\"nacos提供了权重配置来控制访问频率\",{\"1\":{\"72\":1}}],[\"nacos启动\",{\"1\":{\"61\":1}}],[\"nacos2\",{\"1\":{\"61\":1}}],[\"nacos\",{\"0\":{\"61\":1},\"1\":{\"61\":8,\"63\":2,\"70\":3,\"71\":2,\"72\":1,\"76\":1,\"77\":1,\"101\":3,\"114\":5}}],[\"nacos注册中心会主动询问实例的健康状态\",{\"1\":{\"77\":1}}],[\"nacos注册中心简介\",{\"0\":{\"58\":1}}],[\"nacos注册中心\",{\"0\":{\"57\":1}}],[\"name指的是user的name属性\",{\"1\":{\"163\":1}}],[\"name=spzx\",{\"1\":{\"101\":1}}],[\"name=bj\",{\"1\":{\"70\":2}}],[\"name表示该负载均衡器要应用的服务名称\",{\"1\":{\"83\":1}}],[\"namespace\",{\"1\":{\"74\":1,\"76\":1}}],[\"name\",{\"1\":{\"53\":1,\"61\":1,\"63\":1,\"70\":1,\"71\":1,\"83\":5,\"101\":1,\"106\":1,\"116\":1,\"117\":1,\"149\":1}}],[\"文件如下\",{\"1\":{\"53\":1}}],[\"文字并包含\",{\"1\":{\"6\":1}}],[\"创建下一个节点存储对象\",{\"1\":{\"222\":1}}],[\"创建链表对象\",{\"1\":{\"221\":1}}],[\"创建新数组\",{\"1\":{\"208\":1}}],[\"创建启动类\",{\"1\":{\"101\":1}}],[\"创建网关微服务模块\",{\"1\":{\"101\":2}}],[\"创建容器\",{\"1\":{\"61\":1}}],[\"创建resttemplate对象\",{\"1\":{\"54\":1}}],[\"创建子模块\",{\"1\":{\"53\":1}}],[\"创建一个maven父工程\",{\"1\":{\"52\":1}}],[\"peek\",{\"1\":{\"229\":1}}],[\"per\",{\"0\":{\"129\":1}}],[\"pop\",{\"1\":{\"229\":1}}],[\"post\",{\"1\":{\"100\":2}}],[\"port=8090\",{\"1\":{\"134\":1}}],[\"port=8222\",{\"1\":{\"101\":1}}],[\"port=10103\",{\"1\":{\"70\":1}}],[\"port=10101\",{\"1\":{\"70\":1}}],[\"port\",{\"1\":{\"53\":1,\"101\":1,\"134\":1,\"161\":1}}],[\"p\",{\"1\":{\"61\":2,\"219\":1,\"221\":1,\"222\":5}}],[\"push\",{\"1\":{\"229\":1}}],[\"put方法中调研putval方法\",{\"1\":{\"218\":1}}],[\"putval方法源码\",{\"0\":{\"219\":1}}],[\"putval方法\",{\"1\":{\"218\":1}}],[\"putval方法中调用hash方法\",{\"1\":{\"218\":1}}],[\"putval\",{\"1\":{\"218\":1}}],[\"put\",{\"1\":{\"218\":1}}],[\"pull\",{\"1\":{\"61\":1}}],[\"public\",{\"1\":{\"54\":4,\"65\":3,\"66\":1,\"83\":3,\"86\":4,\"90\":2,\"92\":3,\"93\":2,\"101\":2,\"106\":1,\"108\":3,\"109\":1,\"116\":2,\"117\":5,\"142\":1,\"143\":4,\"149\":1,\"161\":3,\"163\":1,\"164\":1,\"165\":3,\"203\":2,\"205\":15,\"206\":11,\"208\":2,\"209\":1,\"212\":3,\"214\":1,\"215\":1,\"218\":1}}],[\"printreverse\",{\"1\":{\"205\":1}}],[\"print\",{\"1\":{\"205\":1}}],[\"println\",{\"1\":{\"102\":1,\"143\":4,\"203\":3,\"208\":1}}],[\"private\",{\"1\":{\"54\":2,\"65\":3,\"86\":2,\"92\":2,\"116\":2,\"117\":4,\"205\":1,\"212\":4}}],[\"preview\",{\"1\":{\"134\":2}}],[\"prefix\",{\"1\":{\"117\":1}}],[\"predicate对象可以赋值给\",{\"1\":{\"102\":1}}],[\"predicate工厂可以进行组合\",{\"1\":{\"102\":1}}],[\"predicate工厂\",{\"1\":{\"102\":1}}],[\"predicate\",{\"1\":{\"102\":2}}],[\"predicates\",{\"1\":{\"101\":4,\"102\":2,\"106\":1,\"107\":1}}],[\"pre\",{\"1\":{\"100\":2}}],[\"product服务中的pom\",{\"1\":{\"165\":1}}],[\"property\",{\"1\":{\"83\":2}}],[\"properties>\",{\"1\":{\"52\":1,\"53\":1}}],[\"projectlombok<\",{\"1\":{\"53\":1,\"93\":1}}],[\"project\",{\"1\":{\"52\":1,\"53\":1}}],[\"patternproperties\",{\"1\":{\"117\":5,\"149\":1}}],[\"pattern\",{\"1\":{\"116\":3,\"117\":3}}],[\"path=\",{\"1\":{\"101\":2,\"102\":1,\"106\":1,\"107\":1}}],[\"pathvariable\",{\"1\":{\"86\":1,\"106\":1,\"116\":1,\"117\":1,\"149\":1}}],[\"param\",{\"1\":{\"83\":2}}],[\"parent下创建子模块spzx\",{\"1\":{\"101\":1}}],[\"parent>\",{\"1\":{\"52\":1}}],[\"parent<\",{\"1\":{\"52\":1}}],[\"package\",{\"1\":{\"53\":1}}],[\"password\",{\"1\":{\"53\":1,\"134\":1,\"161\":1}}],[\"0=0\",{\"1\":{\"221\":2}}],[\"02\",{\"0\":{\"154\":1}}],[\"0110\",{\"1\":{\"221\":1}}],[\"0111\",{\"1\":{\"221\":1}}],[\"01\",{\"0\":{\"152\":1,\"156\":1,\"168\":1,\"170\":1,\"172\":1,\"174\":1,\"176\":1,\"257\":1},\"1\":{\"107\":1}}],[\"0010\",{\"1\":{\"221\":2}}],[\"0011\",{\"1\":{\"221\":2}}],[\"0001\",{\"1\":{\"221\":4}}],[\"0000\",{\"1\":{\"221\":33}}],[\"00\",{\"1\":{\"102\":1,\"107\":1}}],[\"06\",{\"1\":{\"102\":1}}],[\"07\",{\"1\":{\"102\":2,\"107\":1}}],[\"0~1\",{\"1\":{\"72\":1}}],[\"0\",{\"1\":{\"52\":7,\"72\":1,\"93\":2,\"101\":9,\"102\":1,\"108\":1,\"134\":4,\"197\":2,\"203\":2,\"205\":4,\"206\":2,\"208\":1,\"209\":1,\"212\":6,\"213\":2,\"214\":1,\"215\":2,\"216\":1,\"219\":1,\"220\":1,\"221\":4,\"222\":1}}],[\"步骤如下\",{\"1\":{\"136\":1}}],[\"步骤分析\",{\"1\":{\"108\":1}}],[\"步骤\",{\"1\":{\"52\":1,\"71\":1,\"114\":1,\"139\":1,\"165\":1}}],[\"父工程搭建\",{\"0\":{\"52\":1}}],[\"远程调用\",{\"1\":{\"49\":1,\"86\":1}}],[\"⭐\",{\"1\":{\"131\":1}}],[\"⭐设置远程调用的超时时间\",{\"1\":{\"126\":1}}],[\"⭐我们最终的目的\",{\"1\":{\"118\":1}}],[\"⭐sentinel\",{\"1\":{\"49\":1}}],[\"⭐gateway\",{\"1\":{\"49\":1}}],[\"⭐loadbalancer\",{\"1\":{\"49\":1}}],[\"⭐openfeign\",{\"1\":{\"49\":1}}],[\"⭐nacos\",{\"1\":{\"49\":1}}],[\"genericjackson2jsonredisserializer\",{\"1\":{\"161\":4,\"165\":4}}],[\"getcapacity\",{\"1\":{\"206\":1,\"208\":1}}],[\"getcategory\",{\"1\":{\"205\":1}}],[\"getsize\",{\"1\":{\"205\":1,\"206\":1,\"208\":2}}],[\"getsize+getcapacity+isempty+isfull\",{\"1\":{\"205\":1}}],[\"getdateformat\",{\"1\":{\"117\":1,\"149\":1}}],[\"getorder\",{\"1\":{\"108\":1}}],[\"getrequiredattribute\",{\"1\":{\"109\":1}}],[\"getrequest\",{\"1\":{\"108\":1}}],[\"getresponse\",{\"1\":{\"108\":2}}],[\"getfilters\",{\"1\":{\"109\":1}}],[\"getfirst\",{\"1\":{\"108\":1}}],[\"getforobject\",{\"1\":{\"54\":1,\"65\":1,\"66\":1}}],[\"getqueryparams\",{\"1\":{\"108\":1}}],[\"getmapping\",{\"1\":{\"86\":1,\"106\":1,\"116\":1,\"117\":1,\"142\":1,\"143\":2,\"149\":1}}],[\"getlazyprovider\",{\"1\":{\"83\":1}}],[\"getproperty\",{\"1\":{\"83\":1}}],[\"getport\",{\"1\":{\"65\":1}}],[\"geturi\",{\"1\":{\"81\":1}}],[\"getuserid\",{\"1\":{\"54\":1,\"65\":1,\"66\":1,\"86\":1}}],[\"get\",{\"1\":{\"65\":1,\"86\":1,\"205\":1,\"211\":1}}],[\"getinstances\",{\"1\":{\"65\":1}}],[\"gethost\",{\"1\":{\"65\":1,\"81\":1}}],[\"guavacachemanager\",{\"1\":{\"159\":1}}],[\"go\",{\"1\":{\"131\":1}}],[\"goods\",{\"1\":{\"148\":1}}],[\"good\",{\"1\":{\"107\":1}}],[\"globalfilters\",{\"1\":{\"109\":1}}],[\"globalfilter\",{\"1\":{\"108\":1,\"109\":3}}],[\"gatewayfilterfactories\",{\"1\":{\"109\":1}}],[\"gatewayfilters\",{\"1\":{\"109\":2}}],[\"gatewayfilterchain\",{\"1\":{\"108\":1}}],[\"gatewayfilter\",{\"1\":{\"105\":1}}],[\"gateway提供了31种不同的过滤器\",{\"1\":{\"105\":1}}],[\"gateway包含许多内置的route\",{\"1\":{\"102\":1}}],[\"gateway包括许多内置的route\",{\"1\":{\"102\":1}}],[\"gateway创建route对象时\",{\"1\":{\"102\":1}}],[\"gateway将路由匹配作为spring\",{\"1\":{\"102\":1}}],[\"gatewayapplication\",{\"1\":{\"101\":2}}],[\"gateway<\",{\"1\":{\"101\":1}}],[\"gateway\",{\"1\":{\"101\":12,\"102\":3,\"105\":1,\"106\":1,\"107\":1,\"109\":2}}],[\"gateway发出请求\",{\"1\":{\"100\":1}}],[\"gateway网关底层使用\",{\"1\":{\"95\":1}}],[\"gateway组件\",{\"0\":{\"94\":1}}],[\"gatway是网关组件\",{\"1\":{\"95\":1}}],[\"gatway网关\",{\"1\":{\"49\":1}}],[\"github\",{\"1\":{\"85\":1,\"133\":1}}],[\"group都在同一个namespace\",{\"1\":{\"74\":1}}],[\"group\",{\"1\":{\"74\":1}}],[\"groupid>\",{\"1\":{\"52\":5,\"53\":4,\"63\":1,\"66\":1,\"86\":1,\"93\":4,\"101\":3,\"114\":1,\"136\":1,\"161\":2,\"165\":1}}],[\"grow\",{\"1\":{\"21\":1,\"212\":2}}],[\"green\",{\"1\":{\"21\":2}}],[\"腾讯组件\",{\"1\":{\"49\":1}}],[\"目前最流行的组件\",{\"1\":{\"49\":1}}],[\"目录\",{\"0\":{\"41\":1}}],[\"不需要处理固定容量的问题\",{\"1\":{\"245\":1}}],[\"不需要额外的\",{\"1\":{\"131\":1}}],[\"不牵扯值得问题\",{\"1\":{\"217\":1}}],[\"不是一new底层就会创建初始容量为10的空列表\",{\"1\":{\"212\":1}}],[\"不支持new\",{\"1\":{\"206\":1}}],[\"不能删除空元素\",{\"1\":{\"205\":1}}],[\"不能增加元素\",{\"1\":{\"205\":1}}],[\"不能访问\",{\"1\":{\"98\":1}}],[\"不考虑冲突的话\",{\"1\":{\"193\":1}}],[\"不用实现业务\",{\"1\":{\"143\":1}}],[\"不要给另外的数组分配额外的空间\",{\"1\":{\"209\":1}}],[\"不要点击菜单中的执行按钮来运行\",{\"1\":{\"139\":1}}],[\"不要让其影响到其他的程序的运行\",{\"1\":{\"125\":1}}],[\"不依赖任何框架\",{\"1\":{\"131\":1}}],[\"不再调用执行熔断\",{\"1\":{\"126\":1}}],[\"不再更新\",{\"1\":{\"49\":1}}],[\"不利于后期代码维护在实际的工作过程中\",{\"1\":{\"93\":1}}],[\"不记录任何日志信息\",{\"1\":{\"89\":1}}],[\"不过会使用ribbon的重试\",{\"1\":{\"88\":1}}],[\"不会无休止等待\",{\"1\":{\"124\":1}}],[\"不会从服务列表剔除\",{\"1\":{\"77\":1}}],[\"不会考虑机器的性能问题\",{\"1\":{\"72\":1}}],[\"不同哈希值的对象\",{\"1\":{\"221\":1}}],[\"不同路由访问不同内容\",{\"1\":{\"97\":1}}],[\"不同模块\",{\"1\":{\"46\":1}}],[\"不同元素可以有相同的动画顺序\",{\"1\":{\"25\":1}}],[\"子框架\",{\"1\":{\"48\":1}}],[\"每次扩容的倍数是多少\",{\"1\":{\"212\":1}}],[\"每找一次排除一半的可能\",{\"1\":{\"193\":1}}],[\"每个节点只有一个后续节点\",{\"1\":{\"243\":1}}],[\"每个节点只有一个前驱节点\",{\"1\":{\"243\":1}}],[\"每个存储单元都有一个唯一的地址\",{\"1\":{\"180\":1}}],[\"每个存储单元可以存储一个固定大小的数据块\",{\"1\":{\"180\":1}}],[\"每个缓存名称下面可以有很多key\",{\"1\":{\"163\":1}}],[\"每个缓存名称下面可以有多个key\",{\"1\":{\"161\":1,\"164\":1}}],[\"每个服务做到对应唯一业务能力\",{\"1\":{\"46\":1}}],[\"每个服务模块独立运行\",{\"1\":{\"46\":1}}],[\"每1秒请求量不超过10\",{\"1\":{\"149\":1}}],[\"每1秒请求量不超过4\",{\"1\":{\"149\":1}}],[\"每1秒相同参数值的请求数不能超过2\",{\"1\":{\"148\":1}}],[\"每秒处理5个请求\",{\"1\":{\"130\":1}}],[\"每秒的请求数\",{\"1\":{\"127\":1}}],[\"每一种路由工厂的使用spring\",{\"1\":{\"102\":1}}],[\"每一个过滤器的功能都是固定的\",{\"1\":{\"108\":1}}],[\"每一个服务消费方要调用服务提供方\",{\"1\":{\"93\":1}}],[\"每一个服务注册到nacos注册中心都需要提供一个服务名称\",{\"1\":{\"63\":1}}],[\"每一个机房的服务可以看做成是一个集群\",{\"1\":{\"69\":1}}],[\"每一个组件都是用来解决问题架构中所遇到的问题\",{\"1\":{\"48\":1}}],[\"每台服务器放的不同内容\",{\"1\":{\"46\":1}}],[\"分治\",{\"1\":{\"191\":1}}],[\"分块查找\",{\"1\":{\"190\":1}}],[\"分散存储\",{\"1\":{\"180\":1}}],[\"分为两个部分\",{\"1\":{\"131\":1}}],[\"分为两部分\",{\"1\":{\"131\":1}}],[\"分布式\",{\"1\":{\"46\":1}}],[\"分担服务器访问压力\",{\"1\":{\"46\":1}}],[\"分割垂直幻灯片\",{\"1\":{\"3\":1}}],[\"多态\",{\"1\":{\"207\":1}}],[\"多维数组\",{\"1\":{\"183\":1}}],[\"多次调用都是失败\",{\"1\":{\"126\":1}}],[\"多种谓词工厂可以组合\",{\"1\":{\"102\":1}}],[\"多个route\",{\"1\":{\"102\":1}}],[\"多个动画片段\",{\"0\":{\"23\":1}}],[\"多台服务器上面部署不同内容模块\",{\"1\":{\"46\":1}}],[\"多台服务器上部署相同的项目\",{\"1\":{\"46\":1}}],[\"负载均衡组件\",{\"1\":{\"101\":1}}],[\"负载均衡算法\",{\"0\":{\"82\":1}}],[\"负载均衡就是负载请求通过多台服务器进行处理\",{\"1\":{\"55\":1}}],[\"负载均衡\",{\"1\":{\"46\":1,\"49\":1}}],[\"服务端口\",{\"1\":{\"134\":1}}],[\"服务和服务之间的稳定性变得越来越重要\",{\"1\":{\"131\":1}}],[\"服务降级\",{\"1\":{\"124\":1}}],[\"服务间调用关系错综复杂\",{\"1\":{\"122\":1}}],[\"服务间的通讯\",{\"1\":{\"46\":1}}],[\"服务不可用等\",{\"1\":{\"92\":1}}],[\"服务器每秒能处理的请求数量\",{\"1\":{\"129\":1}}],[\"服务器在压力过大的情况下会发生宕机\",{\"1\":{\"127\":1}}],[\"服务器数量=\",{\"1\":{\"82\":1}}],[\"服务器设备性能有差异\",{\"1\":{\"72\":1}}],[\"服务集群\",{\"0\":{\"67\":1}}],[\"服务消费方向服务注册中心咨询服务\",{\"1\":{\"58\":1}}],[\"服务提供方的服务ip地址和端口号可以使用服务提供方的服务名称进行替换\",{\"1\":{\"66\":1}}],[\"服务提供方在启动的时候\",{\"1\":{\"58\":1}}],[\"服务提供唯一标准的接口\",{\"1\":{\"46\":1}}],[\"服务方提供ip地址发生改变\",{\"1\":{\"55\":1}}],[\"服务保护组件\",{\"1\":{\"49\":1}}],[\"服务网关\",{\"1\":{\"49\":1}}],[\"堵路部署和交付\",{\"1\":{\"46\":1}}],[\"团队独立\",{\"1\":{\"46\":1}}],[\"单向链表\",{\"1\":{\"243\":1}}],[\"单一职责\",{\"1\":{\"46\":1}}],[\"单体架构\",{\"1\":{\"45\":1}}],[\"灵活性强\",{\"1\":{\"46\":1}}],[\"谁修改某个服务\",{\"1\":{\"46\":1}}],[\"i就是索引\",{\"1\":{\"221\":1}}],[\"illegal\",{\"1\":{\"212\":1,\"215\":2}}],[\"illegalargumentexception\",{\"1\":{\"212\":1,\"215\":2}}],[\"i>index\",{\"1\":{\"206\":1}}],[\"i>=index\",{\"1\":{\"205\":1}}],[\"i<size\",{\"1\":{\"205\":2}}],[\"i+1\",{\"1\":{\"205\":1,\"206\":1}}],[\"i++\",{\"1\":{\"203\":1,\"205\":2,\"208\":1}}],[\"i=size\",{\"1\":{\"205\":1}}],[\"i\",{\"1\":{\"203\":7,\"205\":7,\"206\":3,\"208\":4,\"219\":1,\"221\":6}}],[\"istackdesc栈接口\",{\"0\":{\"232\":1}}],[\"isnan\",{\"1\":{\"215\":1}}],[\"isfull\",{\"1\":{\"205\":2,\"206\":2}}],[\"isempty\",{\"1\":{\"205\":2,\"206\":1}}],[\"isdebugenabled\",{\"1\":{\"109\":1}}],[\"is\",{\"1\":{\"107\":1,\"212\":2}}],[\"io\",{\"1\":{\"102\":1,\"105\":1,\"131\":1}}],[\"id指的是user的id属性\",{\"1\":{\"163\":1}}],[\"id值不为1的请求不受影响\",{\"1\":{\"148\":1}}],[\"id参数值会有变化\",{\"1\":{\"148\":1}}],[\"id=spzx\",{\"1\":{\"101\":2}}],[\"id\",{\"1\":{\"101\":2,\"102\":1,\"106\":1,\"107\":1,\"148\":1,\"163\":2}}],[\"if\",{\"1\":{\"92\":1,\"108\":1,\"109\":1,\"205\":7,\"206\":2,\"208\":1,\"212\":6,\"215\":3,\"219\":1,\"220\":3,\"221\":1,\"222\":3}}],[\"ip\",{\"1\":{\"58\":1}}],[\"ibatis\",{\"1\":{\"53\":1}}],[\"import\",{\"1\":{\"114\":1}}],[\"implements\",{\"1\":{\"65\":1,\"86\":1,\"92\":1,\"108\":1,\"217\":1}}],[\"implement\",{\"1\":{\"54\":1}}],[\"impl\",{\"1\":{\"53\":1}}],[\"image\",{\"1\":{\"46\":4,\"51\":1,\"53\":2,\"54\":1,\"55\":3,\"58\":2,\"60\":1,\"61\":1,\"63\":1,\"69\":2,\"70\":3,\"72\":2,\"74\":2,\"75\":1,\"76\":1,\"79\":1,\"80\":1,\"81\":2,\"85\":2,\"91\":1,\"93\":1,\"100\":1,\"101\":3,\"102\":2,\"104\":1,\"109\":1,\"111\":1,\"113\":2,\"118\":1,\"122\":1,\"124\":1,\"125\":2,\"126\":2,\"127\":1,\"131\":2,\"133\":2,\"135\":2,\"136\":1,\"138\":1,\"139\":6,\"141\":1,\"142\":7,\"143\":9,\"144\":1,\"145\":6,\"146\":6,\"148\":4,\"149\":3}}],[\"initial\",{\"1\":{\"213\":1,\"215\":1,\"220\":1}}],[\"initialcapacity直接等于最大容器\",{\"1\":{\"215\":1}}],[\"initialcapacity\",{\"1\":{\"212\":6,\"215\":8}}],[\"increments\",{\"1\":{\"212\":1}}],[\"info\",{\"1\":{\"106\":1,\"116\":1,\"117\":1,\"149\":1,\"161\":1,\"163\":1,\"164\":1}}],[\"instanceindex\",{\"1\":{\"65\":2}}],[\"instances\",{\"1\":{\"65\":3}}],[\"integer\",{\"1\":{\"220\":1}}],[\"interface接口里面写什么类型方法\",{\"0\":{\"223\":1}}],[\"interface\",{\"1\":{\"86\":1}}],[\"ints\",{\"1\":{\"203\":7}}],[\"int\",{\"1\":{\"65\":2,\"92\":2,\"108\":1,\"197\":3,\"203\":4,\"205\":30,\"206\":8,\"208\":3,\"209\":1,\"211\":5,\"212\":9,\"215\":2,\"216\":3,\"217\":2,\"219\":1,\"222\":1}}],[\"index+1\",{\"1\":{\"205\":1}}],[\"index<0||index>=size\",{\"1\":{\"205\":2,\"206\":1}}],[\"index<0||index>size\",{\"1\":{\"205\":2}}],[\"index\",{\"1\":{\"25\":1,\"205\":12,\"206\":3,\"211\":4}}],[\"in\",{\"1\":{\"19\":3}}],[\"inline\",{\"1\":{\"7\":1}}],[\"独立部署\",{\"1\":{\"46\":1}}],[\"按照逆序打印\",{\"1\":{\"205\":1}}],[\"按照正序打印\",{\"1\":{\"205\":1}}],[\"按照下标index获取元素get\",{\"1\":{\"205\":1}}],[\"按照下标index设置元素\",{\"1\":{\"205\":1}}],[\"按照order的值进行排序\",{\"1\":{\"109\":1}}],[\"按照特定的方式实现特定功能就是算法\",{\"1\":{\"82\":1}}],[\"按照功能拆分成多个独立的服务模块\",{\"1\":{\"46\":1}}],[\"按下\",{\"1\":{\"34\":1,\"36\":1,\"38\":1}}],[\"把书组织放到新数组里面\",{\"1\":{\"208\":1}}],[\"把一部分的请求统计到了下一秒中导致的\",{\"1\":{\"139\":1}}],[\"把一个完整项目\",{\"1\":{\"46\":1}}],[\"把多个为服务模块中相同配置\",{\"1\":{\"110\":1}}],[\"把之前的缓存删除\",{\"1\":{\"69\":1}}],[\"把项目中所有功能模块全部写在一个工程中\",{\"1\":{\"45\":1}}],[\"微服务中无需重启即可让配置生效\",{\"1\":{\"118\":1}}],[\"微服务需要进行改造\",{\"1\":{\"114\":1}}],[\"微服务集成配置中心\",{\"0\":{\"114\":1}}],[\"微服务互相访问时\",{\"1\":{\"69\":1}}],[\"微服务的管理\",{\"1\":{\"46\":1}}],[\"微服务架构\",{\"1\":{\"46\":1}}],[\"微小服务\",{\"1\":{\"46\":1}}],[\"易于维护\",{\"1\":{\"45\":1}}],[\"结构设计一个队列\",{\"0\":{\"238\":1}}],[\"结构简单\",{\"1\":{\"45\":1}}],[\"结果是32\",{\"1\":{\"216\":1}}],[\"结果是8\",{\"1\":{\"216\":1}}],[\"结果是4\",{\"1\":{\"216\":1}}],[\"结果还是4\",{\"1\":{\"216\":1}}],[\"结果还是2\",{\"1\":{\"216\":1}}],[\"结束\",{\"0\":{\"39\":1}}],[\"风险高\",{\"1\":{\"45\":1}}],[\"拓展性差\",{\"1\":{\"45\":1}}],[\"牵一发动全身\",{\"1\":{\"45\":1}}],[\"禁用展示\",{\"1\":{\"41\":1}}],[\"展示\",{\"1\":{\"41\":1}}],[\"的空列表\",{\"1\":{\"212\":1}}],[\"的额外空间解决这一问题\",{\"1\":{\"209\":1}}],[\"的形式给出\",{\"1\":{\"209\":1}}],[\"的时间复杂度\",{\"1\":{\"193\":1}}],[\"的算法\",{\"1\":{\"193\":1}}],[\"的请求中\",{\"1\":{\"148\":1}}],[\"的历史\",{\"1\":{\"131\":1}}],[\"的超时机制是指在使用\",{\"1\":{\"91\":1}}],[\"的同时点击幻灯片的任何元素\",{\"1\":{\"38\":1}}],[\"的段落\",{\"1\":{\"6\":1}}],[\"oldthr\",{\"1\":{\"220\":1}}],[\"oldtab\",{\"1\":{\"220\":1}}],[\"oldcap\",{\"1\":{\"220\":4}}],[\"oldcapacity\",{\"1\":{\"212\":3}}],[\"other\",{\"1\":{\"214\":1}}],[\"overflow\",{\"1\":{\"212\":2}}],[\"override\",{\"1\":{\"54\":1,\"65\":1,\"86\":1,\"92\":2,\"108\":2,\"161\":1}}],[\"object\",{\"1\":{\"206\":1,\"208\":2,\"211\":1,\"212\":3}}],[\"o后面的括号中有一个函数\",{\"1\":{\"193\":1}}],[\"onecategorylist\",{\"1\":{\"165\":1}}],[\"ofseconds\",{\"1\":{\"161\":1,\"165\":1}}],[\"openfeign日志级别配置\",{\"1\":{\"89\":2}}],[\"openfeign可以支持很多的自定义配置\",{\"1\":{\"88\":1}}],[\"openfeign<\",{\"1\":{\"86\":1,\"93\":1}}],[\"openfeign的使用步骤如下\",{\"1\":{\"86\":1}}],[\"openfeign\",{\"1\":{\"85\":1,\"89\":2,\"91\":1,\"92\":1}}],[\"openfeign组件\",{\"0\":{\"84\":1}}],[\"originaluri\",{\"1\":{\"81\":1}}],[\"order的值越小\",{\"1\":{\"109\":1}}],[\"order的application\",{\"1\":{\"76\":1}}],[\"ordered\",{\"1\":{\"108\":1}}],[\"orderapplication\",{\"1\":{\"93\":2}}],[\"order中编写的userfeginclient\",{\"1\":{\"93\":1}}],[\"order服务的pom文件中引入openfeign的依赖\",{\"1\":{\"86\":1}}],[\"order微服务引入spzx\",{\"1\":{\"93\":1}}],[\"order微服务和spzx\",{\"1\":{\"93\":2}}],[\"order微服务在loadbalancer组件中集成nacos\",{\"1\":{\"71\":1}}],[\"order微服务注册的时候需要更改微服务名称\",{\"1\":{\"63\":1}}],[\"orderid\",{\"1\":{\"54\":2,\"65\":2,\"86\":2}}],[\"ordermapper\",{\"1\":{\"54\":3,\"65\":3,\"86\":3}}],[\"orderservice\",{\"1\":{\"54\":1,\"65\":1,\"86\":1}}],[\"orderserviceimpl\",{\"1\":{\"54\":1,\"65\":1,\"86\":1}}],[\"order\",{\"1\":{\"54\":6,\"63\":1,\"65\":6,\"66\":1,\"86\":6,\"89\":2,\"92\":1,\"93\":1,\"98\":1,\"101\":6}}],[\"org\",{\"1\":{\"53\":1,\"109\":1,\"139\":1}}],[\"o\",{\"1\":{\"34\":1,\"193\":8,\"194\":1,\"209\":1,\"211\":1}}],[\"out的异常\",{\"1\":{\"92\":1}}],[\"out\",{\"1\":{\"19\":3,\"102\":1,\"143\":2,\"203\":3,\"208\":1}}],[\"或存储在分散的内存单元中\",{\"1\":{\"180\":1}}],[\"或之后\",{\"1\":{\"100\":1}}],[\"或\",{\"1\":{\"34\":1,\"36\":1}}],[\"equals\",{\"1\":{\"222\":1}}],[\"else\",{\"1\":{\"212\":2,\"220\":1,\"222\":1}}],[\"elementdata\",{\"1\":{\"212\":15}}],[\"element\",{\"1\":{\"3\":1,\"211\":2}}],[\"empty\",{\"1\":{\"212\":3}}],[\"e只能先创建一个object类型的\",{\"1\":{\"206\":1}}],[\"ehcache\",{\"1\":{\"161\":1}}],[\"ehcachecachemanager\",{\"1\":{\"159\":1}}],[\"err\",{\"1\":{\"143\":2}}],[\"exchange\",{\"1\":{\"108\":5,\"109\":3}}],[\"execute\",{\"1\":{\"81\":1}}],[\"ephemeral\",{\"1\":{\"77\":1}}],[\"ensureexplicitcapacity\",{\"1\":{\"212\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"212\":2}}],[\"entry<k\",{\"1\":{\"217\":1}}],[\"entryttl\",{\"1\":{\"161\":1,\"165\":1}}],[\"entity\",{\"1\":{\"53\":1}}],[\"envoy\",{\"1\":{\"131\":1}}],[\"environment\",{\"1\":{\"83\":4}}],[\"endpoint\",{\"1\":{\"138\":1}}],[\"end\",{\"1\":{\"92\":2}}],[\"encoder\",{\"1\":{\"88\":1}}],[\"enablecaching\",{\"1\":{\"160\":2,\"161\":1,\"165\":1}}],[\"enableconfigurationproperties\",{\"1\":{\"117\":1}}],[\"enableconfigurationproperties注解\",{\"1\":{\"117\":1}}],[\"enablefeignclients这个注解中\",{\"1\":{\"90\":1}}],[\"enablefeignclients\",{\"1\":{\"86\":1,\"90\":1,\"93\":1}}],[\"enabled=true\",{\"1\":{\"101\":1}}],[\"enabled\",{\"1\":{\"71\":1,\"101\":1}}],[\"e\",{\"0\":{\"242\":1},\"1\":{\"61\":1,\"92\":2,\"205\":18,\"206\":12,\"208\":4,\"211\":7,\"212\":3,\"222\":3}}],[\"eurela\",{\"0\":{\"60\":1}}],[\"esc\",{\"1\":{\"34\":1}}],[\"+出栈removelast\",{\"1\":{\"229\":1}}],[\"++bincount\",{\"1\":{\"222\":1}}],[\"++\",{\"1\":{\"205\":1}}],[\"+i+\",{\"1\":{\"203\":2}}],[\"+order\",{\"1\":{\"54\":1}}],[\"+\",{\"1\":{\"32\":2,\"65\":5,\"66\":1,\"74\":1,\"109\":1,\"212\":3,\"215\":2,\"216\":1}}],[\"x的版本新增了一个客户端与服务端的grpc的通讯端口号9848\",{\"1\":{\"61\":1}}],[\"xml文件中添加依赖\",{\"1\":{\"165\":1}}],[\"xml文件中添加如下依赖\",{\"1\":{\"161\":1}}],[\"xml\",{\"1\":{\"53\":1}}],[\"x\",{\"0\":{\"194\":1},\"1\":{\"32\":2,\"194\":1}}],[\"语法说明\",{\"1\":{\"142\":1}}],[\"语法来分布高亮特定行\",{\"1\":{\"32\":1}}],[\"语法的各种标记\",{\"1\":{\"4\":1,\"5\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1}}],[\"功能\",{\"0\":{\"30\":1,\"31\":1,\"33\":1,\"35\":1,\"37\":1}}],[\"可能部分商品是热点商品\",{\"1\":{\"148\":1}}],[\"可能导致服务瞬间宕机\",{\"1\":{\"145\":1}}],[\"可能会存在很多个软件环境\",{\"1\":{\"74\":1}}],[\"可能的值\",{\"1\":{\"27\":1}}],[\"可拓展性好\",{\"1\":{\"46\":1}}],[\"可以查看到sentinel的簇点链路规则中\",{\"1\":{\"143\":1}}],[\"可以发现\",{\"1\":{\"142\":1}}],[\"可以选择三种流控模式\",{\"1\":{\"141\":1}}],[\"可以看到我们标记的hot资源出现了\",{\"1\":{\"149\":1}}],[\"可以看到这里200个线程\",{\"1\":{\"143\":1}}],[\"可以看到这里的intercept方法\",{\"1\":{\"81\":1}}],[\"可以看到1000个线程\",{\"1\":{\"142\":1}}],[\"可以看到\",{\"1\":{\"139\":1}}],[\"可以通过下列配置\",{\"1\":{\"134\":1}}],[\"可以通过配置中的\",{\"1\":{\"27\":1}}],[\"可以集中管理所有实例的配置\",{\"1\":{\"111\":1}}],[\"可以对进入网关的请求和微服务返回的响应做处理\",{\"1\":{\"104\":1}}],[\"可以自定义\",{\"1\":{\"101\":1}}],[\"可以及时给出错误提示或进行相应的处理\",{\"1\":{\"91\":1}}],[\"可以避免客户端在请求服务时长时间等待响应而导致的性能问题\",{\"1\":{\"91\":1}}],[\"可以从discoveryclient或者其他注册中心中获取可用的服务实例列表\",{\"1\":{\"83\":1}}],[\"可以启动多个user微服务实例进行负载均衡的测试\",{\"1\":{\"65\":1}}],[\"可以使用不同的语言\",{\"1\":{\"46\":1}}],[\"可以使用不同的数据库\",{\"1\":{\"46\":1}}],[\"可靠性差\",{\"1\":{\"45\":1}}],[\"第3版mylinkedlistv3\",{\"0\":{\"253\":1}}],[\"第2版mylinkedlistv2\",{\"0\":{\"252\":1}}],[\"第1版mylinkedlistv1\",{\"0\":{\"250\":1}}],[\"第1秒同时接收到10个请求\",{\"1\":{\"146\":1}}],[\"第12个请求的预期等待时长\",{\"1\":{\"146\":1}}],[\"第6个请求的预期等待时长\",{\"1\":{\"146\":1}}],[\"第四步\",{\"1\":{\"54\":1,\"69\":1}}],[\"第三步\",{\"1\":{\"54\":1,\"69\":1}}],[\"第二次查询的时候由于redis中已经存在了数据\",{\"1\":{\"161\":1}}],[\"第二部分\",{\"1\":{\"131\":1}}],[\"第二步\",{\"1\":{\"54\":1,\"69\":1}}],[\"第二个显示\",{\"1\":{\"25\":2}}],[\"第一次扩容\",{\"1\":{\"213\":1}}],[\"第一次查询时候会打印日志\",{\"1\":{\"161\":1}}],[\"第一个参数\",{\"1\":{\"148\":1}}],[\"第一个显示\",{\"1\":{\"25\":1}}],[\"第一部分\",{\"1\":{\"131\":1}}],[\"第一步\",{\"1\":{\"54\":1,\"69\":1}}],[\"属性局部设置\",{\"1\":{\"27\":1}}],[\"属性改变元素的动画顺序\",{\"1\":{\"25\":1}}],[\"属性自定义幻灯片背景\",{\"1\":{\"15\":1}}],[\"顺序查找\",{\"1\":{\"190\":1}}],[\"顺序\",{\"0\":{\"25\":1}}],[\"渐变\",{\"0\":{\"26\":1,\"27\":1,\"28\":1}}],[\"渐出\",{\"1\":{\"23\":1}}],[\"渐入\",{\"1\":{\"23\":1}}],[\"变红\",{\"1\":{\"23\":1}}],[\"table\",{\"1\":{\"219\":1}}],[\"tablesizefor方法分析\",{\"0\":{\"216\":1}}],[\"tablesizefor\",{\"1\":{\"215\":2,\"216\":1}}],[\"tab\",{\"1\":{\"219\":4,\"221\":3,\"222\":1}}],[\"target>\",{\"1\":{\"52\":1,\"53\":1}}],[\"target>17<\",{\"1\":{\"52\":1,\"53\":1}}],[\"to\",{\"1\":{\"212\":1}}],[\"tomcat\",{\"1\":{\"131\":1}}],[\"tmp\",{\"1\":{\"209\":1}}],[\"timed\",{\"1\":{\"92\":1}}],[\"timeout\",{\"1\":{\"91\":2,\"92\":2,\"146\":1}}],[\"threshold\",{\"1\":{\"213\":2,\"215\":1,\"220\":2,\"222\":1}}],[\"threadlocal\",{\"2\":{\"166\":1}}],[\"throw\",{\"1\":{\"92\":1,\"205\":6,\"212\":1,\"215\":2}}],[\"this\",{\"1\":{\"81\":1,\"109\":1,\"205\":1,\"206\":1,\"212\":4,\"214\":1,\"215\":2,\"217\":4}}],[\"then\",{\"1\":{\"19\":2}}],[\"treeifybin\",{\"1\":{\"222\":1}}],[\"treeify\",{\"1\":{\"213\":2,\"222\":1}}],[\"transient\",{\"1\":{\"212\":1}}],[\"transition\",{\"1\":{\"27\":3}}],[\"transport\",{\"1\":{\"136\":1}}],[\"truth\",{\"1\":{\"106\":1,\"116\":1,\"117\":1,\"149\":1}}],[\"truth=atguigu\",{\"1\":{\"106\":1}}],[\"true\",{\"1\":{\"71\":1,\"101\":1,\"205\":1,\"212\":1,\"218\":1}}],[\"type\",{\"1\":{\"53\":1}}],[\"type>\",{\"1\":{\"52\":2}}],[\"text\",{\"1\":{\"12\":1}}],[\"tex\",{\"1\":{\"9\":1}}],[\"lb就是负载均衡\",{\"1\":{\"101\":1}}],[\"lb\",{\"1\":{\"101\":2,\"102\":1,\"106\":1,\"107\":1}}],[\"list1\",{\"1\":{\"212\":1}}],[\"list\",{\"1\":{\"212\":2}}],[\"list<category>\",{\"1\":{\"165\":1}}],[\"list<gatewayfilter>\",{\"1\":{\"109\":2}}],[\"list<serviceinstance>\",{\"1\":{\"65\":1}}],[\"linux\",{\"1\":{\"38\":1}}],[\"loitering\",{\"0\":{\"234\":1}}],[\"loadfactor=0\",{\"1\":{\"214\":1}}],[\"loadfactor\",{\"1\":{\"214\":1,\"215\":7}}],[\"load\",{\"1\":{\"213\":1,\"214\":2,\"215\":1}}],[\"loadbalanced\",{\"1\":{\"66\":2,\"83\":1}}],[\"loadbalancerclient\",{\"1\":{\"83\":1}}],[\"loadbalancerclients\",{\"1\":{\"83\":1}}],[\"loadbalancerclientfactory\",{\"1\":{\"83\":5}}],[\"loadbalancer默认的负载均衡算法是roundrobinloadbalancer\",{\"1\":{\"83\":1}}],[\"loadbalancer是blockingloadbalancerclient类型\",{\"1\":{\"81\":1}}],[\"loadbalancer是spring\",{\"1\":{\"79\":1}}],[\"loadbalancerinterceptor\",{\"1\":{\"81\":1}}],[\"loadbalancer的执行流程\",{\"0\":{\"80\":1}}],[\"loadbalancer\",{\"0\":{\"78\":1},\"1\":{\"71\":1,\"81\":1}}],[\"loadbalancer<\",{\"1\":{\"66\":1,\"101\":1}}],[\"loadbalancer负载均衡\",{\"1\":{\"66\":1}}],[\"long\",{\"1\":{\"54\":1,\"65\":1,\"86\":3,\"106\":1,\"116\":1,\"117\":1,\"149\":1,\"161\":1,\"164\":1}}],[\"locator\",{\"1\":{\"101\":2}}],[\"locations\",{\"1\":{\"53\":1}}],[\"localhost\",{\"1\":{\"53\":1,\"54\":2,\"63\":1,\"101\":1,\"135\":1,\"136\":2}}],[\"logn\",{\"1\":{\"193\":3}}],[\"loggerlevel\",{\"1\":{\"89\":2,\"91\":1,\"92\":1}}],[\"logger\",{\"1\":{\"88\":1,\"90\":2,\"109\":2}}],[\"logging\",{\"1\":{\"53\":1,\"89\":2}}],[\"log\",{\"1\":{\"53\":1,\"106\":1,\"116\":1,\"117\":1,\"149\":1,\"161\":1,\"163\":1,\"164\":1}}],[\"logo\",{\"1\":{\"13\":1}}],[\"lombok依赖\",{\"1\":{\"53\":1,\"93\":1}}],[\"leetcode链表练习经典题\",{\"0\":{\"255\":1}}],[\"leetcode数组练习经典题\",{\"0\":{\"209\":1}}],[\"lenth\",{\"1\":{\"206\":1}}],[\"length\",{\"1\":{\"197\":2,\"203\":2,\"205\":2,\"206\":1,\"209\":1,\"212\":2,\"219\":2}}],[\"level的对象\",{\"1\":{\"90\":1}}],[\"level\",{\"1\":{\"88\":1,\"89\":2,\"90\":2}}],[\"lettuceconnectionfactory\",{\"1\":{\"161\":1,\"165\":1}}],[\"let\",{\"1\":{\"32\":3}}],[\"left++\",{\"1\":{\"209\":1}}],[\"left<right\",{\"1\":{\"209\":1}}],[\"left\",{\"1\":{\"19\":1,\"209\":4}}],[\"duration\",{\"1\":{\"161\":1,\"165\":1}}],[\"dubbo\",{\"1\":{\"131\":1}}],[\"dist\",{\"1\":{\"139\":1}}],[\"discoveryclient\",{\"1\":{\"65\":4}}],[\"discovery\",{\"1\":{\"63\":1,\"70\":3,\"71\":1,\"72\":1,\"76\":1,\"77\":1,\"101\":4}}],[\"discovery<\",{\"1\":{\"63\":1,\"101\":1}}],[\"dashboard\",{\"1\":{\"131\":1,\"134\":4,\"136\":1}}],[\"dateformat\",{\"1\":{\"116\":2,\"117\":3,\"149\":1}}],[\"datasource\",{\"1\":{\"53\":1}}],[\"data\",{\"1\":{\"15\":1,\"25\":1,\"27\":1,\"29\":1,\"117\":1,\"160\":1,\"161\":2,\"202\":1,\"205\":12,\"206\":8,\"208\":3}}],[\"daimakuai\",{\"1\":{\"106\":1,\"107\":1}}],[\"demoprintarray\",{\"1\":{\"203\":1}}],[\"demo项目的pom\",{\"1\":{\"161\":1}}],[\"demo项目\",{\"1\":{\"161\":1}}],[\"demo项目中的查询用户方法\",{\"1\":{\"161\":1}}],[\"deletebyid\",{\"1\":{\"164\":1}}],[\"dev\",{\"1\":{\"114\":1}}],[\"denver\",{\"1\":{\"107\":1}}],[\"defaulted\",{\"1\":{\"214\":1}}],[\"defaultcapacity\",{\"1\":{\"212\":2}}],[\"defaultcacheconfig\",{\"1\":{\"161\":1,\"165\":1}}],[\"defaultconfiguration\",{\"1\":{\"90\":1}}],[\"defaultgatewayfilterchain\",{\"1\":{\"109\":1}}],[\"defaultfilter\",{\"1\":{\"109\":2}}],[\"defaultfeignconfiguration都复制到spzx\",{\"1\":{\"93\":1}}],[\"defaultfeignconfiguration\",{\"1\":{\"90\":3,\"93\":1}}],[\"default\",{\"1\":{\"89\":1,\"91\":1,\"92\":1,\"107\":1,\"212\":1,\"213\":2,\"214\":2,\"220\":1}}],[\"debug\",{\"1\":{\"89\":2,\"109\":1}}],[\"decoder\",{\"1\":{\"88\":1}}],[\"dependencymanagement>\",{\"1\":{\"52\":1}}],[\"dependency>\",{\"1\":{\"52\":4,\"53\":4,\"63\":1,\"66\":1,\"86\":1,\"93\":4,\"101\":3,\"114\":1,\"136\":1,\"161\":2,\"165\":1}}],[\"dependencies>\",{\"1\":{\"52\":1,\"53\":1}}],[\"dependencies<\",{\"1\":{\"52\":2}}],[\"dspring\",{\"1\":{\"70\":2}}],[\"dserver\",{\"1\":{\"70\":2,\"134\":1}}],[\"double\",{\"1\":{\"220\":1}}],[\"docs\",{\"1\":{\"102\":2,\"105\":2}}],[\"docker\",{\"1\":{\"61\":2}}],[\"docker安装nacos\",{\"1\":{\"61\":1}}],[\"down\",{\"1\":{\"19\":1}}],[\"driver\",{\"1\":{\"53\":2}}],[\"d\",{\"0\":{\"235\":1},\"1\":{\"32\":1,\"61\":1}}],[\"float\",{\"1\":{\"214\":1,\"215\":3}}],[\"for\",{\"1\":{\"203\":2,\"205\":3,\"206\":1,\"208\":1,\"209\":1,\"222\":2}}],[\"fromserializer\",{\"1\":{\"161\":2,\"165\":2}}],[\"fragment\",{\"1\":{\"17\":1,\"25\":1}}],[\"full\",{\"1\":{\"88\":1,\"89\":3,\"91\":1,\"92\":1}}],[\"feign的默认配置都抽取到一个spzx\",{\"1\":{\"93\":1}}],[\"feign一旦请求超时了\",{\"1\":{\"92\":1}}],[\"feign默认的超时配置为\",{\"1\":{\"91\":1}}],[\"feignloglevel\",{\"1\":{\"90\":1}}],[\"feign\",{\"1\":{\"88\":5,\"89\":2,\"91\":3,\"92\":1,\"93\":5}}],[\"feign就可以帮助我们发送http请求\",{\"1\":{\"86\":1}}],[\"feignclientretryer\",{\"1\":{\"92\":3}}],[\"feignclient这个注解中\",{\"1\":{\"90\":1}}],[\"feignclient\",{\"1\":{\"86\":1,\"90\":1}}],[\"feign其作用就是帮助我们优雅的实现http请求的发送\",{\"1\":{\"85\":1}}],[\"feign是一个声明式的http客户端\",{\"1\":{\"85\":1}}],[\"factor\",{\"1\":{\"213\":1,\"214\":2,\"215\":1}}],[\"factories\",{\"1\":{\"102\":2,\"105\":1}}],[\"factory路由工厂举例\",{\"1\":{\"102\":1}}],[\"factory的getinstance方法做了两件事情\",{\"1\":{\"81\":1}}],[\"factory从nacos注册中心获取列表以及负载均衡算法实例对象\",{\"1\":{\"80\":1}}],[\"false\",{\"1\":{\"77\":1,\"143\":1,\"149\":1,\"205\":1,\"218\":1}}],[\"fade\",{\"1\":{\"19\":8,\"27\":1}}],[\"fields\",{\"1\":{\"214\":1}}],[\"final\",{\"1\":{\"214\":1,\"216\":1,\"217\":2}}],[\"fing\",{\"1\":{\"98\":1}}],[\"findallcategory\",{\"1\":{\"165\":1}}],[\"findbyid\",{\"1\":{\"161\":1}}],[\"find\",{\"1\":{\"98\":1}}],[\"findorderbyorderid\",{\"1\":{\"54\":2,\"65\":2,\"86\":2}}],[\"finduserbyuserid方法执行了\",{\"1\":{\"106\":1,\"116\":1,\"117\":1,\"149\":1}}],[\"finduserbyuserid\",{\"1\":{\"54\":2,\"65\":1,\"66\":1,\"81\":1,\"86\":2,\"101\":2,\"106\":3,\"116\":3,\"117\":3,\"136\":1,\"138\":1,\"139\":1,\"142\":4,\"145\":1,\"146\":1,\"149\":5}}],[\"filteringwebhandler\",{\"1\":{\"109\":1}}],[\"filters\",{\"1\":{\"106\":1,\"107\":1}}],[\"filter在\",{\"1\":{\"100\":1}}],[\"filter\",{\"1\":{\"95\":1,\"108\":2,\"109\":1}}],[\"fit\",{\"1\":{\"12\":1}}],[\"f11\",{\"1\":{\"36\":1}}],[\"f\",{\"1\":{\"36\":1}}],[\"break\",{\"1\":{\"222\":1}}],[\"bincount\",{\"1\":{\"222\":2}}],[\"binaries\",{\"1\":{\"139\":1}}],[\"boolean\",{\"1\":{\"205\":3,\"206\":2,\"211\":2,\"212\":1}}],[\"boot项目中\",{\"1\":{\"160\":1}}],[\"boot的web开发所需要的起步依赖\",{\"1\":{\"53\":1}}],[\"boot整合的起步依赖\",{\"1\":{\"52\":1,\"53\":1}}],[\"boot<\",{\"1\":{\"52\":2,\"53\":2,\"161\":2,\"165\":1}}],[\"boot父工程\",{\"1\":{\"52\":1}}],[\"boot\",{\"1\":{\"52\":5,\"53\":2,\"131\":1,\"161\":2,\"165\":1}}],[\"byte\",{\"1\":{\"180\":1}}],[\"b不限流\",{\"1\":{\"142\":1}}],[\"basepackages\",{\"1\":{\"93\":1}}],[\"basic\",{\"1\":{\"88\":1,\"89\":1,\"90\":1}}],[\"background\",{\"1\":{\"15\":1}}],[\"bean覆盖默认bean即可\",{\"1\":{\"88\":1}}],[\"bean\",{\"1\":{\"54\":1,\"66\":1,\"83\":2,\"90\":1,\"161\":1,\"165\":1}}],[\"builder\",{\"1\":{\"161\":1,\"165\":1}}],[\"build\",{\"1\":{\"52\":2,\"53\":2,\"161\":1,\"165\":1}}],[\"b\",{\"0\":{\"196\":1},\"1\":{\"32\":1}}],[\"b|c\",{\"1\":{\"32\":1}}],[\"blue\",{\"1\":{\"21\":2}}],[\"blockingloadbalancerclient\",{\"1\":{\"81\":1}}],[\"block\",{\"1\":{\"7\":1}}],[\"背景\",{\"0\":{\"15\":1}}],[\"使相同的\",{\"1\":{\"29\":1}}],[\"使它们填充满幻灯片垂直方向上的剩余空间\",{\"1\":{\"13\":1}}],[\"使用无参数构造方法创建hashmap对象\",{\"1\":{\"214\":1}}],[\"使用新容量\",{\"1\":{\"208\":1}}],[\"使用interface为了更加规范\",{\"1\":{\"207\":1}}],[\"使用下标位置索引十分高效的访问任意元素\",{\"1\":{\"199\":1}}],[\"使用空间换取时间\",{\"1\":{\"192\":2}}],[\"使用缓存技术只需在项目中导入相关缓存技术的依赖包\",{\"1\":{\"160\":1}}],[\"使用google的guavacache作为缓存技术\",{\"1\":{\"159\":1}}],[\"使用ehcache作为缓存技术\",{\"1\":{\"159\":1}}],[\"使用场景\",{\"1\":{\"142\":1}}],[\"使用java代码能实现sentinel使用\",{\"1\":{\"131\":1}}],[\"使用该实体类\",{\"1\":{\"117\":1}}],[\"使用redis作为缓存技术\",{\"1\":{\"159\":1,\"160\":1}}],[\"使用resttemplate进行远程调用代码回顾\",{\"1\":{\"85\":1}}],[\"使用routepredicatefactory创建predicate对象\",{\"1\":{\"102\":1}}],[\"使用feign客户端代替resttemplate\",{\"1\":{\"86\":1}}],[\"使用loadbalance\",{\"1\":{\"72\":1}}],[\"使用步骤\",{\"1\":{\"66\":1}}],[\"使用spring\",{\"1\":{\"66\":1,\"165\":1}}],[\"使用到spring\",{\"1\":{\"65\":1}}],[\"使用这些框架\",{\"1\":{\"56\":1}}],[\"使用这些组件可以实现微服务架构\",{\"1\":{\"48\":1}}],[\"使用父工程来管理多个微服务所需的依赖\",{\"1\":{\"51\":1}}],[\"使用大于两台服务器进行部署\",{\"1\":{\"46\":1}}],[\"使用指南\",{\"2\":{\"42\":1}}],[\"使用\",{\"1\":{\"3\":3,\"209\":1}}],[\"帮助你控制注入图片或视频的大小\",{\"1\":{\"13\":1}}],[\"s\",{\"1\":{\"209\":8}}],[\"saveuser\",{\"1\":{\"163\":1}}],[\"save和\",{\"1\":{\"143\":1}}],[\"save\",{\"1\":{\"143\":5}}],[\"slf4j\",{\"1\":{\"116\":1,\"117\":1}}],[\"slideend\",{\"1\":{\"39\":1}}],[\"slide\",{\"1\":{\"3\":1,\"27\":1}}],[\"slidestart\",{\"1\":{\"0\":1}}],[\"src\",{\"1\":{\"114\":1}}],[\"so\",{\"1\":{\"212\":1}}],[\"solution\",{\"1\":{\"209\":1}}],[\"sorted\",{\"1\":{\"109\":1}}],[\"sort\",{\"1\":{\"109\":1}}],[\"sourceencoding>\",{\"1\":{\"52\":1,\"53\":1}}],[\"sourceencoding>utf\",{\"1\":{\"52\":1,\"53\":1}}],[\"source>\",{\"1\":{\"52\":1,\"53\":1}}],[\"source>17<\",{\"1\":{\"52\":1,\"53\":1}}],[\"system\",{\"1\":{\"102\":1,\"143\":4,\"203\":3,\"208\":1}}],[\"snapshot<\",{\"1\":{\"93\":2}}],[\"shanghai\",{\"1\":{\"102\":1}}],[\"sh\",{\"1\":{\"70\":1,\"71\":1}}],[\"shrink\",{\"1\":{\"21\":1}}],[\"size++\",{\"1\":{\"206\":1,\"212\":1}}],[\"size=0\",{\"1\":{\"206\":1}}],[\"size==data\",{\"1\":{\"205\":1}}],[\"size==0\",{\"1\":{\"205\":1}}],[\"size实际个数\",{\"1\":{\"202\":1}}],[\"size\",{\"1\":{\"65\":3,\"205\":8,\"206\":6,\"211\":1,\"212\":3}}],[\"spzx\",{\"1\":{\"53\":2,\"54\":1,\"63\":1,\"65\":1,\"66\":1,\"81\":2,\"83\":1,\"86\":1,\"89\":3,\"90\":1,\"92\":1,\"93\":2,\"101\":9,\"102\":2,\"106\":2,\"107\":2,\"114\":1,\"161\":1,\"165\":1}}],[\"spring先查看缓存中是否有数据\",{\"1\":{\"161\":1}}],[\"springcache可以集成不同的缓存技术\",{\"1\":{\"161\":1}}],[\"springcloud<\",{\"1\":{\"93\":2}}],[\"springcloud实现微服务框架\",{\"1\":{\"56\":1}}],[\"springcloud实现微服务架构离不开springboot\",{\"1\":{\"48\":1}}],[\"springcloud远程调用\",{\"1\":{\"53\":1}}],[\"springcloud组件自己研发的组件\",{\"1\":{\"49\":1}}],[\"springcloud包含很多组件\",{\"1\":{\"49\":1}}],[\"springcloud是一系列框架集合\",{\"1\":{\"56\":1}}],[\"springcloud是一系列框架的有序集合\",{\"1\":{\"48\":1}}],[\"springcloud是一系列框架或者组件的集合\",{\"1\":{\"48\":1}}],[\"springcloud里面包含了很多组件和框架\",{\"1\":{\"48\":1}}],[\"springcloud并不是一种技术\",{\"1\":{\"48\":1}}],[\"springcloud初体验\",{\"0\":{\"47\":1}}],[\"springcloud\",{\"0\":{\"43\":1},\"1\":{\"57\":1}}],[\"spring基础\",{\"2\":{\"150\":1,\"166\":1}}],[\"springapplication\",{\"1\":{\"93\":1,\"101\":1,\"117\":1}}],[\"springframework\",{\"1\":{\"52\":2,\"53\":1,\"66\":1,\"86\":1,\"93\":1,\"101\":2,\"109\":1,\"161\":2,\"165\":1}}],[\"spring\",{\"0\":{\"158\":1,\"264\":1,\"265\":1,\"267\":1},\"1\":{\"49\":2,\"52\":11,\"53\":4,\"63\":1,\"66\":2,\"70\":1,\"71\":2,\"72\":1,\"76\":1,\"77\":1,\"79\":1,\"89\":2,\"91\":1,\"92\":1,\"101\":10,\"102\":7,\"105\":3,\"106\":1,\"107\":1,\"114\":1,\"131\":2,\"136\":1,\"143\":1,\"159\":2,\"161\":1}}],[\"springbootapplication\",{\"1\":{\"93\":1,\"101\":1,\"117\":1}}],[\"springboot\",{\"0\":{\"40\":1},\"1\":{\"56\":1}}],[\"secutiry\",{\"0\":{\"267\":1}}],[\"seconds\",{\"0\":{\"129\":1}}],[\"sentinel只监控controller方法\",{\"1\":{\"143\":1}}],[\"sentinelresource注解标记资源\",{\"1\":{\"149\":1}}],[\"sentinelresource\",{\"1\":{\"143\":2,\"149\":1}}],[\"sentinel<\",{\"1\":{\"136\":1}}],[\"sentinel是懒加载的\",{\"1\":{\"135\":1}}],[\"sentinel管理后台下载地址\",{\"1\":{\"133\":1}}],[\"sentinel入门\",{\"0\":{\"132\":1}}],[\"sentinel\",{\"1\":{\"131\":9,\"133\":1,\"134\":6,\"135\":1,\"136\":2,\"143\":1}}],[\"sentinelguard\",{\"1\":{\"131\":1}}],[\"sentinel介绍\",{\"0\":{\"131\":1}}],[\"sentinel部分\",{\"0\":{\"120\":1}}],[\"set\",{\"1\":{\"205\":1,\"211\":1}}],[\"setage\",{\"1\":{\"161\":1}}],[\"setcomplete\",{\"1\":{\"108\":1}}],[\"setstatuscode\",{\"1\":{\"108\":1}}],[\"setusername\",{\"1\":{\"161\":1}}],[\"setuser\",{\"1\":{\"65\":1,\"86\":1}}],[\"serializevalueswith\",{\"1\":{\"161\":1,\"165\":1}}],[\"serializekeyswith\",{\"1\":{\"161\":1,\"165\":1}}],[\"serializationpair\",{\"1\":{\"161\":2,\"165\":2}}],[\"service的feign的客户端\",{\"1\":{\"86\":1}}],[\"serviceinstancelistsupplier\",{\"1\":{\"83\":2}}],[\"serviceinstance\",{\"1\":{\"65\":8}}],[\"service\",{\"1\":{\"65\":1,\"86\":1,\"131\":2,\"138\":1}}],[\"serverwebexchangeutils\",{\"1\":{\"109\":1}}],[\"serverwebexchange\",{\"1\":{\"108\":1,\"109\":1}}],[\"server\",{\"1\":{\"53\":1,\"61\":2,\"63\":1,\"101\":4,\"114\":1,\"134\":1}}],[\"seruser\",{\"1\":{\"54\":1}}],[\"semi\",{\"1\":{\"19\":1}}],[\"scope>\",{\"1\":{\"52\":2}}],[\"static\",{\"1\":{\"93\":1,\"101\":1,\"117\":1,\"203\":1,\"212\":1,\"214\":1,\"216\":1,\"217\":1}}],[\"standalone\",{\"1\":{\"61\":1}}],[\"start++\",{\"1\":{\"92\":1}}],[\"start\",{\"1\":{\"92\":2}}],[\"startup\",{\"1\":{\"61\":1}}],[\"starter<\",{\"1\":{\"52\":1,\"53\":1}}],[\"starter\",{\"1\":{\"52\":1,\"53\":1,\"63\":1,\"86\":1,\"93\":1,\"101\":2,\"114\":2,\"136\":1,\"161\":2,\"165\":1}}],[\"stdoutimpl\",{\"1\":{\"53\":1}}],[\"stdout\",{\"1\":{\"53\":1}}],[\"stringredisserializer\",{\"1\":{\"161\":4,\"165\":4}}],[\"stringutils\",{\"1\":{\"108\":1}}],[\"string\",{\"1\":{\"65\":1,\"83\":1,\"93\":1,\"101\":1,\"106\":1,\"108\":1,\"116\":2,\"117\":4,\"142\":1,\"143\":2,\"149\":1,\"203\":1}}],[\"strike\",{\"1\":{\"21\":1}}],[\"stretch\",{\"1\":{\"13\":1}}],[\"cap\",{\"1\":{\"216\":2}}],[\"capacity\",{\"1\":{\"205\":2,\"206\":3,\"212\":2,\"213\":2,\"215\":4,\"216\":2,\"220\":3}}],[\"calculatecapacity\",{\"1\":{\"212\":2}}],[\"category\",{\"1\":{\"165\":1}}],[\"cache框架\",{\"1\":{\"165\":1}}],[\"cachedefaults\",{\"1\":{\"161\":1,\"165\":1}}],[\"cache<\",{\"1\":{\"161\":1,\"165\":1}}],[\"cacheevict\",{\"0\":{\"164\":1},\"1\":{\"160\":1,\"164\":2}}],[\"cacheput\",{\"0\":{\"163\":1},\"1\":{\"160\":1,\"163\":2}}],[\"cacheable\",{\"1\":{\"160\":1,\"161\":3,\"165\":2}}],[\"cachemanager\",{\"1\":{\"159\":1,\"161\":4,\"165\":4}}],[\"cachemanager是spring提供的各种缓存技术抽象接口\",{\"1\":{\"159\":1}}],[\"cache只是提供了一层抽象\",{\"1\":{\"159\":1}}],[\"cache是一个框架\",{\"1\":{\"159\":1}}],[\"cache\",{\"0\":{\"158\":1,\"264\":1},\"1\":{\"161\":4,\"165\":1},\"2\":{\"166\":1}}],[\"c++\",{\"1\":{\"131\":1}}],[\"cn\",{\"1\":{\"131\":1}}],[\"customloadbalancerconfiguration\",{\"1\":{\"83\":2}}],[\"current\",{\"1\":{\"21\":3}}],[\"char\",{\"1\":{\"209\":2}}],[\"characterencoding=utf8\",{\"1\":{\"53\":1}}],[\"chain\",{\"1\":{\"108\":2}}],[\"choose方法\",{\"1\":{\"81\":1}}],[\"chooseserviceinstance\",{\"1\":{\"65\":2}}],[\"cmd\",{\"1\":{\"61\":1}}],[\"cmd方式进入bin里面\",{\"1\":{\"61\":1}}],[\"cj\",{\"1\":{\"53\":1}}],[\"copyof\",{\"1\":{\"212\":2}}],[\"code\",{\"1\":{\"212\":2}}],[\"code实例\",{\"1\":{\"205\":1}}],[\"codec\",{\"1\":{\"88\":2}}],[\"coldfactor\",{\"1\":{\"145\":1}}],[\"combined\",{\"1\":{\"109\":5}}],[\"component\",{\"1\":{\"108\":1}}],[\"compiler\",{\"1\":{\"52\":4,\"53\":4}}],[\"com\",{\"1\":{\"53\":2,\"54\":1,\"85\":1,\"89\":2,\"92\":1,\"93\":1,\"101\":1,\"133\":1,\"161\":1,\"165\":1}}],[\"conscious\",{\"1\":{\"212\":2}}],[\"const\",{\"1\":{\"8\":1}}],[\"contain\",{\"1\":{\"205\":1}}],[\"context\",{\"1\":{\"143\":1}}],[\"continueorpropagate\",{\"1\":{\"92\":1}}],[\"contract\",{\"1\":{\"88\":1}}],[\"connectionfactory\",{\"1\":{\"161\":2,\"165\":2}}],[\"connect\",{\"1\":{\"91\":1,\"92\":1}}],[\"connector\",{\"1\":{\"52\":1,\"53\":1}}],[\"config<\",{\"1\":{\"114\":1}}],[\"config依赖\",{\"1\":{\"114\":1}}],[\"config\",{\"1\":{\"54\":1,\"89\":2,\"91\":1,\"92\":1,\"114\":3,\"161\":3,\"165\":3}}],[\"configurationproperties注解读取配置信息\",{\"1\":{\"118\":1}}],[\"configurationproperties注解读取自定义配置\",{\"1\":{\"117\":1}}],[\"configurationproperties\",{\"0\":{\"117\":1},\"1\":{\"117\":1}}],[\"configuration\",{\"1\":{\"53\":1,\"54\":1,\"83\":2,\"90\":1,\"161\":1,\"165\":1}}],[\"concave\",{\"1\":{\"27\":1}}],[\"convex\",{\"1\":{\"27\":1}}],[\"close\",{\"1\":{\"212\":1}}],[\"clone\",{\"1\":{\"92\":1}}],[\"cloud的官网都给出了具体的示例代码\",{\"1\":{\"102\":1}}],[\"cloud的依赖\",{\"1\":{\"52\":1}}],[\"cloud中用于创建负载均衡器的工厂类\",{\"1\":{\"83\":1}}],[\"cloud中负责客户端负载均衡的模块\",{\"1\":{\"79\":1}}],[\"cloud中所提供的一个组件\",{\"1\":{\"66\":1}}],[\"cloud中所提供的一个服务发现的客户端对象\",{\"1\":{\"65\":1}}],[\"cloud<\",{\"1\":{\"52\":2,\"63\":1,\"66\":1,\"86\":1,\"93\":1,\"101\":3,\"114\":1,\"136\":1}}],[\"cloud\",{\"1\":{\"49\":2,\"52\":9,\"53\":2,\"54\":1,\"63\":3,\"65\":1,\"66\":4,\"70\":4,\"71\":2,\"72\":2,\"76\":2,\"77\":1,\"79\":1,\"81\":2,\"83\":1,\"86\":3,\"89\":5,\"90\":1,\"91\":1,\"92\":2,\"93\":13,\"100\":1,\"101\":26,\"102\":8,\"105\":1,\"106\":7,\"107\":3,\"109\":1,\"114\":6,\"131\":1,\"136\":4,\"138\":1,\"143\":1}}],[\"client\",{\"1\":{\"89\":2,\"91\":1,\"92\":1}}],[\"cluster\",{\"1\":{\"70\":3,\"71\":1}}],[\"classpath\",{\"1\":{\"53\":1}}],[\"class\",{\"0\":{\"19\":1,\"21\":1},\"1\":{\"12\":1,\"13\":1,\"17\":1,\"53\":1,\"54\":3,\"65\":2,\"66\":1,\"83\":4,\"86\":1,\"90\":3,\"92\":1,\"93\":2,\"101\":2,\"108\":1,\"116\":1,\"117\":5,\"161\":1,\"165\":1,\"203\":1,\"205\":1,\"206\":1,\"209\":1,\"217\":1}}],[\"ctrl\",{\"1\":{\"38\":1}}],[\"c\",{\"0\":{\"226\":1},\"1\":{\"32\":2}}],[\"route\",{\"1\":{\"102\":2,\"109\":5}}],[\"routes\",{\"1\":{\"101\":7,\"102\":1,\"106\":1,\"107\":1}}],[\"roundrobinloadbalancer\",{\"1\":{\"81\":1}}],[\"root\",{\"1\":{\"53\":2}}],[\"randomloadbalancer\",{\"1\":{\"83\":2}}],[\"random\",{\"1\":{\"65\":4}}],[\"runtimeexcption\",{\"1\":{\"205\":1}}],[\"runtimeexception\",{\"1\":{\"92\":1,\"205\":5,\"206\":2}}],[\"run\",{\"1\":{\"61\":1,\"93\":1,\"101\":1,\"117\":1}}],[\"reversestring\",{\"1\":{\"209\":1}}],[\"removelast\",{\"1\":{\"205\":2}}],[\"remove\",{\"1\":{\"205\":4,\"206\":1,\"211\":2}}],[\"removefirst\",{\"1\":{\"205\":2}}],[\"removeresponseheader\",{\"1\":{\"105\":1}}],[\"removerequestheader\",{\"1\":{\"105\":1}}],[\"required\",{\"1\":{\"149\":1}}],[\"requestmapping\",{\"1\":{\"116\":1,\"117\":1}}],[\"requestheader\",{\"1\":{\"106\":1,\"116\":1,\"117\":1,\"149\":1}}],[\"requestratelimiter\",{\"1\":{\"105\":1}}],[\"request\",{\"1\":{\"81\":1,\"102\":1}}],[\"refreshscope\",{\"1\":{\"118\":1}}],[\"reference\",{\"1\":{\"102\":1,\"105\":1}}],[\"resize方法的扩容计算\",{\"0\":{\"220\":1}}],[\"resize\",{\"1\":{\"208\":4,\"219\":1}}],[\"result代表方法返回值\",{\"1\":{\"163\":2}}],[\"result\",{\"1\":{\"163\":2,\"205\":2}}],[\"restcontroller\",{\"1\":{\"116\":1,\"117\":1}}],[\"resttemplate\",{\"1\":{\"54\":6,\"65\":3,\"66\":4,\"83\":3}}],[\"resttemplateconfiguration\",{\"1\":{\"54\":1,\"83\":1}}],[\"resources\",{\"1\":{\"114\":1}}],[\"releases\",{\"1\":{\"133\":1}}],[\"release\",{\"1\":{\"105\":1}}],[\"read\",{\"1\":{\"91\":1,\"92\":2}}],[\"reactorloadbalancer<serviceinstance>\",{\"1\":{\"83\":1}}],[\"reactiveloadbalancer\",{\"1\":{\"81\":1}}],[\"retryableexception\",{\"1\":{\"92\":1}}],[\"retryer\",{\"1\":{\"88\":1,\"92\":3}}],[\"return\",{\"1\":{\"54\":2,\"65\":2,\"66\":1,\"83\":3,\"86\":1,\"90\":1,\"92\":1,\"106\":1,\"108\":3,\"109\":1,\"116\":1,\"117\":1,\"142\":1,\"143\":2,\"149\":1,\"161\":2,\"163\":1,\"165\":2,\"205\":10,\"206\":6,\"208\":1,\"212\":4,\"216\":1,\"218\":1,\"220\":1}}],[\"redisserializationcontext\",{\"1\":{\"161\":2,\"165\":2}}],[\"rediscacheconfiguration\",{\"1\":{\"161\":2,\"165\":2}}],[\"rediscachemanager\",{\"1\":{\"159\":1,\"161\":2,\"165\":2}}],[\"redisconfig\",{\"1\":{\"161\":1,\"165\":1}}],[\"redis\",{\"1\":{\"161\":1}}],[\"redis<\",{\"1\":{\"161\":1}}],[\"redis的maven坐标即可\",{\"1\":{\"160\":1}}],[\"red\",{\"1\":{\"21\":2}}],[\"rc2<\",{\"1\":{\"52\":1}}],[\"right\",{\"1\":{\"19\":1,\"209\":4}}],[\"r\",{\"1\":{\"12\":1,\"13\":1}}],[\"👆\",{\"1\":{\"12\":1,\"13\":1}}],[\"👇\",{\"1\":{\"2\":1}}],[\"布局\",{\"0\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1}}],[\"⚠请注意\",{\"1\":{\"10\":1}}],[\"你必须原地修改输入数组\",{\"1\":{\"209\":1}}],[\"你好\",{\"0\":{\"153\":1,\"155\":1,\"157\":1,\"169\":1,\"171\":1,\"173\":1,\"175\":1,\"177\":1,\"258\":1}}],[\"你需要在元素上添加\",{\"1\":{\"17\":1}}],[\"你可以尝试进行扩容\",{\"1\":{\"206\":1}}],[\"你可以对代码块进行高亮\",{\"1\":{\"32\":1}}],[\"你可以在相邻的幻灯片上添加\",{\"1\":{\"29\":1}}],[\"你可以在幻灯片中使用\",{\"1\":{\"4\":1,\"5\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1}}],[\"你可以使用\",{\"1\":{\"25\":1,\"32\":1}}],[\"你可以按照顺序包裹一个\",{\"1\":{\"23\":1}}],[\"你可以通过向特定幻灯片添加\",{\"1\":{\"15\":1}}],[\"你也可以使用\",{\"1\":{\"9\":1}}],[\"==========================================\",{\"1\":{\"212\":1}}],[\"======================================\",{\"1\":{\"212\":1}}],[\"==\",{\"1\":{\"206\":2,\"208\":1,\"212\":2,\"219\":2,\"221\":1,\"222\":3}}],[\"==e\",{\"1\":{\"205\":1}}],[\"=data\",{\"1\":{\"205\":1}}],[\"=path=\",{\"1\":{\"101\":2}}],[\"=>\",{\"1\":{\"32\":1}}],[\"=\",{\"1\":{\"8\":1,\"32\":3,\"54\":2,\"65\":8,\"83\":4,\"86\":3,\"90\":3,\"92\":2,\"93\":1,\"102\":1,\"106\":3,\"108\":1,\"109\":3,\"116\":4,\"117\":6,\"142\":1,\"143\":2,\"146\":6,\"149\":4,\"161\":7,\"163\":2,\"164\":2,\"165\":6,\"197\":2,\"203\":5,\"205\":9,\"206\":5,\"208\":5,\"209\":5,\"212\":12,\"213\":1,\"214\":2,\"215\":4,\"216\":1,\"217\":4,\"219\":4,\"220\":3,\"221\":6,\"222\":6}}],[\"abc\",{\"1\":{\"212\":1}}],[\"abstract\",{\"1\":{\"86\":1}}],[\"a关联b\",{\"1\":{\"142\":1}}],[\"annotationawareordercomparator\",{\"1\":{\"109\":1}}],[\"animate\",{\"1\":{\"29\":1}}],[\"add方法一定能添加成功的\",{\"1\":{\"211\":1}}],[\"addlast\",{\"1\":{\"205\":2,\"206\":1}}],[\"add\",{\"1\":{\"205\":4,\"206\":3,\"211\":2,\"212\":2}}],[\"addfirst\",{\"1\":{\"205\":2,\"206\":1}}],[\"addall\",{\"1\":{\"109\":1}}],[\"addresponseheader\",{\"1\":{\"105\":1}}],[\"addrequestheader=truth\",{\"1\":{\"106\":1,\"107\":1}}],[\"addrequestheader\",{\"1\":{\"105\":1}}],[\"addr=127\",{\"1\":{\"101\":1}}],[\"addr\",{\"1\":{\"63\":1,\"101\":1,\"114\":1}}],[\"attr\",{\"1\":{\"109\":1}}],[\"atguigu\",{\"1\":{\"53\":1,\"54\":1,\"89\":2,\"92\":1,\"93\":3,\"101\":1,\"161\":1,\"165\":1}}],[\"auth\",{\"1\":{\"134\":2}}],[\"authorizationfilter\",{\"1\":{\"108\":1}}],[\"autowired\",{\"1\":{\"54\":2,\"65\":3,\"86\":2,\"116\":1,\"117\":2}}],[\"auto\",{\"1\":{\"29\":1}}],[\"america\",{\"1\":{\"107\":1}}],[\"after=2017\",{\"1\":{\"107\":1}}],[\"after=2023\",{\"1\":{\"102\":1}}],[\"asia\",{\"1\":{\"102\":1}}],[\"arrays\",{\"1\":{\"212\":1}}],[\"array\",{\"1\":{\"197\":3,\"212\":1}}],[\"arraylist数组扩容机制\",{\"1\":{\"212\":1}}],[\"arraylist<>\",{\"1\":{\"212\":2}}],[\"arraylist<string>\",{\"1\":{\"212\":2}}],[\"arraylist底层会自动扩容\",{\"1\":{\"212\":1}}],[\"arraylist底层是数组\",{\"1\":{\"212\":1}}],[\"arraylist底层结构和扩容机制\",{\"0\":{\"210\":1}}],[\"arraylist源码总结\",{\"1\":{\"212\":1}}],[\"arraylist构造\",{\"1\":{\"212\":1}}],[\"arraylist是list的实现类\",{\"1\":{\"211\":1}}],[\"arraylist\",{\"1\":{\"109\":1,\"197\":1,\"212\":5}}],[\"archive\",{\"1\":{\"139\":1}}],[\"args\",{\"1\":{\"93\":2,\"101\":2,\"117\":2,\"203\":1}}],[\"artifactid>\",{\"1\":{\"52\":5,\"53\":4,\"63\":1,\"66\":1,\"86\":1,\"93\":4,\"101\":3,\"114\":1,\"136\":1,\"161\":2,\"165\":1}}],[\"acf3\",{\"1\":{\"76\":1}}],[\"applicationname\",{\"1\":{\"65\":2}}],[\"application\",{\"1\":{\"63\":1,\"101\":2,\"114\":1,\"119\":1}}],[\"api依赖\",{\"1\":{\"93\":1}}],[\"api项目中\",{\"1\":{\"93\":1}}],[\"api包中\",{\"1\":{\"93\":1}}],[\"api\",{\"1\":{\"54\":2,\"65\":1,\"66\":1,\"81\":1,\"86\":2,\"93\":2,\"98\":3,\"101\":3,\"102\":1,\"106\":1,\"107\":1,\"116\":1,\"117\":1,\"136\":1,\"138\":1,\"139\":1,\"142\":9,\"143\":10,\"145\":1,\"146\":1,\"149\":2}}],[\"apachejmeter\",{\"1\":{\"139\":1}}],[\"apache\",{\"1\":{\"53\":1,\"139\":3}}],[\"all\",{\"1\":{\"165\":1,\"214\":1}}],[\"alpha\",{\"1\":{\"134\":2}}],[\"aliases\",{\"1\":{\"53\":1}}],[\"alibaba的依赖\",{\"1\":{\"52\":1}}],[\"alibaba\",{\"1\":{\"52\":5,\"57\":1,\"63\":2,\"101\":2,\"114\":3,\"133\":1,\"136\":2}}],[\"alibaba组件\",{\"1\":{\"49\":1}}],[\"alt\",{\"1\":{\"38\":1}}],[\"a\",{\"0\":{\"178\":1},\"1\":{\"8\":1,\"32\":2,\"212\":1}}],[\"30\",{\"1\":{\"215\":1}}],[\"30<\",{\"1\":{\"52\":1}}],[\"34\",{\"1\":{\"190\":1}}],[\"3gateway工作流程\",{\"0\":{\"100\":1}}],[\"3过滤器\",{\"0\":{\"99\":1}}],[\"3openfeign自定义配置\",{\"0\":{\"87\":1}}],[\"3源码跟踪\",{\"0\":{\"81\":1}}],[\"3微服务配置名称空间\",{\"0\":{\"76\":1}}],[\"3微服务集成nacos\",{\"0\":{\"62\":1}}],[\"3集群访问\",{\"0\":{\"71\":1}}],[\"3其他问题须知\",{\"0\":{\"56\":1}}],[\"3306\",{\"1\":{\"53\":1}}],[\"3子工程搭建\",{\"0\":{\"53\":1}}],[\"3springcloud初体验\",{\"0\":{\"50\":1}}],[\"3分布式和集群\",{\"1\":{\"46\":1}}],[\"3\",{\"0\":{\"51\":1,\"52\":1,\"53\":1,\"57\":1,\"58\":1,\"59\":1,\"62\":1,\"63\":2,\"64\":2,\"65\":2,\"66\":2,\"67\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"88\":1,\"91\":1,\"92\":2,\"106\":1,\"115\":1,\"118\":1,\"131\":1,\"135\":1,\"137\":1,\"138\":1,\"139\":1,\"140\":2,\"144\":1,\"147\":1,\"161\":1,\"216\":1},\"1\":{\"7\":1,\"32\":1,\"63\":1,\"66\":1,\"81\":1,\"86\":1,\"91\":1,\"92\":1,\"93\":1,\"101\":1,\"105\":1,\"109\":1,\"117\":1,\"136\":1,\"138\":1,\"141\":1,\"142\":1,\"144\":1,\"145\":1,\"149\":2,\"161\":2,\"165\":1,\"190\":1,\"203\":1,\"206\":1}}],[\"256个数据中查找只要找8次就可以找到目标\",{\"1\":{\"193\":1}}],[\"2200ms\",{\"1\":{\"146\":1}}],[\"21之后才可以进行访问\",{\"1\":{\"102\":1}}],[\"21t10\",{\"1\":{\"102\":1}}],[\"23\",{\"1\":{\"102\":1,\"161\":1}}],[\"2断言\",{\"0\":{\"98\":1}}],[\"2三个核心概念\",{\"0\":{\"96\":1}}],[\"20\",{\"1\":{\"190\":1}}],[\"200\",{\"1\":{\"146\":2}}],[\"2000\",{\"1\":{\"91\":2,\"92\":2,\"146\":1}}],[\"2019\",{\"1\":{\"131\":1}}],[\"2018\",{\"1\":{\"131\":1}}],[\"2017\",{\"1\":{\"131\":1}}],[\"2013\",{\"1\":{\"131\":1}}],[\"2012\",{\"1\":{\"131\":1}}],[\"20220320162420189\",{\"1\":{\"149\":1}}],[\"20220320155202523\",{\"1\":{\"146\":1}}],[\"20220320155103019\",{\"1\":{\"146\":1}}],[\"20220320154801992\",{\"1\":{\"146\":1}}],[\"20220320153646510\",{\"1\":{\"145\":1}}],[\"20220320153522505\",{\"1\":{\"145\":1}}],[\"20220320153409220\",{\"1\":{\"145\":1}}],[\"20220320152944101\",{\"1\":{\"145\":1}}],[\"20220320150559229\",{\"1\":{\"143\":1}}],[\"20220320114459422\",{\"1\":{\"142\":1}}],[\"20220320112142379\",{\"1\":{\"139\":1}}],[\"20220320112040803\",{\"1\":{\"139\":1}}],[\"20220320111955904\",{\"1\":{\"139\":1}}],[\"20220320111824238\",{\"1\":{\"139\":1}}],[\"2020\",{\"1\":{\"131\":1}}],[\"20210714164856664\",{\"1\":{\"113\":1}}],[\"20231027163905542\",{\"1\":{\"143\":1}}],[\"20231027163806970\",{\"1\":{\"142\":1}}],[\"20231027093301407\",{\"1\":{\"100\":1}}],[\"20231025190315177\",{\"1\":{\"80\":1}}],[\"20231025144200255\",{\"1\":{\"72\":1}}],[\"20231025144212023\",{\"1\":{\"69\":1}}],[\"20231025184553633\",{\"1\":{\"69\":1}}],[\"20231025183451126\",{\"1\":{\"58\":1}}],[\"20231025183404072\",{\"1\":{\"55\":1}}],[\"20231025181951482\",{\"1\":{\"54\":1}}],[\"20231025150218218\",{\"1\":{\"61\":1}}],[\"20231025150223666\",{\"1\":{\"60\":1}}],[\"20231025150229500\",{\"1\":{\"58\":1}}],[\"20231025150235228\",{\"1\":{\"55\":1}}],[\"20231025150240929\",{\"1\":{\"55\":1}}],[\"20231025150247970\",{\"1\":{\"53\":1}}],[\"20231025150254012\",{\"1\":{\"53\":1}}],[\"20231025150259507\",{\"1\":{\"51\":1}}],[\"20231025150343310\",{\"1\":{\"46\":1}}],[\"20231025150331327\",{\"1\":{\"46\":1}}],[\"20231025150319539\",{\"1\":{\"46\":1}}],[\"20231025150308975\",{\"1\":{\"46\":1}}],[\"20230628102031276\",{\"1\":{\"149\":1}}],[\"20230628101715773\",{\"1\":{\"149\":1}}],[\"20230628101331468\",{\"1\":{\"148\":1}}],[\"20230628101216576\",{\"1\":{\"148\":1}}],[\"20230628101012945\",{\"1\":{\"148\":1}}],[\"20230628100914491\",{\"1\":{\"148\":1}}],[\"20230628100313331\",{\"1\":{\"146\":1}}],[\"20230628100049968\",{\"1\":{\"146\":1}}],[\"20230628100019712\",{\"1\":{\"146\":1}}],[\"20230628115300889\",{\"1\":{\"139\":1}}],[\"20230628095925921\",{\"1\":{\"145\":1}}],[\"20230628095505037\",{\"1\":{\"145\":1}}],[\"20230628095109686\",{\"1\":{\"144\":1}}],[\"20230628095013326\",{\"1\":{\"143\":1}}],[\"20230628094857374\",{\"1\":{\"143\":1}}],[\"20230628094814795\",{\"1\":{\"143\":1}}],[\"20230628094713655\",{\"1\":{\"143\":1}}],[\"20230628094648097\",{\"1\":{\"143\":1}}],[\"20230628094433574\",{\"1\":{\"143\":1}}],[\"20230628094306219\",{\"1\":{\"143\":1}}],[\"20230628093300378\",{\"1\":{\"142\":1}}],[\"20230628093126793\",{\"1\":{\"142\":1}}],[\"20230628092751648\",{\"1\":{\"142\":1}}],[\"20230628092515666\",{\"1\":{\"142\":1}}],[\"20230628092034118\",{\"1\":{\"142\":1}}],[\"20230628091856122\",{\"1\":{\"141\":1}}],[\"20230628090407483\",{\"1\":{\"139\":1}}],[\"20230624220603571\",{\"1\":{\"138\":1}}],[\"20230624220303385\",{\"1\":{\"136\":1}}],[\"20230624215704921\",{\"1\":{\"135\":1}}],[\"20230624215635555\",{\"1\":{\"135\":1}}],[\"20230624215403344\",{\"1\":{\"133\":1}}],[\"20230624215112184\",{\"1\":{\"133\":1}}],[\"20230624203730680\",{\"1\":{\"131\":1}}],[\"20230624203655208\",{\"1\":{\"131\":1}}],[\"20230624203508014\",{\"1\":{\"127\":1}}],[\"20230624203409785\",{\"1\":{\"126\":1}}],[\"20230624203334370\",{\"1\":{\"126\":1}}],[\"20230624203256590\",{\"1\":{\"125\":1}}],[\"20230624203222353\",{\"1\":{\"125\":1}}],[\"20230624203153340\",{\"1\":{\"124\":1}}],[\"20230624203044831\",{\"1\":{\"122\":1}}],[\"20230624200928589\",{\"1\":{\"118\":1}}],[\"20230624171530387\",{\"1\":{\"113\":1}}],[\"20230624171403235\",{\"1\":{\"111\":1}}],[\"20230624170925571\",{\"1\":{\"109\":1}}],[\"20230624164230054\",{\"1\":{\"104\":1}}],[\"20230624163811030\",{\"1\":{\"102\":1}}],[\"20230624163155679\",{\"1\":{\"101\":1}}],[\"20230624113033761\",{\"1\":{\"93\":1}}],[\"20230624103625541\",{\"1\":{\"91\":1}}],[\"20230624093650991\",{\"1\":{\"85\":1}}],[\"20230624093622996\",{\"1\":{\"85\":1}}],[\"20230721101903404\",{\"1\":{\"102\":1}}],[\"20230721101439700\",{\"1\":{\"101\":1}}],[\"20230721092532222\",{\"1\":{\"101\":1}}],[\"20230503224702411\",{\"1\":{\"81\":1}}],[\"20230503223822056\",{\"1\":{\"81\":1}}],[\"20230503213502251\",{\"1\":{\"79\":1}}],[\"20230503191655562\",{\"1\":{\"76\":1}}],[\"20230503191050511\",{\"1\":{\"75\":1}}],[\"20230503190738675\",{\"1\":{\"74\":1}}],[\"20230503185847770\",{\"1\":{\"74\":1}}],[\"20230503185416608\",{\"1\":{\"72\":1}}],[\"20230503183721175\",{\"1\":{\"70\":1}}],[\"20230503183655565\",{\"1\":{\"70\":1}}],[\"20230809102346561\",{\"1\":{\"70\":1}}],[\"20230809100204178\",{\"1\":{\"63\":1}}],[\"20t17\",{\"1\":{\"107\":1}}],[\"2openfeign初体验\",{\"0\":{\"86\":1}}],[\"2421acbff67a\",{\"1\":{\"76\":1}}],[\"2创建名称空间\",{\"0\":{\"75\":1}}],[\"2集群配置\",{\"0\":{\"70\":1}}],[\"2方案二\",{\"0\":{\"66\":1}}],[\"2远程调用\",{\"0\":{\"64\":1}}],[\"2注册中心产品\",{\"0\":{\"59\":1}}],[\"2传统方式调用的问题所在\",{\"0\":{\"55\":1}}],[\"2<\",{\"1\":{\"52\":1}}],[\"2springcloud组成\",{\"0\":{\"49\":1}}],[\"2微服务架构\",{\"0\":{\"46\":1}}],[\"2\",{\"0\":{\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"51\":1,\"52\":2,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"65\":1,\"66\":1,\"80\":1,\"91\":1,\"97\":1,\"98\":1,\"99\":1,\"105\":1,\"112\":1,\"113\":1,\"114\":2,\"115\":1,\"123\":1,\"132\":1,\"133\":1,\"134\":2,\"135\":1,\"136\":1,\"139\":1,\"160\":1,\"215\":1},\"1\":{\"7\":1,\"32\":2,\"53\":1,\"61\":4,\"63\":1,\"66\":1,\"71\":1,\"77\":1,\"81\":2,\"83\":1,\"86\":1,\"91\":1,\"92\":1,\"93\":1,\"98\":1,\"101\":1,\"105\":3,\"106\":1,\"109\":1,\"114\":1,\"117\":1,\"134\":2,\"136\":1,\"138\":1,\"139\":1,\"141\":1,\"142\":2,\"143\":2,\"144\":1,\"145\":1,\"146\":2,\"149\":2,\"161\":2,\"165\":1,\"203\":2,\"205\":1,\"206\":1,\"208\":2,\"212\":1,\"216\":3}}],[\"1st\",{\"1\":{\"222\":1}}],[\"1=1\",{\"1\":{\"221\":2}}],[\"1=0\",{\"1\":{\"221\":2}}],[\"1111\",{\"1\":{\"221\":4}}],[\"1规则\",{\"1\":{\"216\":1}}],[\"16\",{\"1\":{\"213\":1,\"216\":1}}],[\"168\",{\"1\":{\"61\":1,\"114\":1,\"161\":1}}],[\"1234\",{\"1\":{\"161\":1}}],[\"12\",{\"1\":{\"146\":1,\"213\":1}}],[\"127\",{\"1\":{\"101\":1}}],[\"1限流\",{\"1\":{\"142\":1}}],[\"1请求限流\",{\"1\":{\"142\":1}}],[\"1秒内运行完\",{\"1\":{\"139\":1}}],[\"1073741824\",{\"1\":{\"215\":1}}],[\"103\",{\"1\":{\"149\":2}}],[\"102\",{\"1\":{\"149\":2}}],[\"101\",{\"1\":{\"149\":2}}],[\"10103\",{\"1\":{\"70\":1}}],[\"10101\",{\"1\":{\"70\":1}}],[\"10100\",{\"1\":{\"53\":1,\"54\":2,\"136\":1}}],[\"1000\",{\"1\":{\"221\":1}}],[\"1000ms\",{\"1\":{\"146\":1}}],[\"100秒\",{\"1\":{\"142\":1}}],[\"10\",{\"1\":{\"145\":1,\"190\":1,\"197\":1,\"212\":4,\"215\":1}}],[\"10个线程\",{\"1\":{\"139\":1}}],[\"1调用2直接返回兜底数据\",{\"1\":{\"126\":1}}],[\"1调用2\",{\"1\":{\"126\":1}}],[\"1时\",{\"1\":{\"101\":1}}],[\"1路由\",{\"0\":{\"97\":1}}],[\"1认识gateway\",{\"0\":{\"95\":1}}],[\"1openfeign组件介绍\",{\"0\":{\"85\":1}}],[\"1简介\",{\"0\":{\"79\":1}}],[\"1环境隔离概述\",{\"0\":{\"74\":1}}],[\"1集群概述\",{\"0\":{\"69\":1}}],[\"1服务集群\",{\"0\":{\"68\":1}}],[\"1方案一\",{\"0\":{\"65\":1}}],[\"1准备工作\",{\"0\":{\"63\":1}}],[\"142\",{\"1\":{\"61\":1,\"114\":1,\"161\":1}}],[\"136\",{\"1\":{\"61\":1,\"114\":1,\"161\":1}}],[\"192\",{\"1\":{\"61\":1,\"114\":1,\"161\":1}}],[\"1传统调用\",{\"0\":{\"54\":1}}],[\"1<\",{\"1\":{\"52\":1}}],[\"1工程结构说明\",{\"0\":{\"51\":1}}],[\"1什么是springcloud\",{\"0\":{\"48\":1}}],[\"1单体架构\",{\"0\":{\"45\":1}}],[\"1\",{\"0\":{\"44\":1,\"45\":1,\"46\":1,\"58\":1,\"69\":1,\"70\":1,\"71\":1,\"88\":1,\"104\":1,\"111\":1,\"113\":1,\"121\":1,\"122\":2,\"123\":1,\"131\":1,\"133\":1,\"138\":1,\"159\":2,\"160\":1,\"161\":1,\"162\":1,\"165\":1,\"214\":1,\"276\":1},\"1\":{\"7\":1,\"8\":1,\"32\":2,\"46\":1,\"54\":1,\"63\":1,\"66\":1,\"71\":1,\"72\":1,\"77\":1,\"81\":3,\"83\":1,\"86\":1,\"91\":1,\"92\":2,\"93\":1,\"98\":1,\"101\":7,\"105\":1,\"106\":1,\"109\":1,\"114\":1,\"117\":1,\"136\":2,\"138\":1,\"139\":1,\"141\":1,\"142\":3,\"143\":2,\"144\":1,\"145\":1,\"146\":4,\"149\":2,\"161\":2,\"165\":1,\"190\":1,\"193\":4,\"203\":2,\"205\":4,\"206\":3,\"209\":2,\"212\":6,\"215\":1,\"216\":5,\"220\":2,\"221\":5,\"222\":2,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":1,\"256\":1}}],[\"项目\",{\"0\":{\"277\":1},\"1\":{\"7\":6}}],[\"列表默认为\",{\"1\":{\"7\":1}}],[\"斜体\",{\"1\":{\"6\":1}}],[\"粗体\",{\"1\":{\"6\":1}}],[\"标记资源\",{\"1\":{\"149\":1}}],[\"标记userservice中的queryusers方法为一个sentinel监控的资源\",{\"1\":{\"143\":1}}],[\"标准语法中的内容均不受支持\",{\"1\":{\"10\":1}}],[\"标题默认会自动转换为大写\",{\"1\":{\"6\":1}}],[\"标注水平幻灯片\",{\"1\":{\"3\":1}}],[\"标注幻灯片\",{\"0\":{\"2\":1,\"3\":1}}],[\"min\",{\"1\":{\"213\":1}}],[\"mincapacity\",{\"1\":{\"212\":13}}],[\"mvc资源无效\",{\"1\":{\"149\":1}}],[\"mvc的所有请求设置同一个root资源\",{\"1\":{\"143\":1}}],[\"mvc的每一个端点就是调用链路中的一个资源\",{\"1\":{\"138\":1}}],[\"mvc的每一个端点\",{\"1\":{\"138\":1}}],[\"mesh\",{\"1\":{\"131\":2}}],[\"modcount++\",{\"1\":{\"212\":1}}],[\"modcount\",{\"1\":{\"212\":1}}],[\"model<\",{\"1\":{\"93\":2}}],[\"model\",{\"1\":{\"93\":2}}],[\"mode=standalone\",{\"1\":{\"61\":1}}],[\"mono<void>\",{\"1\":{\"108\":1,\"109\":1}}],[\"m\",{\"1\":{\"61\":1}}],[\"mylinkedlistv1\",{\"0\":{\"249\":1}}],[\"myqueue\",{\"0\":{\"241\":1}}],[\"mystack\",{\"0\":{\"233\":1}}],[\"mysql的驱动\",{\"1\":{\"52\":1,\"53\":1}}],[\"mysql\",{\"0\":{\"260\":1},\"1\":{\"52\":2,\"53\":2}}],[\"myarraygeneric\",{\"1\":{\"206\":2}}],[\"myarraygeneric<e>\",{\"1\":{\"206\":1}}],[\"myarray\",{\"1\":{\"205\":3}}],[\"mybatis和spring\",{\"1\":{\"52\":1,\"53\":1}}],[\"mybatis\",{\"1\":{\"52\":3,\"53\":2}}],[\"map\",{\"1\":{\"217\":1}}],[\"mapping中找到与请求匹配的路由\",{\"1\":{\"100\":1}}],[\"mapper\",{\"1\":{\"53\":2,\"138\":1}}],[\"maximum\",{\"1\":{\"215\":3,\"216\":2,\"220\":2}}],[\"max\",{\"1\":{\"212\":3,\"220\":1}}],[\"maxthreshold\",{\"1\":{\"145\":1}}],[\"main\",{\"1\":{\"93\":1,\"101\":1,\"114\":1,\"117\":1,\"203\":1}}],[\"maven\",{\"1\":{\"52\":2,\"53\":2}}],[\"math\",{\"1\":{\"9\":1,\"212\":2}}],[\"markdown\",{\"0\":{\"4\":1,\"5\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1},\"1\":{\"4\":1,\"5\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":2,\"41\":1},\"2\":{\"151\":1,\"167\":1}}],[\"mr\",{\"1\":{\"1\":1}}],[\"hugecapacity\",{\"1\":{\"212\":1}}],[\"host\",{\"1\":{\"161\":1}}],[\"hot\",{\"1\":{\"149\":1}}],[\"hope\",{\"1\":{\"1\":1}}],[\"hash\",{\"1\":{\"217\":5,\"218\":2,\"221\":4,\"222\":4}}],[\"hashmap中的内部类node非常重要\",{\"1\":{\"217\":1}}],[\"hashmap中的静态成员变量\",{\"1\":{\"214\":1}}],[\"hashmap有参数构造方法分析\",{\"0\":{\"215\":1}}],[\"hashmap\",{\"1\":{\"214\":1,\"215\":2}}],[\"hashmap无参数构造方法的分析\",{\"0\":{\"214\":1}}],[\"hashmap默认加载因子\",{\"1\":{\"213\":1}}],[\"hashmap默认容量\",{\"1\":{\"213\":1}}],[\"hashmap创建出来\",{\"1\":{\"213\":1}}],[\"hashmap底层数据结构\",{\"1\":{\"213\":1}}],[\"hashmap底层结构和扩容机制\",{\"0\":{\"213\":1}}],[\"hastext\",{\"1\":{\"108\":1}}],[\"haha\",{\"1\":{\"155\":1}}],[\"handle\",{\"1\":{\"109\":1}}],[\"handle方法会加载全局过滤器\",{\"1\":{\"109\":1}}],[\"handlermapper基础框架的一部分\",{\"1\":{\"102\":1}}],[\"handler再通过指定的过滤器链来将请求发送给我们实际的服务执行业务逻辑\",{\"1\":{\"100\":1}}],[\"handler\",{\"1\":{\"100\":2,\"109\":1}}],[\"header\",{\"1\":{\"106\":3,\"116\":3,\"117\":3,\"149\":3}}],[\"headers\",{\"1\":{\"88\":1,\"89\":1}}],[\"http远程调用的结果做解析\",{\"1\":{\"88\":1}}],[\"httpstatus\",{\"1\":{\"108\":1}}],[\"https\",{\"1\":{\"85\":1,\"102\":1,\"105\":1,\"131\":1,\"133\":1,\"139\":1}}],[\"http\",{\"1\":{\"54\":1,\"61\":1,\"65\":1,\"66\":1,\"81\":1,\"91\":1,\"101\":1}}],[\"html\",{\"1\":{\"3\":1,\"23\":1,\"29\":1,\"102\":1,\"105\":1}}],[\"highlight\",{\"1\":{\"8\":1,\"21\":6,\"32\":1}}],[\"h3\",{\"0\":{\"6\":1}}],[\"在数组中仍然有我们已经出栈的对象的指针\",{\"1\":{\"234\":1}}],[\"在第一次put的时候\",{\"1\":{\"213\":1}}],[\"在不指定长度时\",{\"1\":{\"213\":1}}],[\"在索引位置添加1\",{\"1\":{\"205\":1}}],[\"在所有数据结构中\",{\"1\":{\"197\":1}}],[\"在描述算法复杂度时\",{\"1\":{\"193\":1}}],[\"在categoryserviceimpl类中的findcategorytree方法上添加\",{\"1\":{\"165\":1}}],[\"在service\",{\"1\":{\"165\":1}}],[\"在spzx\",{\"1\":{\"93\":1,\"101\":1,\"106\":1,\"114\":2}}],[\"在spring\",{\"1\":{\"160\":1,\"161\":1}}],[\"在springcache中提供了很多缓存操作的注解\",{\"1\":{\"160\":1}}],[\"在springcloud这个项目中包含很多的组件\",{\"1\":{\"48\":1}}],[\"在spring容器中注册一个bean\",{\"1\":{\"83\":1}}],[\"在方法执行前\",{\"1\":{\"161\":1}}],[\"在方法执行前spring先查看缓存中是否有数据\",{\"1\":{\"160\":1}}],[\"在流控的高级选项中\",{\"1\":{\"144\":1}}],[\"在弹出的表单中填写下面信息\",{\"1\":{\"143\":1}}],[\"在这两个端点中分别调用userservice中的queryusers方法\",{\"1\":{\"143\":1}}],[\"在jmeter中进行测试\",{\"1\":{\"142\":1}}],[\"在userserviceimpl类中的findbyid方法上添加\",{\"1\":{\"161\":1}}],[\"在userservice中添加一个queryusers方法\",{\"1\":{\"143\":1}}],[\"在usercontroller中\",{\"1\":{\"143\":1}}],[\"在usercontroller新建一个端点\",{\"1\":{\"142\":1}}],[\"在user模块配置文件添加配置\",{\"1\":{\"69\":1}}],[\"在添加限流规则时\",{\"1\":{\"141\":1}}],[\"在阿里巴巴集团内部迅速发展\",{\"1\":{\"131\":1}}],[\"在部分服务故障时\",{\"1\":{\"127\":1}}],[\"在高并发情况下\",{\"1\":{\"122\":1}}],[\"在微服务系统架构中\",{\"1\":{\"122\":1}}],[\"在gateway中提供了三种级别的类型的过滤器\",{\"1\":{\"105\":1}}],[\"在gateway中提供了很多的路由工厂如下所示\",{\"1\":{\"102\":1}}],[\"在gateway中要实现其他的功能\",{\"1\":{\"104\":1}}],[\"在控制台可以看到如下信息\",{\"1\":{\"102\":1}}],[\"在网关模块中配置文件中\",{\"1\":{\"101\":1}}],[\"在\",{\"1\":{\"100\":1,\"118\":1}}],[\"在basic的基础上\",{\"1\":{\"89\":1}}],[\"在启动类上添加\",{\"1\":{\"86\":1,\"117\":1,\"161\":1,\"165\":1}}],[\"在loadbalancerclient的choose方法通过reactiveloadbalancer\",{\"1\":{\"80\":1}}],[\"在nacos服务端创建一个配置\",{\"1\":{\"113\":1}}],[\"在nacos是通过namespace来实现多环境的隔离\",{\"1\":{\"74\":1}}],[\"在nacos控制台\",{\"1\":{\"72\":1}}],[\"在实际的开发过程中\",{\"1\":{\"74\":1}}],[\"在实际生产环境中\",{\"1\":{\"69\":1}}],[\"在配置文件中进行权重配置\",{\"1\":{\"72\":1}}],[\"在访问bj集群中的实例\",{\"1\":{\"71\":1}}],[\"在调用端order进行配置\",{\"1\":{\"69\":1}}],[\"在调用端order模块创建user实体类\",{\"1\":{\"54\":1}}],[\"在调用端order模块创建配置类\",{\"1\":{\"54\":1}}],[\"在服务端user进行配置\",{\"1\":{\"69\":1}}],[\"在声明resttemplate的方法上添加\",{\"1\":{\"66\":1}}],[\"在application\",{\"1\":{\"63\":1,\"101\":1,\"161\":1}}],[\"在两个子工程中引入如下依赖\",{\"1\":{\"63\":1}}],[\"在注册中心会维护一张服务清单\",{\"1\":{\"58\":1}}],[\"在order微服务中添加依赖\",{\"1\":{\"66\":1}}],[\"在order微服务的spring容器中注册一个resttemplate\",{\"1\":{\"54\":1}}],[\"在order实现类的方法使用resttemplate发起远程调用\",{\"1\":{\"54\":1}}],[\"在resourse目录下面创建一个application\",{\"1\":{\"53\":1}}],[\"在子模块中添加依赖\",{\"1\":{\"53\":1}}],[\"在dependencymanagement标签中所定义的依赖不会被子工程直接进行继承\",{\"1\":{\"52\":1}}],[\"在创建微服务工程的时候都需要先提供一个工程\",{\"1\":{\"51\":1}}],[\"在你启用\",{\"1\":{\"8\":1,\"9\":1}}],[\"在前一个\",{\"1\":{\"3\":1}}],[\"在幻灯片上添加属性\",{\"1\":{\"3\":1}}],[\"在水平幻灯片中使用\",{\"1\":{\"3\":1}}],[\">2\",{\"1\":{\"221\":1}}],[\">3\",{\"1\":{\"221\":1}}],[\">96355\",{\"1\":{\"221\":1}}],[\">无论指定了多少容量\",{\"1\":{\"216\":1}}],[\">创建map集合的时候指定底层数组长度以及加载因子\",{\"1\":{\"215\":1}}],[\">扩容大小是2倍\",{\"1\":{\"213\":1}}],[\">代表当元素存储到百分之75的时候就要扩容了\",{\"1\":{\"213\":1}}],[\">>>\",{\"1\":{\"216\":5}}],[\">>\",{\"1\":{\"212\":1}}],[\">数组\",{\"1\":{\"212\":2}}],[\">1179410\",{\"1\":{\"221\":1}}],[\">15\",{\"1\":{\"221\":2}}],[\">10\",{\"1\":{\"212\":5}}],[\">1\",{\"1\":{\"212\":3}}],[\">arrays\",{\"1\":{\"212\":1}}],[\">获取集合元素个数\",{\"1\":{\"211\":1}}],[\">根据索引获取元素\",{\"1\":{\"211\":1}}],[\">将元素放在数组中\",{\"1\":{\"221\":1}}],[\">将元素添加到集合中\",{\"1\":{\"211\":1}}],[\">将指定索引位置上的元素\",{\"1\":{\"211\":1}}],[\">删除指定索引位置上的元素\",{\"1\":{\"211\":1}}],[\">删除指定的元素\",{\"1\":{\"211\":1}}],[\">在指定索引位置上添加元素\",{\"1\":{\"211\":1}}],[\">=\",{\"1\":{\"92\":1,\"203\":1,\"216\":1,\"220\":2,\"222\":1}}],[\">\",{\"1\":{\"3\":2,\"23\":2,\"52\":7,\"53\":4,\"63\":1,\"66\":1,\"86\":1,\"93\":3,\"101\":3,\"109\":2,\"114\":1,\"119\":2,\"136\":1,\"143\":2,\"161\":1,\"163\":1,\"164\":1,\"211\":1,\"212\":6,\"215\":1,\"220\":1}}],[\"<<\",{\"1\":{\"215\":1,\"220\":2}}],[\"<=\",{\"1\":{\"215\":1}}],[\"<artifactid>spzx\",{\"1\":{\"93\":2}}],[\"<artifactid>spring\",{\"1\":{\"52\":3,\"53\":1,\"63\":1,\"66\":1,\"86\":1,\"93\":1,\"101\":3,\"114\":1,\"136\":1,\"161\":2,\"165\":1}}],[\"<artifactid>lombok<\",{\"1\":{\"53\":1,\"93\":1}}],[\"<artifactid>mybatis\",{\"1\":{\"52\":1,\"53\":1}}],[\"<artifactid>mysql\",{\"1\":{\"52\":1,\"53\":1}}],[\"<groupid>mysql<\",{\"1\":{\"52\":1,\"53\":1}}],[\"<groupid>com\",{\"1\":{\"52\":1,\"63\":1,\"93\":2,\"101\":1,\"114\":1,\"136\":1}}],[\"<groupid>org\",{\"1\":{\"52\":3,\"53\":3,\"66\":1,\"86\":1,\"93\":2,\"101\":2,\"161\":2,\"165\":1}}],[\"<scope>import<\",{\"1\":{\"52\":2}}],[\"<spring\",{\"1\":{\"52\":2}}],[\"<type>pom<\",{\"1\":{\"52\":2}}],[\"<version>1\",{\"1\":{\"93\":2}}],[\"<version>$\",{\"1\":{\"52\":4}}],[\"<version>3\",{\"1\":{\"52\":1}}],[\"<dependency>\",{\"1\":{\"52\":4,\"53\":4,\"63\":1,\"66\":1,\"86\":1,\"93\":4,\"101\":3,\"114\":1,\"136\":1,\"161\":2,\"165\":1}}],[\"<dependencymanagement>\",{\"1\":{\"52\":1}}],[\"<dependencies>\",{\"1\":{\"52\":1,\"53\":1}}],[\"<parent>\",{\"1\":{\"52\":1}}],[\"<project\",{\"1\":{\"52\":1,\"53\":1}}],[\"<properties>\",{\"1\":{\"52\":1,\"53\":1}}],[\"<mysql\",{\"1\":{\"52\":1}}],[\"<mybatis\",{\"1\":{\"52\":1}}],[\"<maven\",{\"1\":{\"52\":2,\"53\":2}}],[\"<\",{\"1\":{\"3\":2,\"52\":19,\"53\":10,\"63\":2,\"66\":2,\"86\":2,\"93\":7,\"101\":6,\"114\":2,\"136\":2,\"161\":2,\"165\":1,\"203\":1,\"208\":1,\"212\":1,\"215\":1,\"216\":1,\"220\":1}}],[\"幻灯片演示\",{\"0\":{\"1\":1}}],[\"幻灯片页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
